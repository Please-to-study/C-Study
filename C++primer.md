## 2.3 复合类型

### 2.3.1 引用

1. 程序把引用和它的初始值绑定到一起，而不是将初始值拷贝给引用。一定初始化完成，引用将和它的初始值对象一直绑定到一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
2. 引用并非对象，相反的它只是为一个已经存在的对象所起的另外一个名字。
3. 引用的类型都要和与之绑定的对象严格匹配。（但有两种例外情况）
4. 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。

### 2.3.2 指针

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须再定义的时候赋初值。和其它内置类型一样，再块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

3. 指针的类型都要和它所指向的对象严格匹配。（但有两种例外情况）

#### 空指针

空指针不指向任何对象。

```c++
# 生成空指针的方法
int *p = nullptr;
int *p = 0;
//需要首先#include cstdlib
int *p = NULL;
```

#### void* 指针

void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址追踪到底是个什么类型的对象并不了解。

利用void* 指针能做的事比较有限：拿他和别的指针比较、作为函数的输入输出、或者赋值给另外一个void\*指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

### 2.4 const限定符

#### 2.4.1 const的引用

1. 把引用绑定到const对象上，我们称之为**对常量的引用**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci = 1024;
const int &r1 = ci;
r1 = 0;  // 错误：ri是对常量的引用，常量无法被修改。
int &r2 = ci; // 错误：试图让一个非常量引用指向一个常量对象。他们的类型不一致！
```

**引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是：在初始化常量引用的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式**

```c++
int i = 42;
const int &r1 = i; // 允许将const int&绑定到一个普通int对象上;
const int &r2 = 42; // 正确：r2是一个常量引用;
const int &r3 = r1 * 2; // 正确： r3是一个常量引用;
int &r4 = r1 * 2;  // 错误：r4是一个普通的非常量引用;
```

**对const的引用可能引用一个并非const的对象**

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 42;
int &r1 = i; // 引用r1绑定对象i
const int &r2 = i; // r2也绑定对象i,但是不允许通过r2来修改i的值;
r1 = 0; // r1并非常量,i的值修改为0;
r2 = 0; // 错误：r2是一个常量引用，不可以做修改操作;
```

### 2.4.2 指针和const

与引用一样，也可以令指针指向常量或非常量.类似于常量引用，**指向常量的指针**不能用于改变其所指对象的值。

指针的类型必须与其所指向对象的类型一致，但是有两个例外。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象。

```c++
const double pi = 3.14; //pi是一个常量，他的值不能改变; 
double *ptr = &pi; // 错误：ptr 是一个普通指针;
const double *cptr = &pi; // 正确：cptr可以指向一个双精度常量;
*cptr = 42; // 错误：cptr指向的是一个常量，不能给cptr赋值;
double dval = 3.14;
cptr = &dval; // 正确：但是不能通过cptr改变dval的值;
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量，所为指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

> 所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以不觉得不去改变所指对象的值。

### 2.4.3 顶层const 

**顶层const **:表示指针本身是个常量。

**底层const**:表示指针所指对象是一个常量。

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显，其中顶层const不受什么影响。顶层const只是标注了变量本身是const不允许改变，而底层const表示了变量所指的对象的类型，在拷贝时要求拷贝对象和被拷贝对象类型一致！

### 2.4.4 constexpr 和常量表达式

**常量表达式**是指值不会改变并且在编译过程中就能得到计算结果的表达式。

一个对象或表达式是不是常量表达式由他的数据类型和初始值共同决定。

#### 字面值类型

常量表达式的值需要再编译时就得到计算，因此对声明constexptr时用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见、容易得到，就称之为“字面值类型” 算术类型、引用和指针都属于字面值类型。

一个constexpr指针的初始值必须是nullptr或者0，或者是存储在某个固定地址中的对象。

函数体外的对象其地址固定不变，能用来初始化constexpr指针。

函数体内定义的变量一般来说并非存放在固定地址中，不能初始化constexpr指针，但是函数体内也可以定义一类有效范围超出函数本身的变量，这类变量也有固定地址。

```c++
const int *p = nullptr; //p是一个指向整型常量的指针;
constexpr int *q = nullptr; // q是一个指向证书的常量指针
```

## 2.5 处理类型

### 2.5.1 类型别名

有两种方法可用于定义类型别名：

```c++
1.传统方法typedef:
typedef double wages; // wages是double的同义词
2.别名声明:
using SI = Sales_item; // SI是Sales_item的同义词
```

### 2.5.2 auto类型说明符

auto类型说明符能让编译器通过初始值来推算变量的类型，显然auto定义的变量必须有初始值。

auto一般会忽略掉顶层const，同时底层const则会保留下来。变量b、c是案例。

设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留！变量g是案例。

例子：

```c++
	 int i = 0, &r = i;
   auto a = r;   // auto = int a是整数
   const int ci = i, &cr = ci; 
   auto b = ci; // auto = int b是整数
   auto c = cr; // auto = int c是整数
   auto d = &i; // auto = int d是i的地址值
   auto e = &ci; // auto = int e是i的地址值
   auto &g = ci; // auto = const int  g是整型常量引用 绑定到ci上
```

### 2.5.3 decltype 类型指示符

**decltype**：它的作用是选择并返回操作数的数据类型。

decltype处理顶层const和引用的方式与auto有些不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&, y绑定到变量x 
decltype(ci) cj z; // 错误：z是一个引用，必须初始化
```

**需要指出的是，引用从来都是作为其所指对象的同义词出现，只有用在decltype处是一个例外**

#### decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

r是个引用，所以decltype(r)的结果是引用类型，如果想让结果类型是r所指对象的类型，可以把r作为表达式的一部分，例如r+0.

如果表达式的内容是解引用操作，则decltype将得到引用类型.

```c++
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // 正确：加法的结果是int,因此b是一个（未初始化的）int
decltype(*p) c; // 错误：c是int&,必须初始化
```

如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式，decltype就会得到引用类型：

```c++
decltype((i)) d; //错误： d是int&,必须初始化
decltype(i) e; // 正确：e是一个（未初始化的）int
```

> !切记：decltype((variable))（主义是双层括号）的结果永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。

## 2.6 自定义数据结构

### 2.6.3 编写自己的头文件

#### 预处理器概述

预处理变量有两种状态：已定义和未定义。

**#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**ifndef**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到**#endif**指令为止。

> 预处理变量无视C++语言中关于作用的规则。

> 头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符

# 第3章 字符串、向量和数组

## 3.1 命名空间的using声明

有了using声明就无需专门的前缀（形如命名空间::）也能使用所需的名字了。

using声明具有如下的形式:

```c++
using namespace::name;
// 一旦声明了上述语句，就可以直接访问命名空间中的名字
```

> **!头文件不应包含using声明**

## 3.2 标准库类型 string

### 3.2.1 定义和初始化string对象

![image-20211115175652876](https://cdn.pkubailu.cn/img/3.1.png)

#### 直接初始化和拷贝初始化

如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化。

### 3.2.2 string对象上的操作

![image-20211115180215371](https://cdn.pkubailu.cn/img/3.2.png)

#### 读写string对象

```c++
int main() 
{
  string s;
  cin >> s;
  cout << s << endl;
  return0;
}
// 在执行读取操作时，string对象会自动忽略开头的空白（即空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。
// 如果输入是"    hello world!    "则输出将是"hello"
```

#### 使用getline读取一整行

如果希望在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的>>运算符。

getline从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始输入的是换行符，那么所得的结果是个空string。

#### 比较 string 对象

字典序规则！

### 3.2.3 处理string对象中的字符

![image-20211115191804174](https://cdn.pkubailu.cn/img/3.3.png)

### 3.2.3 处理string对象中的字符

#### 处理每个字符？使用基于范围的for语句

语法形式：

```c++
for (declaration : expression)
  statement
```

## 3.3 标准库类型 vector

编译器根据模板创建类或函数的过程成为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

> vector 是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>

### 3.3.1 定义和初始化vector对象

![image-20211119003835476](https://cdn.pkubailu.cn/img/3.4.png)

#### 列表初始化vector对象

在大多数情况下这些初始化方式可以相互等价的使用，不过也并非一直如此。两种例外情况如下：

1. 使用拷贝初始化时（即使用=时）只能提供一个初始值；
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。

第三种特殊的要求是，如果提供的是初始元素值的列表，则只能爸初始值都放在花括号里进行列表初始化。

#### 值初始化

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个**值初始化的**元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。

```C++
vector<int> ivec(10); //10个元素 每个都初始化为0
vector<string> svec(10) // 10个元素，每个都是空的string对象
```

对这种初始化的方式有两个特殊限制：

1. 有些类要求必须明确的提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始化的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：

```C++
vector<int> vi = 10; // 错误：必须使用直接初始化的形式指定向量大小
```

#### 列表初始值还是元素数量

![image-20211121004224917](https://cdn.pkubailu.cn/img/列表初始值还是元素数量1.png)

![image-20211121004346187](https://cdn.pkubailu.cn/img/列表初始值还是元素数量2.png)

### 3.3.2 向vector对象中添加元素

可以先创建一个空的vector对象，然后在运行时再利用vector的成员函数**push_back**向其中添加元素。

>! 范围for语句体内不应该改变其所遍历序列的大小。

### 3.3.3 其他vector操作

![image-20211121005240108](https://cdn.pkubailu.cn/img/3.5.png)

> Note: 要使用size_type，需要先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型
>
> ```C++
> vector<int>::size_type  // 正确
> vector::size_type  // 错误
> ```

两个vector对象相等当且仅当他们所含的元素个数相同，而且对应位置的元素值也相同。

关系运算符依照字典顺序进行比较:如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。

只有当元素的值可比较时，vector对象才能被比较。

## 3.4 迭代器介绍

有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

### 3.4.1 使用迭代器

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。这些类型都拥有名为**begin**和**end**的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器，end成员则负责返回指向容器”尾元素的下一位置“的迭代器，简称为尾迭代器。

#### 迭代器运算符

![3.6](https://cdn.pkubailu.cn/img/3.6.png)

#### 将迭代器从一个元素移动到另外一个元素

迭代器使用递增（++）运算符来从一个元素移动到下一个元素。

> Note:因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。

#### 迭代器类型

迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型

![迭代器类型](https://cdn.pkubailu.cn/img/迭代器类型.png)

Const_iterator和常量指针差不多，鞥读取但不能修改它所值的元素值。相反，iterator的对象可读可写。

#### begin和end运算符

```C++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 的类型是vector<int>::iterator
auto it2 = cv.begin(); // it1 的类型是vector<int>::const_iterator
```

为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend：

```C++
auto it3 = v.cbegin(); // it3 的类型是vector<int>::const_iterator
```

不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

#### 结合解引用和成员访问操作

```C++
(*it).empty() // 解引用it，然后调用结果对象的empty()成员
*it.empty()  //错误： 试图访问it的名为empty的成员，但it是个迭代器，没有empty成员
```

为了简化上述表达式，C++语言定义了**箭头运算符**(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it->mem和(*it).mem表达的意思相同。

#### 某些对vector对象的操作会使迭代器失效

>**谨记！，但凡是使用了迭代器的循环体，都不要向迭代其所属的容器添加元素。**

### 3.4.2 迭代器运算

![3.7](https://cdn.pkubailu.cn/img/3.7.png)

#### 迭代器的算术运算

对于string或vector的迭代器来说，除了判断是否相等，还能使用关系运算符(<、<=、>、>=)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。例如，假设it和mid是同一个vector对象的两个迭代器，可以用下面的代码来比较他们所指的位置谁前谁后：

```C++
if (it < mid)
	// 处理vector前半部分的元素
```

## 3.5 数组

### 3.5.1 定义和初始化内置数组

默认情况下，数组的元素被默认初始化

> Warning! 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

#### 显示初始化数组

![显示初始化数组](https://cdn.pkubailu.cn/img/显示初始化数组.png)

#### 字符数组的特殊性

![字符数组的特殊性](https://cdn.pkubailu.cn/img/字符数组的特殊性.png )

#### 不允许拷贝和赋值

![不允许拷贝和赋值](https://cdn.pkubailu.cn/img/不允许拷贝和赋值.png )

#### 理解复杂的数组声明

定义数组的指针和数组的引用:

![数组的指针和数组的引用](https://cdn.pkubailu.cn/img/数组的指针和数组的引用.png )

对于数组而言，由内向外阅读要比从右向左好多了。例如：首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。

### 3.5.2 访问数组元素

最好的办法是使用范围for语言。

### 3.5.3 指针和数组

> Note: 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

这一结论有很多隐含的意思：

1. 当使用数组作为一个auto变量的初始值时。推断得到的类型是指针而非是数组：

```C++
int ia[] = {0,1,2,3,4}; // ia 是一个含有5个证书的数组
auto ia2(ia); // ia2是一个整型指针,指向ia的第一个元素
ia2 = 42; // 错误：ia2是一个指针，不能用int值给指针赋值
```

必须指出的是，当时用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个帧数构成的数组：

```C++
// ia3 是一个含有10个整数的数组
decltype(ia) ia3 = {0,1,2,3,4};
ia3 = p; // 错误：不能用整形指针给数组赋值
ia3[4] = i; //正确：把i的值赋给ia3的一个元素
```

#### 指针也是迭代器

允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

```C++
int arr[] = {0,1,2,3,4};
int *p = arr; // p指向arr的第一个元素
++p; // p指向arr[1]
```

利用指针的循环

```C++
int *e = &arr[10];
for (int *b = arr; b != e; ++b)
  cout << *b <<endl;
```

#### 标准库函数begin和end

C++新标准引入了两个名为begin和end的函数

```C++
int ia[] = {0,1,2,3,4}; // ia是一个含有10个整数的数组
int *beg = begin(ia); //指向ia首元素的指针
int *last = end(ia); // 指向arr尾元素的下一位置的指针
```

>Note:一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。

#### 指针运算

指向数组元素的指针可以执行所有的迭代器运算。例如：解引用、递增、比较、与整数相加、两个指针相减等。

给指针加（减）一个整数，得到的新指针仍需要指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置。

```C++
//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置
int *p = arr + sz; //使用警告:不要解引用！
int *p2 = arr + 10; // 错误：arr只有5各元素，p2的值未定义
// 如果计算所得的指针超出了上述范围就将产生错误，而且这种错误编译器一半发现不了。
```

如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果当然是0；

#### 解引用和指针运算的交互

```C++
int ia[] = {0,2,4,,6,8}; //含有5个整数的数组
int last = *(ia + 4); //正确：把last初始化成8，也就是ia[4]的值
```

#### 下标和指针

对数组执行下标运算其实是对指向数组元素的指针执行下标运算：

```C++
int i = ia[2]; //ia转换成指向数组首元素的指针
							//ia[2]得到(ia + 2)所指的元素
int *p = ia; // p指向ia的首元素
i = *(p + 2) // 等价于i = ia[2]
```

只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：

```c++
int *p = &ia[2]; // p指向索引为2的元素
int j = p[1]; // p[1]等价于 *(p=1),就是ia[3]表示的那个元素
int k = p[-2]; // p[-2]是ia[0]表示的那个元素
```

虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。

> 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。

### 3.5.4 C风格字符串

#### C标准库String函数

![C风格字符串函数](https://cdn.pkubailu.cn/img/3.8.png )

传入此类函数的指针必须指向以空字符作为结束的数组:

```C++
char ca[] = {'c','+','+'};  // 不以空字符结束
cout << strlen(ca) << endl; // 严重错误：ca没有以空字符结束
```

#### 比较字符串

比较C风格的字符串和比较标准库string对象的方法大相径庭。

string对象的比较可以用关系运算符，而C风格字符串用关系运算符比较的是指针所指对象的地址。

```C++
string s1 = "A string example";
string s2 = "A different example";
if (s1 < s2) // false: s2 小于 s1
const char ca1[] = "A string example";
const char ca2[] = "A different example";
if (ca1 < ca2) // 未定义的：试图比较两个无关地址
```

### 3.5.5 与旧代码的接口

#### 混用string对象和C风格字符串

允许使用字符串字面值来初始化string对象:

```c++
string s("hello world"); // s的内容是hello world
```

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代:

- 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值。
- 在string对象的假发运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

**上述性质反过来不成立！**

不能使用string对象直接初始化指向字符的指针。为了完成改功能，string住啊们提供了一个名为c_str的成员函数:

```c++
char *str = s; //错误: 不能用string对象初始化char*
const char *str = s.c_str(); // 正确
```

#### 使用数组初始化vector对象

不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。

```c++
int int_arr[] = {0,1,2,3,4};
vector<int> ivec(begin(int_arr), end(int_arr));
```

在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化的值在数组int_arr中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。

> 应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。

## 3.6 多维数组

C++语言中的多维数组其实是数组的数组。

```C++
size_t cnt = 0;
for (auto &row : ia) {
  for (auto &col : row) {
    col = cnt;
    cnt++;
  }
}
```

> Note! 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

#### 指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

> Note! 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。

```C++
// 在下述声明中，圆括号必不可少
int *ip[4]; // 整型指针的数组
int (*ip)[4]; // 指向含有4个整数的数组
```

```C++
//输出ia中每个元素的值，每个内层数组各占一行
// p指向含有4个整数的数组
for (auto p = ia; p != ia + 3; ++p) {
  for (auto q = *p; q != *p + 4; ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

使用标准库函数begin和end也能实现同样的功能。

```C++
for (auto p = begin(ia); p != end(ia); ++p) {
  for (auto q = begin(*p); q != end(*p); ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

# 第4章 表达式

## 4.1 基础

#### 重载运算符

当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为**重载运算符**

#### 左值和右值

当一个对象被用作右值得时候，用的是对象的值（内容）；当对象被用作左值得时候，用的是对象的身份（在内存中的位置）。

使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。例如：

假定p的类型是int *，因为解引用运算符生成左值，所以decltype(\*p)的结果是int&。另一方面，因为取地址运算符生成右值，所指decltype(&p)的结果是int**,也就是说，结果是一个指向整型指针的指针。

## 4.2 算术运算符

在除法运算中，如果两个运算对象的符号相同则商为正（如果不为0的话），否则商为负。C++新标准规定商一律向0取整（即直接切除小数部分）。

C++新标准规定：(-m)/n 和 m/(-n)都等于-(m/n), m%(-n)等于m%n, (-m)%n等于-(m%n)。

## 4.6 成员访问运算符

点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr->mem等价于(*p).mem

## 4.7 条件运算符

条件运算符的优先级非常低，因此当一条长表达式中潜逃了条件运算表达式时，通常需要在它的两端加上括号。

## 4.8 位运算符

左移运算符（<<）在右侧插入值为0的二进制位。右移运算符（>>）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。

## 4.9 sizeof运算符

sizeof运算符返回一条表达式或一个类型名字所占的字节数。

```C++
// 运算符的运算对象有两种形式
sizeof (type)
sizeof expr
// 在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值。
```

![](https://cdn.pkubailu.cn/img/sizeof运算符.png)

因为sizeof不会实际求运算对象的值，所以即使p是一个无效(即未初始化)的指针也不会有什么影响。sizeof不需要真的解引用指针也能知道它所指对象的类型。

sizeof运算符的结果部分地依赖于其作用的类型：

- 对char或者类型为char的表达式执行sizeof运算，结果得1.
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
- 对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。
- 对数组执行sizeof运算的带整个数组所占空间的大小，等价于对数组中所有的元素各执行一次siezof运算并将所得结果求和，注意，sizeof运算不会把数组转换成指针来处理。
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

```C++
// sizeof(ia)/sizeof(*ia)返回ia的元素数量
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz]; //正确：sizeof返回一个常量表达式
```

## 4.11 类型转换

在下面这些情况下，编译器会自动地转换运算对象的类型：

- 在大多数表达式中，比int类型晓得整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。

### 4.11.2 其他隐式类型转换

#### 数组转换成指针

在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针

```C++
int ia[10]; 
int *ip = ia; //ia 转换成指向数组首元素的指针
```

当数组被用作decltype关键字、取地址符(&)、sizeof及typeid等运算符的参数时，不会发生转换。

#### 指针的转换

常量整数值0或者字面值nullptr能转换成任意指针类型

指向任意非常量的指针能转换成void*

指向任意对象的指针能转换成const void*

#### 转换成布尔类型

存在一种从算术类型或指针类型向布尔类型自动转换的机制。

```C++
char *cp = get_string();
if (cp)   //如果指针cp不是0，条件为真
while(*cp) // 如果*cp不是空字符，条件为真
```

#### 转换成常量

允许将指向非常量类型的指针转换成指向相应常量类型的指针，对于引用也是这样。

```C++
int i;
const int &j = i; // 非常量转换成const int 的引用
const int *p = &i; //非常量的地址转换成const的地址
int &r = j, *q = p; //错误：不允许const转换成非常量
```

#### 类类型定义的转换

```C++
string s, t = "a value";  // 字符串字面值转换成string类型
while(cin >> s) // while 的条件部分把cin转换成布尔值
```

