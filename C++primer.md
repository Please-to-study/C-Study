# 第2章 变量和基本类型

## 2.1 基本内置类型

C++定义了一套包括**算术类型和空类型**在内的基本数据类型。

算术类型： 字符、整型数、布尔值、浮点数。

空类型不对应具体的值。

### 2.1.1 算术类型

算术类型分为两类：整型（包括字符和布尔类型在内）和浮点型。

![](https://cdn.pkubailu.cn/img/2.1.png)

### 2.1.2 类型转换

**切勿混用带符号类型和无符号类型**

> Note! 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号类型数。

### 2.1.3 字面值常量

一个形如42的值被称作**字面值常量**，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

#### 整型和浮点型字面值

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数。十进制字面值的类型是int、long和long long中尺寸最小的那个。

默认的，浮点型字面值是一个double。

#### 字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

字符串字面值的类型实际上是由常量字符构成的数组。

## 2.2 变量

#### 列表初始化

```C++
// 初始化方式
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：

```C++
long double ld = 3.1415926;
int a{ld}, b = {ld}; // 错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld; // 正确：转换执行，且却是丢失了部分值
```

#### 默认初始化

如果是内置类型的变量未被显示初始化，他的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0.定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

类的对象如果没有显示的初始化，则其值由类决定。

### 2.2.2 变量的声明和定义的关系

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示的初始化变量：

```C++
extern int i; // 声明i而非定义i
int j; // 声明并定义j
```

任何包含了显示初始化的声明即成为定义。

```C++
extern double pi = 3.1416; // 定义
```

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

## 2.3 复合类型

### 2.3.1 引用

1. 程序把引用和它的初始值绑定到一起，而不是将初始值拷贝给引用。一定初始化完成，引用将和它的初始值对象一直绑定到一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
2. 引用并非对象，相反的它只是为一个已经存在的对象所起的另外一个名字。
3. 引用的类型都要和与之绑定的对象严格匹配。（但有两种例外情况）
4. 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。

### 2.3.2 指针

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须在定义的时候赋初值。和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

3. 指针的类型都要和它所指向的对象严格匹配。（但有两种例外情况）

#### 空指针

空指针不指向任何对象。

```c++
# 生成空指针的方法
int *p = nullptr;
int *p = 0;
//需要首先#include cstdlib
int *p = NULL;
```

#### void* 指针

void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址追踪到底是个什么类型的对象并不了解。

利用void* 指针能做的事比较有限：拿他和别的指针比较、作为函数的输入输出、或者赋值给另外一个void\*指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

### 2.3.3 理解复合类型的声明

#### 指向指针的指针

通过*的个数可以区分指针的级别。也就是说，\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针，以此类推：

```C++
int ival = 1024;
int *pi = &ival; // pi指向一个int型的数
int **ppi = &pi; // ppi指向一个int型的指针
```

解引用int型指针会得到一个int型的数，同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用。

#### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```C++
int i = 42;
int *p = 0; // p是一个int型指针
int *&r = p; // r是对指针p的引用

r = &i; // 给r赋值&i就是让p指向i
*r = 0; // 解引用r得到i,也就是p指向的对象，将i的值改为0
```

### 2.4 const限定符

**如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字**

#### 2.4.1 const的引用

1. 把引用绑定到const对象上，我们称之为**对常量的引用**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci = 1024;
const int &r1 = ci;
r1 = 0;  // 错误：ri是对常量的引用，常量无法被修改。
int &r2 = ci; // 错误：试图让一个非常量引用指向一个常量对象。他们的类型不一致！
```

**引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是：在初始化常量引用的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式**

```c++
int i = 42;
const int &r1 = i; // 允许将const int&绑定到一个普通int对象上;
const int &r2 = 42; // 正确：r2是一个常量引用;
const int &r3 = r1 * 2; // 正确： r3是一个常量引用;
int &r4 = r1 * 2;  // 错误：r4是一个普通的非常量引用;
```

**对const的引用可能引用一个并非const的对象**

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 42;
int &r1 = i; // 引用r1绑定对象i
const int &r2 = i; // r2也绑定对象i,但是不允许通过r2来修改i的值;
r1 = 0; // r1并非常量,i的值修改为0;
r2 = 0; // 错误：r2是一个常量引用，不可以做修改操作;
```

### 2.4.2 指针和const

与引用一样，也可以令指针指向常量或非常量.类似于常量引用，**指向常量的指针**不能用于改变其所指对象的值。

指针的类型必须与其所指向对象的类型一致，但是有两个例外。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象。

```c++
const double pi = 3.14; //pi是一个常量，他的值不能改变; 
double *ptr = &pi; // 错误：ptr 是一个普通指针;
const double *cptr = &pi; // 正确：cptr可以指向一个双精度常量;
*cptr = 42; // 错误：cptr指向的是一个常量，不能给cptr赋值;
double dval = 3.14;
cptr = &dval; // 正确：但是不能通过cptr改变dval的值;
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量，所为指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

> 所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以不觉得不去改变所指对象的值。

### 2.4.3 顶层const 

**顶层const **:表示指针本身是个常量。

**底层const**:表示指针所指对象是一个常量。

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显，其中顶层const不受什么影响。顶层const只是标注了变量本身是const不允许改变，而底层const表示了变量所指的对象的类型，在拷贝时要求拷贝对象和被拷贝对象类型一致！

### 2.4.4 constexpr 和常量表达式

**常量表达式**是指值不会改变并且在编译过程中就能得到计算结果的表达式。

一个对象或表达式是不是常量表达式由他的数据类型和初始值共同决定。

#### 字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明constexptr时用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见、容易得到，就称之为“字面值类型” 算术类型、引用和指针都属于字面值类型。

一个constexpr指针的初始值必须是nullptr或者0，或者是存储在某个固定地址中的对象。

函数体外的对象其地址固定不变，能用来初始化constexpr指针。

函数体内定义的变量一般来说并非存放在固定地址中，不能初始化constexpr指针，但是函数体内也可以定义一类有效范围超出函数本身的变量，这类变量也有固定地址。

```c++
const int *p = nullptr; //p是一个指向整型常量的指针;
constexpr int *q = nullptr; // q是一个指向整型的常量指针
```

## 2.5 处理类型

### 2.5.1 类型别名

有两种方法可用于定义类型别名：

```c++
1.传统方法typedef:
typedef double wages; // wages是double的同义词
2.别名声明:
using SI = Sales_item; // SI是Sales_item的同义词
```

#### 指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。

```C++
typedef char *pstring; // pstring 是类型 char* 的别名
const pstring cstr = 0; // cstr 是指向char的常量指针
const pstring *ps; // ps 是一个指针，它的对象是指向char的常量指针
```

遇到一条使用了类型别名的声明语句时，人们往往会错误的尝试把类型别名替换成它本来的样子，以理解该语句的含义：

```C++
const char *cstr = 0; // 是对 const pstring cstr 的错误理解
```

**这种理解是错误的！**声明语句中用到pstring时，其基本数据类型是指针。可是用char\*重写了声明语句后，数据类型就变成了char，*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

### 2.5.2 auto类型说明符

auto类型说明符能让编译器通过初始值来推算变量的类型，显然auto定义的变量必须有初始值。

auto一般会忽略掉顶层const，同时底层const则会保留下来。变量b、c是案例。

设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留！变量g是案例。

例子：

```c++
	 int i = 0, &r = i;
   auto a = r;   // auto = int a是整数
   const int ci = i, &cr = ci; 
   auto b = ci; // auto = int b是整数
   auto c = cr; // auto = int c是整数
   auto d = &i; // auto = int d是i的地址值
   auto e = &ci; // auto = int e是i的地址值
   auto &g = ci; // auto = const int  g是整型常量引用 绑定到ci上
```

### 2.5.3 decltype 类型指示符

**decltype**：它的作用是选择并返回操作数的数据类型。

decltype处理顶层const和引用的方式与auto有些不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&, y绑定到变量x 
decltype(cj) z; // 错误：z是一个引用，必须初始化
```

**需要指出的是，引用从来都是作为其所指对象的同义词出现，只有用在decltype处是一个例外**

#### decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

r是个引用，所以decltype(r)的结果是引用类型，如果想让结果类型是r所指对象的类型，可以把r作为表达式的一部分，例如r+0.

如果表达式的内容是解引用操作，则decltype将得到引用类型.

```c++
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // 正确：加法的结果是int,因此b是一个（未初始化的）int
decltype(*p) c; // 错误：c是int&,必须初始化
```

如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式，decltype就会得到引用类型：

```c++
decltype((i)) d; //错误： d是int&,必须初始化
decltype(i) e; // 正确：e是一个（未初始化的）int
```

> !切记：decltype((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。

## 2.6 自定义数据结构

### 2.6.3 编写自己的头文件

#### 预处理器概述

预处理变量有两种状态：已定义和未定义。

**#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**ifndef**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到**#endif**指令为止。

> 预处理变量无视C++语言中关于作用域的规则。

> 头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符

# 第3章 字符串、向量和数组

## 3.1 命名空间的using声明

有了using声明就无需专门的前缀（形如命名空间::）也能使用所需的名字了。

using声明具有如下的形式:

```c++
using namespace::name;
// 一旦声明了上述语句，就可以直接访问命名空间中的名字
```

> **!头文件不应包含using声明**

## 3.2 标准库类型 string

### 3.2.1 定义和初始化string对象

![image-20211115175652876](https://cdn.pkubailu.cn/img/3.1.png)

#### 直接初始化和拷贝初始化

如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化。

### 3.2.2 string对象上的操作

![image-20211115180215371](https://cdn.pkubailu.cn/img/3.2.png)

#### 读写string对象

```c++
int main() 
{
  string s;
  cin >> s;
  cout << s << endl;
  return 0;
}
// 在执行读取操作时，string对象会自动忽略开头的空白（即空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。
// 如果输入是"    hello world!    "则输出将是"hello"
```

#### 使用getline读取一整行

如果希望在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的>>运算符。

getline从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始输入的是换行符，那么所得的结果是个空string。

#### 比较 string 对象

字典序规则！

### 3.2.3 处理string对象中的字符

![image-20211115191804174](https://cdn.pkubailu.cn/img/3.3.png)

### 3.2.3 处理string对象中的字符

#### 处理每个字符？使用基于范围的for语句

语法形式：

```c++
for (declaration : expression)
  statement
```

## 3.3 标准库类型 vector

编译器根据模板创建类或函数的过程成为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

> vector 是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>

### 3.3.1 定义和初始化vector对象

![image-20211119003835476](https://cdn.pkubailu.cn/img/3.4.png)

#### 列表初始化vector对象

在大多数情况下这些初始化方式可以相互等价的使用，不过也并非一直如此。两种例外情况如下：

1. 使用拷贝初始化时（即使用=时）只能提供一个初始值；
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。

第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化。

#### 值初始化

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个**值初始化的**元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。

```C++
vector<int> ivec(10); //10个元素 每个都初始化为0
vector<string> svec(10) // 10个元素，每个都是空的string对象
```

对这种初始化的方式有两个特殊限制：

1. 有些类要求必须明确的提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始化的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：

```C++
vector<int> vi = 10; // 错误：必须使用直接初始化的形式指定向量大小
```

#### 列表初始值还是元素数量

![image-20211121004224917](https://cdn.pkubailu.cn/img/列表初始值还是元素数量1.png)

![image-20211121004346187](https://cdn.pkubailu.cn/img/列表初始值还是元素数量2.png)

### 3.3.2 向vector对象中添加元素

可以先创建一个空的vector对象，然后在运行时再利用vector的成员函数**push_back**向其中添加元素。

>! 范围for语句体内不应该改变其所遍历序列的大小。

### 3.3.3 其他vector操作

![image-20211121005240108](https://cdn.pkubailu.cn/img/3.5.png)

> Note: 要使用size_type，需要先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型
>
> ```C++
> vector<int>::size_type  // 正确
> vector::size_type  // 错误
> ```

两个vector对象相等当且仅当他们所含的元素个数相同，而且对应位置的元素值也相同。

关系运算符依照字典顺序进行比较:如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。

只有当元素的值可比较时，vector对象才能被比较。

## 3.4 迭代器介绍

有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

### 3.4.1 使用迭代器

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。这些类型都拥有名为**begin**和**end**的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器，end成员则负责返回指向容器”尾元素的下一位置“的迭代器，简称为尾迭代器。

#### 迭代器运算符

![3.6](https://cdn.pkubailu.cn/img/3.6.png)

#### 将迭代器从一个元素移动到另外一个元素

迭代器使用递增（++）运算符来从一个元素移动到下一个元素。

> Note:因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。

#### 迭代器类型

迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型

![迭代器类型](https://cdn.pkubailu.cn/img/迭代器类型.png)

Const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。

#### begin和end运算符

```C++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 的类型是vector<int>::iterator
auto it2 = cv.begin(); // it2 的类型是vector<int>::const_iterator
```

为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend：

```C++
auto it3 = v.cbegin(); // it3 的类型是vector<int>::const_iterator
```

不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

#### 结合解引用和成员访问操作

```C++
(*it).empty() // 解引用it，然后调用结果对象的empty()成员
*it.empty()  //错误： 试图访问it的名为empty的成员，但it是个迭代器，没有empty成员
```

为了简化上述表达式，C++语言定义了**箭头运算符**(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it->mem和(*it).mem表达的意思相同。

#### 某些对vector对象的操作会使迭代器失效

>**谨记！，但凡是使用了迭代器的循环体，都不要向迭代其所属的容器添加元素。**

### 3.4.2 迭代器运算

![3.7](https://cdn.pkubailu.cn/img/3.7.png)

#### 迭代器的算术运算

对于string或vector的迭代器来说，除了判断是否相等，还能使用关系运算符(<、<=、>、>=)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。例如，假设it和mid是同一个vector对象的两个迭代器，可以用下面的代码来比较他们所指的位置谁前谁后：

```C++
if (it < mid)
	// 处理vector前半部分的元素
```

## 3.5 数组

### 3.5.1 定义和初始化内置数组

默认情况下，数组的元素被默认初始化

> Warning! 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

#### 显示初始化数组

![显示初始化数组](https://cdn.pkubailu.cn/img/显示初始化数组.png)

#### 字符数组的特殊性

![字符数组的特殊性](https://cdn.pkubailu.cn/img/字符数组的特殊性.png )

#### 不允许拷贝和赋值

![不允许拷贝和赋值](https://cdn.pkubailu.cn/img/不允许拷贝和赋值.png )

#### 理解复杂的数组声明

定义数组的指针和数组的引用:

![数组的指针和数组的引用](https://cdn.pkubailu.cn/img/数组的指针和数组的引用.png )

对于数组而言，由内向外阅读要比从右向左好多了。例如：首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。

### 3.5.2 访问数组元素

最好的办法是使用范围for语言。

使用数组下标的时候，通常将其定义为**size_t**类型。

数组除了大小固定这一特点外，其他用法与vector基本类似。

### 3.5.3 指针和数组

> Note: 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

这一结论有很多隐含的意思：

1. 当使用数组作为一个auto变量的初始值时。推断得到的类型是指针而非是数组：

```C++
int ia[] = {0,1,2,3,4}; // ia 是一个含有5个整数的数组
auto ia2(ia); // ia2是一个整型指针,指向ia的第一个元素
ia2 = 42; // 错误：ia2是一个指针，不能用int值给指针赋值
```

必须指出的是，当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组：

```C++
// ia3 是一个含有5个整数的数组
decltype(ia) ia3 = {0,1,2,3,4};
ia3 = p; // 错误：不能用整形指针给数组赋值
ia3[4] = i; //正确：把i的值赋给ia3的一个元素
```

#### 指针也是迭代器

允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

```C++
int arr[] = {0,1,2,3,4};
int *p = arr; // p指向arr的第一个元素
++p; // p指向arr[1]
```

利用指针的循环

```C++
int *e = &arr[10];
for (int *b = arr; b != e; ++b)
  cout << *b <<endl;
```

#### 标准库函数begin和end

C++新标准引入了两个名为begin和end的函数

```C++
int ia[] = {0,1,2,3,4}; // ia是一个含有5个整数的数组
int *beg = begin(ia); //指向ia首元素的指针
int *last = end(ia); // 指向arr尾元素的下一位置的指针
```

>Note:一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。

#### 指针运算

指向数组元素的指针可以执行所有的迭代器运算。例如：解引用、递增、比较、与整数相加、两个指针相减等。

给指针加（减）一个整数，得到的新指针仍需要指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置。

```C++
//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置
int *p = arr + sz; //使用警告:不要解引用！
int *p2 = arr + 10; // 错误：arr只有5各元素，p2的值未定义
// 如果计算所得的指针超出了上述范围就将产生错误，而且这种错误编译器一般发现不了。
```

如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果当然是0；

#### 解引用和指针运算的交互

```C++
int ia[] = {0,2,4,,6,8}; //含有5个整数的数组
int last = *(ia + 4); //正确：把last初始化成8，也就是ia[4]的值
```

#### 下标和指针

对数组执行下标运算其实是对指向数组元素的指针执行下标运算：

```C++
int i = ia[2]; //ia转换成指向数组首元素的指针
							//ia[2]得到(ia + 2)所指的元素
int *p = ia; // p指向ia的首元素
i = *(p + 2) // 等价于i = ia[2]
```

只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：

```c++
int *p = &ia[2]; // p指向索引为2的元素
int j = p[1]; // p[1]等价于 *(p=1),就是ia[3]表示的那个元素
int k = p[-2]; // p[-2]是ia[0]表示的那个元素
```

虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。

> 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。

### 3.5.4 C风格字符串

#### C标准库String函数

![C风格字符串函数](https://cdn.pkubailu.cn/img/3.8.png )

传入此类函数的指针必须指向以空字符作为结束的数组:

```C++
char ca[] = {'c','+','+'};  // 不以空字符结束
cout << strlen(ca) << endl; // 严重错误：ca没有以空字符结束
```

#### 比较字符串

比较C风格的字符串和比较标准库string对象的方法大相径庭。

string对象的比较可以用关系运算符，而C风格字符串用关系运算符比较的是指针所指对象的地址。

```C++
string s1 = "A string example";
string s2 = "A different example";
if (s1 < s2) // false: s2 小于 s1
const char ca1[] = "A string example";
const char ca2[] = "A different example";
if (ca1 < ca2) // 未定义的：试图比较两个无关地址
```

### 3.5.5 与旧代码的接口

#### 混用string对象和C风格字符串

允许使用字符串字面值来初始化string对象:

```c++
string s("hello world"); // s的内容是hello world
```

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代:

- 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值。
- 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

**上述性质反过来不成立！**

不能使用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数:

```c++
char *str = s; //错误: 不能用string对象初始化char*
const char *str = s.c_str(); // 正确
```

#### 使用数组初始化vector对象

不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。

```c++
int int_arr[] = {0,1,2,3,4};
vector<int> ivec(begin(int_arr), end(int_arr));
```

在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化的值在数组int_arr中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。

> 应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。

## 3.6 多维数组

C++语言中的多维数组其实是数组的数组。

```C++
size_t cnt = 0;
for (auto &row : ia) {
  for (auto &col : row) {
    col = cnt;
    cnt++;
  }
}
```

> Note! 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

#### 指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

> Note! 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。

```C++
// 在下述声明中，圆括号必不可少
int *ip[4]; // 整型指针的数组
int (*ip)[4]; // 指向含有4个整数的数组
```

```C++
//输出ia中每个元素的值，每个内层数组各占一行
// p指向含有4个整数的数组
for (auto p = ia; p != ia + 3; ++p) {
  for (auto q = *p; q != *p + 4; ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

使用标准库函数begin和end也能实现同样的功能。

```C++
for (auto p = begin(ia); p != end(ia); ++p) {
  for (auto q = begin(*p); q != end(*p); ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

# 第4章 表达式

## 4.1 基础

#### 重载运算符

当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为**重载运算符**

#### 左值和右值

当一个对象被用作右值得时候，用的是对象的值（内容）；当对象被用作左值得时候，用的是对象的身份（在内存中的位置）。

使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。例如：

假定p的类型是int *，因为解引用运算符生成左值，所以decltype(\*p)的结果是int&。另一方面，因为取地址运算符生成右值，所以decltype(&p)的结果是int**,也就是说，结果是一个指向整型指针的指针。

## 4.2 算术运算符

在除法运算中，如果两个运算对象的符号相同则商为正（如果不为0的话），否则商为负。C++新标准规定商一律向0取整（即直接切除小数部分）。

C++新标准规定：(-m)/n 和 m/(-n)都等于-(m/n), m%(-n)等于m%n, (-m)%n等于-(m%n)。

## 4.6 成员访问运算符

点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr->mem等价于(*p).mem

## 4.7 条件运算符

条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算表达式时，通常需要在它的两端加上括号。

## 4.8 位运算符

左移运算符（<<）在右侧插入值为0的二进制位。右移运算符（>>）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。

## 4.9 sizeof运算符

sizeof运算符返回一条表达式或一个类型名字所占的字节数。

```C++
// 运算符的运算对象有两种形式
sizeof (type)
sizeof expr
// 在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值。
```

![](https://cdn.pkubailu.cn/img/sizeof运算符.png)

因为sizeof不会实际求运算对象的值，所以即使p是一个无效(即未初始化)的指针也不会有什么影响。sizeof不需要真的解引用指针也能知道它所指对象的类型。

sizeof运算符的结果部分地依赖于其作用的类型：

- 对char或者类型为char的表达式执行sizeof运算，结果得1.
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
- 对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。
- 对数组执行sizeof运算的带整个数组所占空间的大小，等价于对数组中所有的元素各执行一次siezof运算并将所得结果求和，注意，sizeof运算不会把数组转换成指针来处理。
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

```C++
// sizeof(ia)/sizeof(*ia)返回ia的元素数量
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz]; //正确：sizeof返回一个常量表达式
```

## 4.11 类型转换

在下面这些情况下，编译器会自动地转换运算对象的类型：

- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。

### 4.11.1 算数转换

1. 首先执行整型提升。如果结果的类型匹配，无需进行进一步的转换。如果两个运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。
2. 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。假设两个类型分别是unsigned int 和 int，则int类型的运算对象转换成unsigned int 类型。需要注意的是，如果int型的值恰好为负值，则采用取模的方式转换。
3. 剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

### 4.11.2 其他隐式类型转换

#### 数组转换成指针

在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针

```C++
int ia[10]; 
int *ip = ia; //ia 转换成指向数组首元素的指针
```

当数组被用作decltype关键字、取地址符(&)、sizeof及typeid等运算符的参数时，不会发生转换。

#### 指针的转换

常量整数值0或者字面值nullptr能转换成任意指针类型

指向任意非常量的指针能转换成void*

指向任意对象的指针能转换成const void*

#### 转换成布尔类型

存在一种从算术类型或指针类型向布尔类型自动转换的机制。

```C++
char *cp = get_string();
if (cp)   //如果指针cp不是0，条件为真
while(*cp) // 如果*cp不是空字符，条件为真
```

#### 转换成常量

允许将指向非常量类型的指针转换成指向相应常量类型的指针，对于引用也是这样。

```C++
int i;
const int &j = i; // 非常量转换成const int 的引用
const int *p = &i; //非常量的地址转换成const的地址
int &r = j, *q = p; //错误：不允许const转换成非常量
```

#### 类类型定义的转换

```C++
string s, t = "a value";  // 字符串字面值转换成string类型
while(cin >> s) // while 的条件部分把cin转换成布尔值
```

### 4.11.3 显示转换

#### 命名的强制类型转换

```C++
// 一个命名的强制类型转换具有如下形式：
cast-name<type>(expression);
// type 是转换的目标类型
// expression 是要转换的值
// cast-name 是 static_cast、dynamic_cast、const_cast、reinterpret_cast中的一种
```

####  static_cast

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

```C++
// 进行强制类型转换以便执行浮点数除法
double slope = static_cast<double>(j) / i;
```

当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。

static_cast对于编译器无法自动执行的类型转换也非常有用。

```C++
// 使用static_cast找回存在于void*指针中的值
void* p = &d; // 正确：任何非常量对象的地址都能存入void*
double *dp = static_cast<double*>(p); //正确：将void*转换回初始的指针类型
// 我们必须确保转换后所得的类型就是指针所指的类型
```

#### const_cast

const_cast只能改变运算对象的底层const

```C++
const char *pc;
char *p = const_cast<char*>(pc); // 正确：但是通过p写值是未定义的行为
```

只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。

#### reinterpret_cast

reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。例如：

```C++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。

# 第5章 语句

### 5.3.2 switch语句

case关键字和它对应的值一起被成为**case标签**。case标签必须是整型常量表达式：

```C++
char ch = getVal();
int ival = 42;
switch(ch) {
  case 3.14: // 错误：case标签不是一个整数
  case ival: // 错误：case标签不是常量
}
```

## 5.6 try语句块和异常处理

在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。

寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch字句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。

如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数，一般情况下，执行该函数将导致程序非正常退出。

如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。

# 第6章 函数

## 6.1 函数基础

函数有几个形参，我们就必须提供相同数量的实参。

#### 函数的形参列表

```C++
void f1(){} // 隐式地定义空形参列表
void f2(void) {} // 显式的定义空形参列表
```

#### 函数返回类型

函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

### 6.1.1 局部对象

#### 自动对象

我们把只存在于块执行期间的对象称为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

#### 局部静态对象

可以将局部变量定义成static类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对他有影响。

如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。

### 6.1.2 函数声明

函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称为**函数原型**

> Note! 含有函数声明的头文件应该被包含到定义函数的原文件中。

## 6.2 参数传递

### 6.2.3 const形参和实参

和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。

调用fcn函数时，既可以传入const int也可以传入int。忽略掉形参的顶层const可能产生意想不到的结果:

```C++
void fcn(const int i) { // fcn 能够读取i，但是不能向i写值 }
void fcn(int i) {} // 错误：重复定义了fcn(int)
```

当重载函数fcn时发生错误，因为顶层const被忽略掉了，所以在上面的代码中传入两个fcn函数的参数可以完全一样，所以第二个fcn是错误的。

#### 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地现值函数所能接受的实参类型。我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

### 6.2.4 数组形参

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：

1. 不允许拷贝数组
2. 使用数组时（通常）会将其转换成指针

尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：

```C++
// 尽管形式不同，但这三个print函数式等价的
// 每个函数都有一个const int*类型的形参
void print(const int*);
void print(const int[]); // 可以看出来，函数的意图是作用于一个数组
void print(const int[10]); // 这里的维度表示我们期望数组含有多少元素，实际不一定
```

> Warning! 和其他使用数组的代码一样，以数组为形参的函数也必须确保使用数组时不会越界。

#### 使用标记指定数组长度

管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。

```C++
void print(const char *cp) {
  if(cp){  // 若cp不是一个空指针
    while(*cp){ // 只要指针所指的字符不是空字符
      cout << *cp++;
    }
  }
}
```

#### 使用标准库规范

管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库的启发。

```C++
void print (const int *beg, const int *end) {
  while(beg != end) {
    cout << *beg++;
  }
}
```

#### 显示传递一个表示数组大小的形参

第三种管理数组实参的方法是专门定义一个表示数组大小的形参。

```C++
// const int ia[] 等价于const int *ia
// size 表示数组的大小
void print(const int ia[],size_t size) {
  for (size_t i = 0; i < size; ++i) {
    cout << ia[i];
  }
}
```

#### 数组形参和const

三个print函数都把数组形参定义成了指向const的指针。当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。

#### 数组引用形参

形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上。

```C++
// 正确： 形参是数组的引用，维度是类型的一部分
void print(int (&arr)[10]) {
  for (auto elem : arr) 
    cout << elem;
}
```

> **&arr 两端的括号必不可少**
>
> **f(int &arr[10])  // 错误： 将arr声明成了引用的数组**
>
> **f(int (&arr)[10])  //正确： arr是具有10个整数的整型数组的引用**

但是，这一用法也无形中限制了print函数的可用性，我们只能将函数作用于大小为10的数组。

#### 传递多维数组

```C++
void print(int (*matrix)[10], int rowSize) {}
// 上述语句将 matrix 声明成指向含有10个整数的数组的指针
```

> Note!
>
> **\*matrix 两端的括号必不可少：**
>
> **int *matrix[10]; // 10个指针构成的数组**
>
> **int (*matrix)[10]; // 指向含有10个整数的数组的指针**

```C++
void print(int matrix[][10], int rowSize) {}
```

matrix 的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。

### 6.2.5 main: 处理命令行选项

```C++
int main(int argc, char *argv[]) {}
```

第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。

当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

```C++
// 当命令行输入
prog -d -o ofile data0
// argv 应该包含如下的C风格字符串：
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

**当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入。**

#### 6.2.6 含有可变形参的函数

#### initializer_list 形参

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。

![](https://cdn.pkubailu.cn/img/6.1.png)

和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型：

```C++
initializer_list<string> ls; // initializer_list 的元素类型是string
initializer_list<int> li; // initializer_list的元素类型是int
```

和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法修改其中的值。

```C++
void error_msg(initializer_list<string> ls) {
  for (auto beg = ls.begin(); beg != ls.end(); ++beg)
    cout << *beg << endl;
}
// 想向initializer_list形参中传递一个值序列，则必须把序列放在一对花括号内
// expected和actual是string对象
if (expected != actual)
  error_msg({"functionX", expected, actual});
else
  error_msg({"functionX", "okay"})
```

#### 省略符形参

**省略符形参应该仅仅用于C和C++通用的类型。特别注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝**

省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：

```C++
void foo(parm_list,...);
void foo(...);
```

第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参无需类型检查。

### 6.3.2 有返回值函数

#### 不要返回局部对象的引用或指针

函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域：

```C++
const string &manip() {
  string ret;
  if (!ret.empty())
    return ret;  // 错误：返回局部对象的引用！
  else 
    return "Empty"; // 错误： "Empty"是一个局部临时变量
}
```

第一条return 语句来说，显然它返回的是局部对象的引用。

第二条return 语句中，字符串字面值转换成一个局部临时string对象，该对象和ret一样都是局部的。

### 6.3.3 返回数组指针

#### 声明一个返回数组指针的函数

```C++
int arr[10]; //arr 是一个含有10个整数的数组
int *p1[10]; // p1是一个含有10个指针的数组
int (*p1)[10]; // p2 是一个指针，它指向含有10个整数的数组
```

和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：

```c++
Type (*function(parameter_list))[dimension]
// (*function(parameter_list))两端的括号必须存在。
```

具体的例子：

```C++
int (*func(int i))[10];
```

可以按照以下的顺序来逐层理解该声明的含义：

- func(int i) 表示调用func函数时需要一个int类型的实参。
- (*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作
- (*func(int i))[10] 表示解引用func的调用将得到一个大小为10的数组
- int (*func(int i))[10] 表示数组中的元素是int类型

#### 使用尾置返回类型

简化上述func声明的方法，还可以使用**尾置返回类型**。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto:

```C++
// func 接受一个int 类型的实参，返回一个指针，该指针指向含有10个整数的数组
auto func(int i) -> int(*)[10];
```

因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。 

#### 使用 decltype

如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。

```C++
int odd[] = {1,3,5,7,9};
int event[] = {0,2,4,6,8};
// 返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i){
  return (i % 2) ? &odd : &even; //返回一个指向数组的指针
}
```

因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回值真还必须在函数声明时加一个*符号。

## 6.4 函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为**重载函数**。

#### 定义重载函数

对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。

#### 判断两个形参的类型是否相异

有时候两个形参列表看起来不一样，但实际上是相同的：

```C++
// 声明的是同一个函数
Record lookup(const Account &acct);
Record lookup(const Account &);  // 省略了形参的名字
```

#### 重载和const形参

顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：

```C++
Record lookup(Phone);
Record lookup(const Phone); 

Record lookup(Phone*);
Record lookup(Phone* const);
```

另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：

```C++
// 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同
// 定义了4个独立的重载函数
Record lookup(Account &); // 函数作用于Account的引用
Record lookup(Account &); // 新函数，作用于常量引用

Record lookup(Account *); // 新函数，作用于指向Account的指针
Record lookup(const Account *); // 新函数，作用于指向常量的指针
```

#### const_cast 和 重载

const_cast 在重载函数的情景中最有用。举个例子：

```C++
// 比较两个string对象的长度，返回较短的那个引用
const string &shorterString(const string &s1, const string &s2){
  return s1.size() <= s2.size() ? s1 : s2;
}
```

这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string 的引用。因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点：

```C++
string &shorterString(string &s1, string &s2){
  auto &r = shorterString(const_cast<const string&>(s1),const_cast<const string&>(s2));
  return const_cast<string&>r;
}
```

在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string&，这显然是安全的。

#### 调用重载的函数

调用重载函数时有三种可能的结果：

- 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
- 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。
- 有多余一个函数可以匹配，但是没一个都不是最明显的最佳选择。此时也将发生错误，成为二义性调用。

### 6.4.1 重载与作用域

重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。

> Note! 在C++语言中，名字查找发生在类型检查之前。

## 6.5 特殊用途语言特性

### 6.5.1 默认实参

我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值。

```C++
typedef string::size_type sz; 
string screen(sz ht = 24, sz wid = 80, char background = ' ');
```

函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参，例如：要想覆盖background的默认值，必须为ht何wid提供实参：

```C++
window = screen(,,'?'); // 错误：只能省略尾部的实参
window = screen('?'); // 调用screen('?',80,' ')
```

当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。

#### 默认实参声明

一个函数通常只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值得形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

```C++
string screen(sz,sz,char = '');
string screen(sz,sz,char = '*'); // 错误：重复声明
// 但是可以按照如下形式添加默认实参：
string screen(sz = 24, sz = 80, char); //正确：添加默认实参
```

#### 默认实参初始值

局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：

```C++
// wd、def、ht的声明必须出现在函数之外
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);
string window = screen(); //调用 screen(ht(),80,' ')
```

用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：

```C++
void f2(){
  def = '*'; // 改变默认实参的值
  sz wd = 100; // 隐藏了外层定义的wd，但是没有改变默认值
  window = screen(); // 调用了screen(ht(),80,'*');
}
```

### 6.5.2 内联函数和 constexpr 函数

#### 内联函数可避免函数调用的开销

将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。

假设我们把shorterString函数定义成内联函数，则如下调用

```C++
cout << shorterString(s1,s2) << endl;
```

将在编译过程中展开成类似下面的形式

```C++
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
```

从而消除了shorterString函数的运行时开销。

在shorterString函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了:

```C++
inline const string &
shorterString(const string &s1, const string &s2){
  return s1.size() < s2.size() ? s1 : s2; 
}
```

一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。

#### constexpr 函数

constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：

```C++
constexpr int new_sz() {return 42;}
constexpr int foo = new_sz(); // 正确： foo是一个常量表达式
```

执行该初始化任务时，编译器把对constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐士地指定为内联函数。

我们允许constexpr函数的返回值并非一个常量：

```C++
// 如果arg是常量表达式，则scale(arg)也是常量表达式
constexpr size_t scale(size_t cnt) {return new_sze() * cnt; }
// 当scale的实参实参是常量表达式时，它的返回值也是常量表达式：反之则不然：
int arr[scale(2)]; // 正确： scale(2)是常量表达式
int i = 2; // i 不是常量表达式
int a2[scale(i)] // 错误：scale(i)不是常量表达式
```

> Note! constexpr 函数不一定返回常量表达式

#### 把内联函数和constexpr 函数放在头文件内

对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。

### 6.5.3 调试帮助

#### assert 预处理宏

assert是一种预处理宏。所谓预处理宏其实是一个预处理变量，他的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：

```C++
assert(expr);
```

首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。

和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件的程序不能再定义名为assert的变量、函数或者其他实体。在实际编译过程中，即使我们没有包含cassert头文件，也最好不要为了其他目的使用assert。很多头文件都包含了cassert，这就意味着即使你没有直接包含cassert，它也很有可能通过其他途径包含在你的程序中。

```C++
// assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时，程序可以包含一条如下所示的语句：
assert(word.size() > threshold)；
```

#### NDEBUG预处理变量

assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。

我们可以使用一个#define 语句定义NDEBUG，从而关闭调试状态。

除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码：如果定义了NDEBUG，这些代码将被忽略。

## 6.6 函数匹配

#### 确定候选函数和可行函数

1. 选定本次调用对应的重载函数集。
2. 考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数。
3. 从候选函数中选择与本次调用最匹配的函数。

#### 寻找最佳匹配（如果有的话）

基本思想是：实参类型与形参类型越接近，他们匹配的越好。

> Note! 调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

### 6.6.1 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级。

1. 精确匹配，包括以下情况：
   - 实参类型和形参类型相同。
   - 实参从数组类型或函数类型转换成对应的指针类型。
   - 向实参添加顶层const或者从实参中删除顶层const。
2. 通过const转换实现的匹配。
3. 通过类型提升实现的匹配。
4. 通过算术类型转换或指针转换实现的匹配。
5. 通过类类型转换实现的匹配。

#### 函数匹配和const实参

```C++
Record lookup(Account&);
Record lookup(const Account&);
const Account a;
Account b;

lookup(a); // 调用lookup(const Account&)
lookup(b); // 调用lookup(Account&)
```

在第一个调用中，我们传入的是const 对象a。因为不能把普通引用绑定到const对象上，所以此例中唯一可行的函数是以常量引用作为形参的那个函数。

在第二个调用中，两个函数都是可行的，因为我们既可以使用b初始化常量引用也可以用它初始化非常量引用。然而，用非常量对象初始化常量引用需要类型转换。

指针也同样如此！

## 6.7 函数指针

函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参共同决定，与函数名无关。

```C++
// 比较两个string对象的长度
bool lengthCompare(const string &,const string &);
```

该函数的类型是bool（const string&, const string&）。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：

```C++
// pf 指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型
bool (*pf) (const string &,const string &); // 未初始化
```

从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。

> Note! *pf 两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数。

#### 使用函数指针

当我们把函数名作为一个值使用时，该函数自动的转换成指针。例如，按照如下形式我们可以将lengthCompare的地址赋给pf：

```C++
pf = lengthCompare; // pf 指向名为lengthCompare的函数
pf = &lengthCompare; // 等价的赋值语句：取地址符是可选的
```

此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针：

```C++
bool b1 = pf("hello","goodbye"); // 调用lengthCompare函数
bool b2 = (*pf)("hello","goodbye"); // 一个等价的调用
bool b3 = lengthCompare("hello","goodbye"); // 另一个等价的调用
```

在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个函数。

```C++
string::size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0; // 正确：pf不指向任何函数
pf = sumlength; // 错误：返回类型不匹配
pf = cstringCompare; // 错误：形参类型不匹配
pf = lengthCompare; // 正确：函数和指针的类型精确匹配
```

#### 重载函数的指针

当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。如果定义了指向重载函数的指针

```C++
void ff(int*);
void ff(unsigned int);

void (*pf1)(unsigned int) = ff; // pf1 指向 ff(unsigned)
```

编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配

```C++
void (*pf2)(int) = ff; // 错误：没有任何一个ff与该形参列表匹配
double (*pf3)(int*) = ff; // 错误： 返回类型不匹配
```

#### 函数指针形参

和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用：

```C++
// 第三个形参是函数类型，它会自动地转换成指向函数的指针
void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));
// 等价的声明：显示的将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &)); 
// 我们可以直接把函数作为实参使用，此时它会自动转换成指针：
useBigger(s1,s2,lengthCompare);
```

正如useBigger的声明语句所示，直接使用函数指针类型显得冗余而繁琐。类型别名和decltype能让我们简化使用了函数指针的代码：

```C++
没有看懂！！！ P222页
```

#### 返回指向函数的指针

和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而， 我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要向声明一个返回函数指针的函数，最简单的办法是使用类型别名：

```C++
using F = int(int*, int); // F是函数类型，不是指针
using PF = int(*)(int*, int); // PF是指针类型
```

必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显示的将返回类型指定为指针：

```C++
PF f1(int); // 正确： PF 是指向函数的指针，f1返回指向函数的指针
F f1(int); // 错误：F是函数类型，f1不能返回一个函数
F *f1(int); // 正确：显示的指定返回类型是指向函数的指针
```

当然，我们也能用下面的形式直接声明f1:

```C++
int (*f1(int))(int*, int);
// 按照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表，所以f1是一个函数：f1前面有*，所以f1返回一个指针，进一步观察发现，指针的类型本身也含有形参列表，因此指针指向函数，该函数的返回类型是int
```

我们还可以使用尾置返回类型的方式

```C++
auto f1(int) -> int (*)(int*, int);
```

#### 将auto和decltype用于函数指针类型

如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。

```C++
string::size_type sumLength(const string&, const string&);
string::size_type largeLength(const string&, const string&);
// 根据其形参的取值，getFcn函数返回指向 sumLength 或者 largeLength的指针
decltype(sumLength) *getFcn(const string &);
```

声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们需要显示的加上*以表明我们需要返回指针。

# 第7章 类

## 7.1 定义抽象数据类型

### 7.1.2 定义改进的 Sales_data 类

定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，例如add、read和print等，它们的定义和声明都在类的外部。

```C++
// 改进的Sales_data类如下所示
struct Sales_data {
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
// Sales_data的非成员接口函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```

> 定义在类内部的函数是隐式的inline函数

#### 定义成员函数

尽管所有成员都必须在类的内部声明，但是成员函数可以定义在类内也可以定义在类外。对于Sales_data类来说，isbn函数定义在了类内，而combine和avg_price定义在了类外。

```C++
std::string isbn() const { return bookNo; }
```

isbn函数是如何获得bookNo成员所依赖的对象的呢？

#### 引入this

```C++
// 调用isbn函数
total.isbn()
```

当我们调用成员函数时，实际上是在替某个对象调用它。如果isbn指向Sales_data的成员(例如bookNo)，则它隐式地指向调用该函数的对象的成员。

成员函数通过一个名为**this**的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。

```C++
total.isbn()
// 编译器负责把total的地址传递给isbn的隐士形参this，可以认为编译器将该调用重写成了如下的形式
Sales_data::isbn(&total)
```

任何对类成员的直接访问都被看作this的隐式调用，也就是说，当isbn使用bookNo时，它隐式的使用this指向的成员，就像我们书写了this->bookNo一样。

对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或变量的行为都是非法的。我们可以在成员函数体内部使用this，因此尽管没有必要，但我们还是能把isbn定义成如下的形式：

```C++
std::string isbn() const { return this->bookNo; }
```

因为this的目的总是指向“这个”对象，所以this是一个常量指针，我们不允许改变this中保存的地址。

#### 引入const 成员函数

isbn函数的另一个关键之处是紧随参数列表之后的const关键字，这里，const的作用是修改隐式this指针的类型。

默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this的类型是Sales_data *const。尽管this是隐士地，但它仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。

如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn的函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。

所以，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为**常量成员函数**。

因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。

#### 类作用域和成员函数

编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体内可以随意使用类中的其他成员而无须在意这些成员出现的次序。

#### 在类的外部定义成员函数

如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员名字必须包含它所属的类名。

#### 定义一个返回this对象的函数

```C++
Sales_data& Sales_data::combine(const Sales_data &rhs){
  units_sold += rhs.units_sold; // 把rhs成员加到this对象的成员上
  revenue += rhs.revenue;
  return *this; // 返回调用该函数的对象
  // return语句解引用this指针以获得执行该函数的对象，换句话说，上面的这个调用返回total的引用
}
```

### 7.1.3 定义类相关的非成员函数

类的作者常常需要定义一些辅助函数，比如add、read、和print等。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。

我们定义非成员函数的方式与定义其它函数一样，通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。

### 7.1.4 构造函数

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

构造函数的名字和类名相同。和其他函数不一样的是，**构造函数没有返回类型**；类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。

不同于其他成员函数，**构造函数不能被声明成const的**。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。

#### 合成的默认构造函数

类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数**。默认构造函数无须任何实参。

如果我们的类没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。

编译器创建的构造函数又被称为**合成的默认构造函数**。其初始化类的数据成员的规则如下：

- 如果存在类内的初始值，用它来初始化成员。
- 否则，默认初始化该成员。

因为Sales_data为units_sold和revenue提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员；同时，它把bookNo默认初始化成一个空字符串。

#### 某些类不能依赖于合成的默认构造函数

合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：

1. 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。
2. 对于某些类来说，合成的默认构造函数可能执行错误的操作。回忆我们之前介绍过的，如果定义在块中的内置类型或复合类型的对象被默认初始化，则他们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。
3. 有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。

#### 定义Sales_data的构造函数

```C++
struct Sales_data {
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) {}
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  Sales_data(std::istream &);
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
```

#### =default的含义

```C++
Sales_data() = default;
```

因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。我们希望这个函数的作用完全等同于之前使用的合成默认构造函数。

#### 构造函数初始值列表

```C++
Sales_data(const std::string &s): bookNo(s) {}
Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
```

花括号定义了（空的）函数体。

冒号和花括号之间的部分称为**构造函数初始值列表**，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。

只有一个string类型参数的构造函数使用这个string对象初始化bookNo，对于units_sold和revenue则没有显示的初始化。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。在此例中，这样的成员使用类内初始值初始化。等价于

```C++
Sales_data(const std::string &s): bookNo(s), units_sold(0), revenue(0) {}
```

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显示的初始化每个内置类型的成员。

#### 在类的外部定义构造函数

```C++
Sales_data::Sales_data(std::istream &is) {
  read(is, *this); // 从is中读取一条交易记录然后存入this对象中
}
```

没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。

### 7.1.5 拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。

如果我们不主动定义这些操作，则编译器将替我们合成他们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。

#### 某些类不能依赖于合成的版本

对于某些类来说，合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。管理动态内存的类通常不能依赖与上述操作的合成版本。

## 7.2 访问控制与封装

目前为止，我们的类还没有封装。在C++语言中，我们使用**访问说明符**加强类的封装性：

- 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。
- 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装（即隐藏了）类的实现细节。

````C++
// 再一次定义Sales_data类，其新形式如下所示：
class Sales_data {
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) {}
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  Sales_data(std::istream &);
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
private:
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
````

一个类包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。

#### 使用class或struct关键字

使用class和struct定义类的唯一区别是，struct和class的默认访问权限不太一样。

类可以在他的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。

> 使用class和struct定义类唯一的区别就是默认的访问权限。

### 7.2.1 友元

既然Sales_data的数据成员是private的，我们的read、print和add函数也就无法正常编译了，这是因为尽管这几个函数是累的接口的一部分，但他们不是类的成员。

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的**友元**。如果类想把一个函数成为它的友元，只需要增加一条friend关键字开始的函数声明语句即可：

```C++
class Sales_data{
  friend Sales_data add(const Sales_data&， const Sales_data&);
  friend std::istream &read(std::istream&, Sales_data&);
  ...
}
```

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。

#### 友元的声明

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。

为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中。

> 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。

最好为友元函数提供一个独立的函数声明，这样即使更换了一个有强制要求的编译器，也不必改编代码。

## 7.3 类的其他特性

### 7.3.1 类成员再探

#### 定义一个类型成员

除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种：

```C++
class Screen {
public:
  typedef std::string::size_type pos;
private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
}
```

Screen 的用户不应该知道 Screen 使用了一个string对象来存放它的数据，因此通过把pos定义成public成员可以隐藏Screen实现细节。

**用来定义类型的成员必须先定义后使用，这一点与普通成员所有区别**。因此，类型成员通常出现在类开始的地方。

#### Screen类的成员函数

```C++
class Screen {
public:
  typedef std::string::size_type pos;
  Screen() = default;
  Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht*wd, c) {}
  char get() const { return contents[cursor]; } // 读取光标处的字符 隐士内联函数
  inline char get(pos ht, pos wd) const; // 显式内联
  Screen &move(pos r, pos c); // 能在之后被设为内联
private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
}
```

第二个构造函数（接收三个参数）为cursor成员隐式地使用了类内初始值。如果类中不存在cursor的初始值，我们就需要像其他成员一样显示的初始化cursor了。

#### 令成员作为内联函数

定义在类内部的成员函数是自动inline的。因此，Screen的构造函数和返回光标所指字符的get函数默认是inline函数。

我们可以在类的内部把inline作为声明的一部分显式的声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：

```C++
inline
Screen &Screen::move (pos r, pos c) {
  pos row = r * width;
  cursor = row + c;
  return *this;
}
```

#### 重载成员函数

和非成员函数一样，成员函数也可以被重载，只要在函数之间的参数的数量或类型上有所区别就行。

#### 可变数据成员

有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。

一个**可变数据成员**永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。举个例子：

```C++
class Screen {
public:
  void some_member() const;
private:
	mutable size_t access_ctr; // 即使在一个const对象内也能被修改  
};
void Screen::some_member() const {
  ++access_ctr; 
}
```

尽管some_member是一个const成员函数，它仍然能够改变access_ctr的值。该成员是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值。

#### 类数据成员的初始值

定义好Screen类之后，我们将继续定义一个窗口类并用它表示显示器上的一组Screen。

```C++
class Window_mgr {
private:
  // 这个Window_mgr追踪的Screen
  // 默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen
  std::vector<Screen> screens{Screen(24,80,'')};
}
```

当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。在此例中，我们使用一个单独的元素值对vector成员执行了列表初始化。

如我们之前所知的，类内初始值必须使用=的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。

> 当我们提供一个类内初始值时，必须以符号=或者花括号表示。

### 7.3.2 返回*this的成员函数

接下来我们继续添加一些函数，他们负责设置光标所在位置的字符或者其他任一给定位置的字符：

```C++
class Screen {
public:
  Screen &set(char);
  Screen &set(pos, pos, char);
}
inline Scrren &Scrren::set(char c) {
  contents[cursor] = c; // 设置当前光标所在位置的新值
  return *this; // 将this对象作为左值返回
}
inline Scrren &Scrren::set(pos r, pos c, char c) {
  contents[r*width + col] = c; // 设置当前光标所在位置的新值
  return *this; // 将this对象作为左值返回
}
```

set成员的返回值是调用set的对象的引用。返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。

如果我们令move和set返回Screen而非Screen&，则下述语句的行为将大不相同。

```C++
// 如果move返回Screen而非Screen&
Screen temp = myScreen.move(4,0); // 对返回值进行拷贝
temp.set('#'); // 不会改变myScreen的contents
```

假如我们定义的返回类型不是引用，则move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变myScreen的值。

#### 从const成员函数返回*this

从逻辑上来说，显示一个Screen并不需要改变它的内容，因此我们令display为一个const成员，此时，this将是一个指向const的指针而*this是const对象。由此推断，display的返回类型应该是const Sales_data&。然而，如果真的令display返回一个const的引用，则我们将不能把display嵌入到一组动作序列中去：

```C++
Screen myScreen;
// 如果display 返回常量引用，则调用set将引发错误
myScreen.display(cout).set('#');
```

即使myScreen是个非常量对象，对set的调用也无法通过编译。问题在于display的const版本返回的是常量引用，而我们显然无权set一个常量对象。

> 一个const成员函数如果以引用的形式返回*this，那么他的返回类型将是常量引用。

#### 基于const的重载

通过区分成员函数是否是const的，我们可以对其进行重载。

因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。

```C++
class Screen {
public:
  // 根据对象是否是const 重载了display函数
  Screen &display(std::ostream &os) 
  { do_display(os); return *this; }
  const Screen &display(std::ostream &os) const 
  { do_display(os); return *this; }
private:
  // 该函数负责显示Screen的内容
  void do_display(std::ostream &os) const 
  { os << contents; }
};
```

当do_display完成后，display函数各自返回解引用this所得的对象。在非常量版本中，this指向一个非常量对象，因此display返回一个普通的（非常量）引用；而const成员则返回一个常量引用。

当我们在某个对象上调用display时，该对象是否是const决定了应该调用display的哪个版本。

### 7.3.3 类类型

每个类定义了唯一的类型。对于两个类来说，即使他们的成员完全一样，这两个类也是两个不同的类型。

我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面：

```C++
Sales_data item1;
class Sales_data item1;
// 两条声明完全等价
```

#### 类的声明

就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它。

这种声明被称为**前向声明**，他向程序中引入了类的名字（Screen）并且指明Screen是一种类类型，对于类型Screen来说，在它声明之后定义之前是一个**不完全类型**。

不完全类型只能在非常有限的情境下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。

### 7.3.4 友元再探

类可以把普通的非成员函数定义成友元。类还可以把其他的类定义成友元，也可以把其他类的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。

#### 类之间的友元关系

我们的Window_mgr类的某些成员可能需要访问它管理的Screen类的内部数据。例如：Window_mgr类中的函数clear需要访问Screen的私有成员；要想令这种访问合法，Screen需要把Window_mgr指定成它的友元：

```C++
class Screen {
  // Window_mgr 的成员可以访问Screen类的私有部分
  friend class Window_mgr;
}
```

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非共有成员在内的所有成员。

```C++
class Window_mgr {
public:
  using ScreenIndex = std::vector<Screen>::size_type;
  void clear(ScreenIndex);
private:
  std::vector<Screen> screens{Screen(24, 80 ,'')};
}
void Window_mgr::clear(ScreenIndex) {
  Screen &s = screens[ScreenIndex];
  s.contents = string(s.ht * s.wd, '');
}
```

如果clear不是Screen的友元，上面的代码将无法通过编译，因为此时clear将不能访问Screen的成员。

必须要注意的一点是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元不能理所当然地具有访问Screen的特权。

#### 令成员函数作为友元

除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：

```C++
class Screen {
  // Windoew_mgr::clear 必须在Screen类之前被声明
  friend void Windoew_mgr::clear(ScreenIndex);
  ....
}
```

要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：

- 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。
- 接下来定义Screen，包括对于clear的友元声明。
- 最后定义clear，此时它才可以使用Screen的成员。

#### 函数重载和友元

尽管重载函数的名字相同，但它们仍然是不同的函数，因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

#### 友元声明和作用域

类和非成员函数的声明不是必须在他们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定改名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。

甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：

```C++
struct X {
  friend void f() {/* 友元函数可以定义在类的内部 */}
  X() { f(); } // 错误：f还没有被声明
  void g();
  void h();
};
void X::g() {return f();} // 错误：f还没有被声明
void f(); // 声明那个定义在X中的函数
void X::h() { return f(); } // 正确：现在f的声明在作用域中了
```

关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。

## 7.4 类的作用域

每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。

#### 作用域和定义在类外部的成员

一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了。

另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。

```C++
// 例如
class Window_mgr {
public:
  // 向窗口添加一个Screen,返回它的编号
  ScreenIndex addScreen(const Screen&);
};
// 首先处理返回类型，之后我们才进入Window_mgr的作用域
Window_mgr::ScreenIndex
Window_mgr::addScreen(const Screen& s) {
  screens.push_back(s);
  return screens.size() - 1;
}
```

因为返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的。

### 7.4.1 名字查找与类的作用域

在目前为止，我们编写的程序中，**名字查找**（寻找与所用名字最匹配的声明的过程）的过程比较直截了当：

- 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。
- 如果没找到，继续查找外层作用域。
- 如果最终没有找到匹配的声明，则程序报错。

对于定义在类内部的成员函数来说，解析其中的名字的方式与上述的查找规则有所区别。类的定义分两步处理：

- 首先，编译成员的声明。
- 直到类全部可见后才编译函数体。

> 编译器处理完类中的全部声明后才会处理成员函数的定义。

#### 用于类成员声明的名字查找

这种两阶段的处理方式只适用于成员函数体中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。

```C++
typedef double Money;
string bal;
class Account {
public:
  Money balance() { return bal; }
private:
  Money bal;
  // .....
};
```

当编译器看到balance函数的声明语句时，他将在Account类的范围内寻找对Money的声明。编译器只考虑Account中在使用Money前出现的声明，因为没找到匹配的成员，所以编译器会接着到Account的外层作用域中查找。另一方面，balance函数体在整个类可见后才被处理，因此，该函数的return语句返回名为bal的成员，而非外层作用域的string对象。

#### 类型名要特殊处理

一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字：

```C++
typedef double Money;
class Account {
public:
  Money balance() { return bal; } // 使用外层作用域中的名字
private:
  typedef double Money; // 错误：不能重新定义Money
  Money bal;
  // .....
};
```

需要特别注意的是，即使Account中定义的Money类型与外层作用域一致，上述代码仍然是错误的。

> 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

#### 成员定义中的普通块作用域的名字查找

成员函数中使用的名字按照如下方式解析：

- 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。
- 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。
- 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。

一般来说不建议使用其他成员的名字作为某个成员函数的参数。

```C++
// 通常情况下不建议为参数和成员使用同样的名字
int height;
class Screen {
public:
  typedef std::string::size_type pos;
  void dummy_fcn(pos height) {
    cursor = width * height; // 哪个height?
  }
private:
  pos cursor = 0;
  pos height = 0, width = 0;
};
```

当编译器处理dummy_fcn中的乘法表达式时，他首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此dummy_fcn函数体内用到的名字height指的是参数声明。

在上述代码中，height参数隐藏了同名的成员。如果想绕开上面的查找规则应该将代码变为：

```C++
void Screen::dummy_fcn(pos height) {
  cursor = width * this->height; // 成员height
  cursor = width * Screen::height; // 成员height
}
```

> 尽管类的成员被隐藏了，但我们任然可通过加上类的名字或显示的使用this指针来强制访问成员。

#### 类作用域之后，在外围的作用域中查找

如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。

如果，我们需要的是外层作用域中的名字，可以显示的通过作用域运算符来进行请求：

```C++
void Screen::dummy_fcn(pos height) {
  cursor = width * ::height // 哪个height?是那个全局的
}
```

#### 在文件中名字的出现处对其进行解析

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。

```C++
int height;
class Screen {
public:
  typedef std::string::size_type pos;
  void setHeight(pos);
  pos height = 0; // 隐藏了外层作用域中的height
};
Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var) {
  // var: 参数
  // height: 类的成员
  // verify: 全局函数
  height = verify(var);
}
```

注意：全局函数verify的声明在Screen类的定义之前是不可见的。然后，名字查找的第三步包括了成员函数出现之前的全局作用域。

## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

如果没有在构造函数的初始值列表中显示的初始化成员，则该成员将在构造函数体之前执行默认初始化。

```C++
Sales_data::Sales_data(const string &s, unsigned cnt, double price) {
  bookNo = s;
  units_sold = cnt;
  revenue = cnt * price;
}
```

原来的版本（构造函数初始化版本）初始化了它的数据成员，而这个版本是对数据成员执行了赋值操作。

#### 构造函数的初始值有时必不可少

有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

```C++
class ConstRef {
public:
  ConstRef(int ii);
private:
  int i;
  const int ci;
  int &ri;
};
```

和其他常量对象或者引用一样，成员ci和ri都必须初始化。

```C++
ConstRef::constRef(int ii){
  i = ii; // 正确
  ci = ii; // 错误： 不能给const赋值
  ri = i; // 错误：ri没被初始化
}
```

随着构造函数体一开始执行，初始化就完成了。我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此构造函数的正确形式应该是：

```C++
// 正确：显示的初始化引用和const成员
ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) {}
```

> Note! 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。

#### 成员初始化的顺序

构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。

成员的初始化顺序与他们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。

> 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。

#### 默认实参和构造函数

```C++
class Sales_data {
public:
  Sales_data(std::string s = ""): bookNo(s) {}
  // ...
}
```

在上面这段程序中，当没有给定实参，或者给定了一个string实参时，两个版本的类创建了相同的对象。因为我们不提供实参也能调用上述的构造函数，所以该构造函数实际上为我们的类提供了默认构造函数。

> 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

### 7.5.2 委托构造函数

C++新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的**委托构造函数**。一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其它构造函数。

在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。

```C++
class Sales_data {
public:
  // 非委托构造函数
  Sales_data(std::string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), revenue(cnt*price) {}
  // 其余构造函数全部委托给另一个构造函数
  Sales_data(): Sales_data("", 0, 0) {}
  Sales_data(std::string s): Sales_data(s, 0, 0) {}
  Sales_data(std::istream &is): Sales_data() { read(is, *this); }
}
```

除了第一个，其他三个构造函数全部委托第一个构造函数完成初始化。

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，执行完后控制权才会交还给委托者的函数体。

### 7.5.3 默认构造函数的作用

当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生：

- 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时。
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
- 当类类型的成员没有在构造函数初始值列表中显示的初始化时。

值初始化在以下情况下发生：

- 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。
- 当我们不使用初始值定义一个局部静态变量时。
- 当我们通过书写形如T()的表达式显示的请求值初始化时，其中T()是类型名（vector的一个构造函数只接受一个实参用于说明vector大小，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。

类必须包含一个默认构造函数以便在上述情况下使用。

> 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。

### 7.5.4 隐式的类类型转换

我们也能为类定义隐式转换规则。如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐士转换机制，有时我们把这种构造函数称作**转换构造函数**。

> 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。

在Sales_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这两种类型向Sales_data隐式转换的规则。也就是说，在需要使用Sales_data的地方，我们可以使用string或者istream作为替代：

```C++
string null_book = "9-999-9999-9";
// 构造一个临时的Sales_data对象
// 该兑现的units_sold和revenue等于0,bookNo等于null_book
item.combine(null_book);
```

这里我们用一个string实参调用了Sales_data的combine成员。该调用是合法的，编译器用给定的string自动创建了一个Sales_data对象。新生成的这个（临时）Sales_data对象被传递给combine。因为combine的参数是一个常量引用，所以我们可以给该参数传递一个临时变量。

#### 只允许一步类类型转换

编译器只会自动的执行一步类类型转换。

```C++
// 因为下面的代码隐式的使用了两种转换规则，所以他是错误的
item.combine("9-99-999");
```

#### 抑制构造函数定义的隐式转换

在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为**explicit**加以阻止：

```C++
class Sales_data {
public:
  Sales_data() = default;
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  explicit Sales_data(const std::string &s): bookNo(s) {}
  explicit Sales_data(std::istream&);
};
```

此时，没有任何构造函数能用于隐式地创建Sales_data对象，之前的两种用法都无法通过编译。

```C++
item.combine(null_book); // 错误：string构造函数是explicit的
item.combine(cin); // 错误：istream构造函数是explicit的
```

关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复：

```C++
explicit Sales_data::Sales_data(istream &is) {
  read(is, *this);
}
```

#### explicit 构造函数只能用于直接初始化

发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=）此时，我们只能使用直接初始化而不能使用explicit构造函数：

```C++
Sales_data item1(null_book); // 正确：直接初始化
// 错误：不能将explicit构造函数用于拷贝形式的初始化过程
Sales_data item2 = null_book;
```

> 当我们使用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。

#### 为转换显示地使用构造函数

尽管编译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显示的强制进行转换：

```C++
// 正确： 实参是一个显示构造的Sales_data对象
item.combine(Sales_data(null_book));
// 正确： static_cast可以使用explicit的构造函数
item.combine(static_cast<Sales_data>(cin));
```

#### 标准库中含有显示构造函数的类

我们用过的一些标准库中的类含有单参数的构造函数：

- 接受一个单参数的const char*的string构造函数不是explicit的。
- 接受一个容量参数的vector构造函数是explicit的。

### 7.5.5 聚合类

**聚合类**使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：

- 所有成员都是public的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类，也没有virtual函数。

```C++
// 这是一个聚合类
struct Data {
  int ival;
  string s;
};
```

我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员：

```c++
// val1.ival = 0; val1.s = string("Anna")
Data val1 = {0, "Anna"};
```

初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。

与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。

值得注意的是，显示的初始化类的对象的成员存在三个明显的缺点：

- 要求类的所有成员都是public的
- 将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。
- 添加或删除一个成员之后，所有的初始化语句都需要更新。

### 7.5.6 字面值常量类

constexpr 函数的参数和返回值必须是字面值类型。和其他类不同，字面值类型的类可能含有constexpr函数成员。

数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合以下要求，则它也是一个字面值常量类：

- 数据成员都必须是字面值类型。
- 类必须至少含有一个constexpr构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

#### constexpr 构造函数

尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。

constexpr构造函数可以声明成=default的形式。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句）。综合这两点可知，constexpr构造函数体一般来说应该是空的。

```C++
class Debug {
public:
  constexpr Debug(bool b = true): hw(b), io(b), other(b) {}
  constexpr Debug(bool h, bool i, bool o): hw(h), io(i), other(o) {}
  constexpr bool any() { return hw || io || other; }
  void set_io(bool b) { io = b; }
  void set_hw(bool b) { hw = b; }
  void set_other(bool b) { other = b; }
 
private:
  bool hw;
  bool io;
  bool other;
};
```

constexpr 构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。

constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型。

## 7.6 类的静态成员

有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。

#### 声明静态成员

我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态成员的类型可以是常量、引用、指针、类类型等。

```C++
class Account {
public:
  void calculate() { amount += amount * interestRate; }
  static double rate() { return interestRate; }
  static void rate(double);
private:
  std::string owner;
  double amount;
  static double interestRate;
  static double initRate();
};
```

类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。

类似的，静态成员函数也不与任何对象绑定在一起，他们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。这一限制既适用于this的显示使用，也对调用非静态成员的隐式使用有效。

#### 使用类的静态成员

我们使用作用域运算符直接访问静态成员：

```C++
double r;
r = Account::rate(); 
```

虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员：

```C++
Account ac1;
Account *ac2 = &ac1;
r = ac1.rate();
r = ac2->rate();
```

成员函数不用通过作用域运算符就能直接使用静态成员：

```C++
class Account {
public:
  void calculate() { amount += amount * interestRate; }
private:
  static double interestRate;
}
```

#### 定义静态成员

和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句：

> 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。

因为静态数据成员不属于类的任何一个对象，所以他们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。

类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。

我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：

```C++
double Account::interestRate = initRate();
```

这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以访问类Account中的所有成员。

#### 静态成员的类内初始化

通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以他们能用在所有适合于常量表达式的地方。

```C++
class Account {
public:
  static double rate() { return interestRate; }
  static void rate(double);
private:
  static constexpr int period = 30;
  double daily_tbl[period];
};
```

如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须有一条定义语句。

例如：如果period的唯一用途就是定义daily_tbl的维度，则不需要在Account外面专门定义period。此时，如果我们忽略了这条定义，那么对程序非常微小的改动也可能造成编译错误，因为程序找不到该成员的定义语句。举个例子，当需要把Account::period传递给一个接受const int&的函数时，必须定义period。

如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了：

```C++
constexpr int Account::period; // 初始值在类的定义内提供
```

> 即使一个常量静态数据成员在类的内部被初始化了，通常情况下也应该在类的外部定义一下该成员。

####  静态成员能用于某些场景，而普通成员不能

某些非静态数据成员可能非法的场合，静态成员却可以正常使用。

静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用：

```C++
class Bar {
public:
  // ...
private:
  static Bar mem1; // 正确： 静态成员可以是不完全类型
  Bar *mem2; // 正确： 指针成员可以是不完全类型
  Bar mem3;  // 错误：数据成员必须是完全类型
}
```

静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参：

```C++
class Screen {
public:
  // bkground 表示一个在类中稍后定义的静态成员
  Screen& clear(char = bkground);
private:
  static const char bkground;
};
```

非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。

# 第8章 IO库

## 8.1 IO类

标准库还定义了其他一些IO类型：iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。

![](https://cdn.pkubailu.cn/img/8.1.png)

为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。

#### IO类型间的关系

标准库使我们能忽略这些不同类型的流之间的差异，这是通过**继承机制**实现的。利用模板，我们可以使用具有继承关系的类，而不必了解继承机制如何工作的细节。

简单地说，继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类（继承类）对象当作其基类（所继承的类）对象来使用。

### 8.1.1 IO对象无拷贝或赋值

 不能拷贝或对IO对象赋值：

```C++
ofstream out1, out2;
out1 = out2; // 错误：不能对流对象赋值
ofstream print(ofstream); // 错误：不能初始化ofstream参数
out2 = print(out2); // 错误： 不能拷贝流对象
```

由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。

### 8.1.2 条件状态

下表列出了IO类所定义的一些函数和标志，可以帮助我们访问和操纵流的**条件状态**。

![](https://cdn.pkubailu.cn/img/8.2-1.png)

![](https://cdn.pkubailu.cn/img/8.2-2.png)

一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：

```C++
while(cin >> word)
  // ok:读操作成功.....
```

while循环检查>>表达式返回的流的状态。

#### 查询流的状态

IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用。IO库定义了4个iostate类型的constexpr值，表示特定的位模式。这些值用来表示特定类型的IO条件，可以与位运算符一起使用来一次性检验或设置多个标志位。

badbit表示系统级错误，如不可恢复的读写错误。一旦badbit被置位，流就无法再使用了。在发生可恢复错误后，failbit被置位。如果到达文件结束位置，eofbit和fail都会被置位

goodbit的值为0，表示流未发生错误。如果badbit、failbit、eofbit任一个被置位，则检测流状态的条件会失败。

使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当做条件使用的代码就等价于!fail()。

#### 管理条件状态

流对象的rdstate成员返回一个iostate值，对应流当前状态。setstate操作将给定条件置位，表示发生了对应错误。clear成员是一个重载的成员：它有一个不接收参数的版本，而另一个版本接受一个iostate类型的参数。

clear不接收参数的版本清除（复位）所有错误标志位。执行clear()后，调用good会返回true。

```C++
// 记住cin的当前状态
auto old_state = cin.rdstate(); // 记住cin当前状态
cin.clear(); // 使cin有效
process_input(cin); // 使用cin
cin.setstate(old_state); // 将cin置为原有状态
```

带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。

```C++
cin.clear(cin.rdstate & ~cin.failbit & ~cin.badbit);
```

### 8.1.3 管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据。

```C++
os << "please enter a value";
```

文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。

导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：

- 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。
- 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
- 我们可以使用操作符如endl来显示刷新缓冲区。
- 在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。
- 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区刷新。

#### 刷新输出缓冲区

```C++
cout << "hi!" << endl; // 输出hi和一个换行，然后刷新缓冲区
cout << "hi!" << flush; // 输出hi，然后刷新缓冲区，不附加任何额外字符
cout << "hi!" << ends; // 输出hi和一个空字符，然后刷新缓冲区
```

#### unitbuf 操纵符

如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：

```C++
cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区
cout << nounitbuf; // 回到正常的缓冲方式
```

> Warning! 如果程序异常终止，输出缓冲区不会被刷新。它所输出的数据很可能停留在输出缓冲区中等待打印。

#### 关联输入和输出流

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起。

```c++
cin >> ival;
// 导致cout的缓冲区被刷新
```

tie有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即x.tie(&o)将x流关联到输出流o。

我们既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream：

```C++
cin.tie(&cout); // 标准库将cin和cout关联在一起
ostream *old_tie = cin.tie(nullptr); // cin不再与其他流关联
cin.tie(&cerr); // 读取cin会刷新cerr而不是cout
cin.tie(old_tie); // 重建cin和cout间的正常关联
```

为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了tie。为了彻底揭开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。

