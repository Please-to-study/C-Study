# 第2章 变量和基本类型

## 2.1 基本内置类型

C++定义了一套包括**算术类型和空类型**在内的基本数据类型。

算术类型： 字符、整型数、布尔值、浮点数。

空类型不对应具体的值。

### 2.1.1 算术类型

算术类型分为两类：整型（包括字符和布尔类型在内）和浮点型。

![](https://cdn.pkubailu.cn/img/2.1.png)

### 2.1.2 类型转换

**切勿混用带符号类型和无符号类型**

> Note! 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号类型数。

### 2.1.3 字面值常量

一个形如42的值被称作**字面值常量**，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

#### 整型和浮点型字面值

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数。十进制字面值的类型是int、long和long long中尺寸最小的那个。

默认的，浮点型字面值是一个double。

#### 字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

字符串字面值的类型实际上是由常量字符构成的数组。

## 2.2 变量

#### 列表初始化

```C++
// 初始化方式
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：

```C++
long double ld = 3.1415926;
int a{ld}, b = {ld}; // 错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld; // 正确：转换执行，且确实丢失了部分值
```

#### 默认初始化

如果是内置类型的变量未被显示初始化，他的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

类的对象如果没有显示的初始化，则其值由类决定。

### 2.2.2 变量的声明和定义的关系

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示的初始化变量：

```C++
extern int i; // 声明i而非定义i
int j; // 声明并定义j
```

任何包含了显示初始化的声明即成为定义。

```C++
extern double pi = 3.1416; // 定义
```

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

## 2.3 复合类型

### 2.3.1 引用

1. 程序把引用和它的初始值绑定到一起，而不是将初始值拷贝给引用。一但初始化完成，引用将和它的初始值对象一直绑定到一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
2. 引用并非对象，相反的它只是为一个已经存在的对象所起的另外一个名字。
3. 引用的类型都要和与之绑定的对象严格匹配。（但有两种例外情况）
4. 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。

### 2.3.2 指针

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须在定义的时候赋初值。和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

3. 指针的类型都要和它所指向的对象严格匹配。（但有两种例外情况）

#### 空指针

空指针不指向任何对象。

```c++
# 生成空指针的方法
int *p = nullptr;
int *p = 0;
//需要首先#include cstdlib
int *p = NULL;
```

#### void* 指针

void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址追踪到底是个什么类型的对象并不了解。

利用void* 指针能做的事比较有限：拿他和别的指针比较、作为函数的输入输出、或者赋值给另外一个void\*指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

### 2.3.3 理解复合类型的声明

#### 指向指针的指针

通过*的个数可以区分指针的级别。也就是说，\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针，以此类推：

```C++
int ival = 1024;
int *pi = &ival; // pi指向一个int型的数
int **ppi = &pi; // ppi指向一个int型的指针
```

解引用int型指针会得到一个int型的数，同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用。

#### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```C++
int i = 42;
int *p = 0; // p是一个int型指针
int *&r = p; // r是对指针p的引用

r = &i; // 给r赋值&i就是让p指向i
*r = 0; // 解引用r得到i,也就是p指向的对象，将i的值改为0
```

### 2.4 const限定符

**如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字**

#### 2.4.1 const的引用

1. 把引用绑定到const对象上，我们称之为**对常量的引用**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci = 1024;
const int &r1 = ci;
r1 = 0;  // 错误：ri是对常量的引用，常量无法被修改。
int &r2 = ci; // 错误：试图让一个非常量引用指向一个常量对象。他们的类型不一致！
```

**引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是：在初始化常量引用的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式**

```c++
int i = 42;
const int &r1 = i; // 允许将const int&绑定到一个普通int对象上;
const int &r2 = 42; // 正确：r2是一个常量引用;
const int &r3 = r1 * 2; // 正确： r3是一个常量引用;
int &r4 = r1 * 2;  // 错误：r4是一个普通的非常量引用;
```

**对const的引用可能引用一个并非const的对象**

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 42;
int &r1 = i; // 引用r1绑定对象i
const int &r2 = i; // r2也绑定对象i,但是不允许通过r2来修改i的值;
r1 = 0; // r1并非常量,i的值修改为0;
r2 = 0; // 错误：r2是一个常量引用，不可以做修改操作;
```

### 2.4.2 指针和const

与引用一样，也可以令指针指向常量或非常量。类似于常量引用，**指向常量的指针**不能用于改变其所指对象的值。

指针的类型必须与其所指向对象的类型一致，但是有两个例外。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象。

```c++
const double pi = 3.14; //pi是一个常量，他的值不能改变; 
double *ptr = &pi; // 错误：ptr 是一个普通指针;
const double *cptr = &pi; // 正确：cptr可以指向一个双精度常量;
*cptr = 42; // 错误：cptr指向的是一个常量，不能给cptr赋值;
double dval = 3.14;
cptr = &dval; // 正确：但是不能通过cptr改变dval的值;
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量，所为指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

> 所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以觉得不去改变所指对象的值。

### 2.4.3 顶层const 

**顶层const **：表示指针本身是个常量。

**底层const：**表示指针所指对象是一个常量。

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显，其中顶层const不受什么影响。顶层const只是标注了变量本身是const不允许改变，而底层const表示了变量所指的对象的类型，在拷贝时要求拷贝对象和被拷贝对象类型一致！

### 2.4.4 constexpr 和常量表达式

**常量表达式**是指值不会改变并且在编译过程中就能得到计算结果的表达式。

一个对象或表达式是不是常量表达式由他的数据类型和初始值共同决定。

#### 字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明 constexptr 时用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见、容易得到，就称之为“字面值类型” 算术类型、引用和指针都属于字面值类型。

一个 constexpr 指针的初始值必须是 nullptr 或者0，或者是存储在某个固定地址中的对象。

函数体外的对象其地址固定不变，能用来初始化constexpr指针。

函数体内定义的变量一般来说并非存放在固定地址中，不能初始化 constexpr 指针，但是函数体内也可以定义一类有效范围超出函数本身的变量，这类变量也有固定地址。

```c++
const int *p = nullptr; //p是一个指向整型常量的指针;
constexpr int *q = nullptr; // q是一个指向整型的常量指针
```

## 2.5 处理类型

### 2.5.1 类型别名

有两种方法可用于定义类型别名：

```c++
// 1.传统方法typedef:
typedef double wages; // wages是double的同义词
// 2.别名声明:
using SI = Sales_item; // SI是Sales_item的同义词
```

#### 指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。

```C++
typedef char *pstring; // pstring 是类型 char* 的别名
const pstring cstr = 0; // cstr 是指向char的常量指针
const pstring *ps; // ps 是一个指针，它的对象是指向char的常量指针
```

遇到一条使用了类型别名的声明语句时，人们往往会错误的尝试把类型别名替换成它本来的样子，以理解该语句的含义：

```C++
const char *cstr = 0; // 是对 const pstring cstr 的错误理解
```

**这种理解是错误的！**声明语句中用到pstring时，其基本数据类型是指针。可是用char\*重写了声明语句后，数据类型就变成了char，*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

### 2.5.2 auto类型说明符

auto类型说明符能让编译器通过初始值来推算变量的类型，显然auto定义的变量必须有初始值。

auto一般会忽略掉顶层const，同时底层const则会保留下来。变量b、c是案例。

设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留！变量g是案例。

例子：

```c++
	 int i = 0, &r = i;
   auto a = r;   // auto = int a是整数
   const int ci = i, &cr = ci; 
   auto b = ci; // auto = int b是整数
   auto c = cr; // auto = int c是整数
   auto d = &i; // auto = int d是i的地址值
   auto e = &ci; // auto = int e是i的地址值
   auto &g = ci; // auto = const int  g是整型常量引用 绑定到ci上
```

### 2.5.3 decltype 类型指示符

**decltype**：它的作用是选择并返回操作数的数据类型。

decltype处理顶层const和引用的方式与auto有些不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&, y绑定到变量x 
decltype(cj) z; // 错误：z是一个引用，必须初始化
```

**需要指出的是，引用从来都是作为其所指对象的同义词出现，只有用在decltype处是一个例外**

#### decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

r是个引用，所以decltype(r)的结果是引用类型，如果想让结果类型是r所指对象的类型，可以把r作为表达式的一部分，例如r+0.

如果表达式的内容是解引用操作，则decltype将得到引用类型.

```c++
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // 正确：加法的结果是int,因此b是一个（未初始化的）int
decltype(*p) c; // 错误：c是int&,必须初始化
```

如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式，decltype就会得到引用类型：

```c++
decltype((i)) d; //错误： d是int&,必须初始化
decltype(i) e; // 正确：e是一个（未初始化的）int
```

> !切记：decltype((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。

## 2.6 自定义数据结构

### 2.6.3 编写自己的头文件

#### 预处理器概述

预处理变量有两种状态：已定义和未定义。

**#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**ifndef**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到**#endif**指令为止。

> 预处理变量无视C++语言中关于作用域的规则。

> 头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符

## 2.7 总结

1. 基本数据类型：

   算术类型：字符、整型数、布尔值、浮点数

   空类型：不对应具体的值

2. 切勿混用带符号类型和无符号类型：

   如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号类型数。

3. 一个形如42的值被称作**字面值常量**，这样的值一望而知。

4. 由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

5. 如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错

6. 如果是内置类型的变量未被显示初始化，他的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将不被初始化。

7. 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

8. 任何包含了显示初始化的声明即成为定义。

9. 引用：

   1. 一但初始化完成，引用将和它的初始值对象一直绑定到一起。引用必须初始化。
   2. 引用并非对象。
   3. 引用的类型都要和与之绑定的对象严格匹配。（但有两种例外情况）
   4. 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。

10. 指针：

    1. 指针本身就是一个对象，允许对指针赋值和拷贝。
    2. 指针无须在定义的时候赋初值。
    3. 指针的类型都要和它所指向的对象严格匹配。（但有两种例外情况）

11. void* 是一种特殊的指针类型，可用于存放任意对象的地址。

12. 利用void* 指针能做的事比较有限：拿他和别的指针比较、作为函数的输入输出、或者赋值给另外一个void\*指针。不能直接操作void*指针所指的对象。

13. 引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用

14. 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字

15. 引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是：在初始化常量引用的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式

16. 对const的引用可能引用一个并非const的对象

17. 与引用一样，也可以令指针指向常量或非常量。类似于常量引用，**指向常量的指针**不能用于改变其所指对象的值。

18. 指针的类型必须与其所指向对象的类型一致，但是有两个例外。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象。

19. **顶层const **：表示指针本身是个常量。

    **底层const：**表示指针所指对象是一个常量。

20. **常量表达式**是指值不会改变并且在编译过程中就能得到计算结果的表达式。

21. 有两种方法可用于定义类型别名：

    ```c++
    // 1.传统方法typedef:
    typedef double wages; // wages是double的同义词
    // 2.别名声明:
    using SI = Sales_item; // SI是Sales_item的同义词
    ```

22. auto 和 decltype 类型说明符

23. **#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**ifndef**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到**#endif**指令为止。

# 第3章 字符串、向量和数组

## 3.1 命名空间的using声明

有了using声明就无需专门的前缀（形如命名空间::）也能使用所需的名字了。

using声明具有如下的形式：

```c++
using namespace::name;
// 一旦声明了上述语句，就可以直接访问命名空间中的名字
```

> **!头文件不应包含using声明**

## 3.2 标准库类型 string

### 3.2.1 定义和初始化string对象

![image-20211115175652876](https://cdn.pkubailu.cn/img/3.1.png)

#### 直接初始化和拷贝初始化

如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化。

### 3.2.2 string对象上的操作

![image-20211115180215371](https://cdn.pkubailu.cn/img/3.2.png)

#### 读写string对象

```c++
int main() 
{
  string s;
  cin >> s;
  cout << s << endl;
  return 0;
}
// 在执行读取操作时，string对象会自动忽略开头的空白（即空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。
// 如果输入是"    hello world!    "则输出将是"hello"
```

#### 使用getline读取一整行

如果希望在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的 >> 运算符。

getline从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始输入的是换行符，那么所得的结果是个空string。

#### 比较 string 对象

字典序规则！

### 3.2.3 处理string对象中的字符

![image-20211115191804174](https://cdn.pkubailu.cn/img/3.3.png)

#### 处理每个字符？使用基于范围的for语句

语法形式：

```c++
for (declaration : expression)
  statement
```

## 3.3 标准库类型 vector

编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

> vector 是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>

### 3.3.1 定义和初始化vector对象

![image-20211119003835476](https://cdn.pkubailu.cn/img/3.4.png)

#### 列表初始化vector对象

在大多数情况下这些初始化方式可以相互等价的使用，不过也并非一直如此。两种例外情况如下：

1. 使用拷贝初始化时（即使用=时）只能提供一个初始值；
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。

第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化。

#### 值初始化

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个**值初始化的**元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。

```C++
vector<int> ivec(10); //10个元素 每个都初始化为0
vector<string> svec(10) // 10个元素，每个都是空的string对象
```

对这种初始化的方式有两个特殊限制：

1. 有些类要求必须明确的提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始化的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：

```C++
vector<int> vi = 10; // 错误：必须使用直接初始化的形式指定向量大小
```

#### 列表初始值还是元素数量

![image-20211121004224917](https://cdn.pkubailu.cn/img/列表初始值还是元素数量1.png)

![image-20211121004346187](https://cdn.pkubailu.cn/img/列表初始值还是元素数量2.png)

### 3.3.2 向vector对象中添加元素

可以先创建一个空的vector对象，然后在运行时再利用vector的成员函数**push_back**向其中添加元素。

>! 范围for语句体内不应该改变其所遍历序列的大小。

### 3.3.3 其他vector操作

![image-20211121005240108](https://cdn.pkubailu.cn/img/3.5.png)

> Note：要使用size_type，需要先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型
>
> ```C++
> vector<int>::size_type  // 正确
> vector::size_type  // 错误
> ```

两个vector对象相等当且仅当他们所含的元素个数相同，而且对应位置的元素值也相同。

关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。

只有当元素的值可比较时，vector对象才能被比较。

## 3.4 迭代器介绍

有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

### 3.4.1 使用迭代器

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。这些类型都拥有名为**begin**和**end**的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器，end成员则负责返回指向容器”尾元素的下一位置“的迭代器，简称为尾迭代器。

#### 迭代器运算符

![3.6](https://cdn.pkubailu.cn/img/3.6.png)

#### 将迭代器从一个元素移动到另外一个元素

迭代器使用递增（++）运算符来从一个元素移动到下一个元素。

> Note：因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。

#### 迭代器类型

迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型

![迭代器类型](https://cdn.pkubailu.cn/img/迭代器类型.png)

const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。

#### begin和end运算符

```C++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 的类型是vector<int>::iterator
auto it2 = cv.begin(); // it2 的类型是vector<int>::const_iterator
```

为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend：

```C++
auto it3 = v.cbegin(); // it3 的类型是vector<int>::const_iterator
```

不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

#### 结合解引用和成员访问操作

```C++
(*it).empty() // 解引用it，然后调用结果对象的empty()成员
*it.empty()  //错误： 试图访问it的名为empty的成员，但it是个迭代器，没有empty成员
```

为了简化上述表达式，C++语言定义了**箭头运算符**(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it->mem和(*it).mem表达的意思相同。

#### 某些对vector对象的操作会使迭代器失效

>**谨记！，但凡是使用了迭代器的循环体，都不要向迭代其所属的容器添加元素。**

### 3.4.2 迭代器运算

![3.7](https://cdn.pkubailu.cn/img/3.7.png)

#### 迭代器的算术运算

对于string或vector的迭代器来说，除了判断是否相等，还能使用关系运算符(<、<=、>、>=)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。例如，假设it和mid是同一个vector对象的两个迭代器，可以用下面的代码来比较他们所指的位置谁前谁后：

```C++
if (it < mid)
	// 处理vector前半部分的元素
```

## 3.5 数组

### 3.5.1 定义和初始化内置数组

默认情况下，数组的元素被默认初始化

> Warning! 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

#### 显示初始化数组

![显示初始化数组](https://cdn.pkubailu.cn/img/显示初始化数组.png)

#### 字符数组的特殊性

![字符数组的特殊性](https://cdn.pkubailu.cn/img/字符数组的特殊性.png )

#### 不允许拷贝和赋值

![不允许拷贝和赋值](https://cdn.pkubailu.cn/img/不允许拷贝和赋值.png )

#### 理解复杂的数组声明

定义数组的指针和数组的引用：

![数组的指针和数组的引用](https://cdn.pkubailu.cn/img/数组的指针和数组的引用.png )

对于数组而言，由内向外阅读要比从右向左好多了。例如：首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。

### 3.5.2 访问数组元素

最好的办法是使用范围for语言。

使用数组下标的时候，通常将其定义为**size_t**类型。

数组除了大小固定这一特点外，其他用法与vector基本类似。

### 3.5.3 指针和数组

> Note： 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

这一结论有很多隐含的意思：

1. 当使用数组作为一个auto变量的初始值时。推断得到的类型是指针而非是数组：

```C++
int ia[] = {0,1,2,3,4}; // ia 是一个含有5个整数的数组
auto ia2(ia); // ia2是一个整型指针,指向ia的第一个元素
ia2 = 42; // 错误：ia2是一个指针，不能用int值给指针赋值
```

必须指出的是，当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组：

```C++
// ia3 是一个含有5个整数的数组
decltype(ia) ia3 = {0,1,2,3,4};
ia3 = p; // 错误：不能用整形指针给数组赋值
ia3[4] = i; //正确：把i的值赋给ia3的一个元素
```

#### 指针也是迭代器

允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

```C++
int arr[] = {0,1,2,3,4};
int *p = arr; // p指向arr的第一个元素
++p; // p指向arr[1]
```

利用指针的循环

```C++
int *e = &arr[10];
for (int *b = arr; b != e; ++b)
  cout << *b <<endl;
```

#### 标准库函数begin和end

C++新标准引入了两个名为begin和end的函数

```C++
int ia[] = {0,1,2,3,4}; // ia是一个含有5个整数的数组
int *beg = begin(ia); //指向ia首元素的指针
int *last = end(ia); // 指向arr尾元素的下一位置的指针
```

>Note：一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。

#### 指针运算

指向数组元素的指针可以执行所有的迭代器运算。例如：解引用、递增、比较、与整数相加、两个指针相减等。

给指针加（减）一个整数，得到的新指针仍需要指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置。

```C++
//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置
int *p = arr + sz; //使用警告:不要解引用！
int *p2 = arr + 10; // 错误：arr只有5各元素，p2的值未定义
// 如果计算所得的指针超出了上述范围就将产生错误，而且这种错误编译器一般发现不了。
```

如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果当然是0；

#### 解引用和指针运算的交互

```C++
int ia[] = {0,2,4,,6,8}; //含有5个整数的数组
int last = *(ia + 4); //正确：把last初始化成8，也就是ia[4]的值
```

#### 下标和指针

对数组执行下标运算其实是对指向数组元素的指针执行下标运算：

```C++
int i = ia[2]; //ia转换成指向数组首元素的指针
							//ia[2]得到(ia + 2)所指的元素
int *p = ia; // p指向ia的首元素
i = *(p + 2) // 等价于i = ia[2]
```

只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：

```c++
int *p = &ia[2]; // p指向索引为2的元素
int j = p[1]; // p[1]等价于 *(p+1),就是ia[3]表示的那个元素
int k = p[-2]; // p[-2]是ia[0]表示的那个元素
```

虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。

> 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。

### 3.5.4 C风格字符串

#### C标准库String函数

![C风格字符串函数](https://cdn.pkubailu.cn/img/3.8.png )

传入此类函数的指针必须指向以空字符作为结束的数组：

```C++
char ca[] = {'c','+','+'};  // 不以空字符结束
cout << strlen(ca) << endl; // 严重错误：ca没有以空字符结束
```

#### 比较字符串

比较C风格的字符串和比较标准库string对象的方法大相径庭。

string对象的比较可以用关系运算符，而C风格字符串用关系运算符比较的是指针所指对象的地址。

```C++
string s1 = "A string example";
string s2 = "A different example";
if (s1 < s2) // false: s2 小于 s1
const char ca1[] = "A string example";
const char ca2[] = "A different example";
if (ca1 < ca2) // 未定义的：试图比较两个无关地址
```

### 3.5.5 与旧代码的接口

#### 混用string对象和C风格字符串

允许使用字符串字面值来初始化string对象:

```c++
string s("hello world"); // s的内容是hello world
```

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：

- 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值。
- 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

**上述性质反过来不成立！**

不能使用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数:

```c++
char *str = s; //错误: 不能用string对象初始化char*
const char *str = s.c_str(); // 正确
```

#### 使用数组初始化vector对象

不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。

```c++
int int_arr[] = {0,1,2,3,4};
vector<int> ivec(begin(int_arr), end(int_arr));
```

在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化的值在数组int_arr中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。

> 应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。

## 3.6 多维数组

C++语言中的多维数组其实是数组的数组。

```C++
size_t cnt = 0;
for (auto &row : ia) {
  for (auto &col : row) {
    col = cnt;
    cnt++;
  }
}
```

> Note! 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

#### 指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

> Note! 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。

```C++
// 在下述声明中，圆括号必不可少
int *ip[4]; // 整型指针的数组
int (*ip)[4]; // 指向含有4个整数的数组
```

```C++
//输出ia中每个元素的值，每个内层数组各占一行
// p指向含有4个整数的数组
for (auto p = ia; p != ia + 3; ++p) {
  for (auto q = *p; q != *p + 4; ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

使用标准库函数begin和end也能实现同样的功能。

```C++
for (auto p = begin(ia); p != end(ia); ++p) {
  for (auto q = begin(*p); q != end(*p); ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

## 3.7 总结

1. 如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化。

2. 在执行读取操作时，string对象会自动忽略开头的空白（即空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。如果输入是"    hello world!    "则输出将是"hello"

3. getline从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始输入的是换行符，那么所得的结果是个空string。

4. String 对象的比较遵循字典序规则

5. 编译器根据模板创建类或函数的过程称为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

6. 列表初始化与值初始化：

   大多数情况下这些初始化方式可以相互等价的使用，不过也并非一直如此。两种例外情况如下：

   1. 使用拷贝初始化时（即使用=时）只能提供一个初始值；
   2. 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化。

7. 值初始化的两个特殊限制：

   1. 有些类要求必须明确的提供初始值，对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
   2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化

8. 范围for语句体内不应该改变其所遍历序列的大小。

9. 要使用size_type，需要先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型

   ```C++
   vector<int>::size_type  // 正确
   vector::size_type  // 错误
   ```

10. 关系运算符依照字典顺序进行比较：如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。

11. 只有当元素的值可比较时，vector对象才能被比较。

12. 有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

13. 因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。

14. C++语言定义了**箭头运算符**(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it->mem和(*it).mem表达的意思相同。

15. 谨记！，但凡是使用了迭代器的循环体，都不要向迭代其所属的容器添加元素

16. 参与比较的两个迭代器必须合法而且指向的是同一个容器的元素。通过比较可以决定两个迭代器的先后位置。

17. 默认情况下，数组的元素被默认初始化。如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值

18. 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

19. 数组不允许拷贝和赋值

20. 需要理解复杂的数组声明（3.5.1节）

21. 使用数组下标的时候，通常将其定义为**size_t**类型。

22. 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针

23. 当使用数组作为一个auto变量的初始值时。推断得到的类型是指针而非是数组

24. 当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组

25. 允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上

26. 指向数组元素的指针可以执行所有的迭代器运算。例如：解引用、递增、比较、与整数相加、两个指针相减等

27. 给指针加（减）一个整数，得到的新指针仍需要指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置

28. 对数组执行下标运算其实是对指向数组元素的指针执行下标运算

29. 虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。

30. 传入C风格字符串的函数的指针必须指向以空字符作为结束的数组

31. string对象的比较可以用关系运算符，而C风格字符串用关系运算符比较的是指针所指对象的地址

32. 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：

    - 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值。
    - 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

33. 不能使用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数:

    ```c++
    char *str = s; //错误: 不能用string对象初始化char*
    const char *str = s.c_str(); // 正确
    ```

34. 不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。

    ```c++
    int int_arr[] = {0,1,2,3,4};
    vector<int> ivec(begin(int_arr), end(int_arr));
    ```

35. 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型

36. 当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针

37. 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组

# 第 4 章 表达式

## 4.1 基础

#### 重载运算符

当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为**重载运算符**

#### 左值和右值

当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。例如：

假定p的类型是int *，因为解引用运算符生成左值，所以decltype(\*p)的结果是int&。另一方面，因为取地址运算符生成右值，所以decltype(&p)的结果是int**,也就是说，结果是一个指向整型指针的指针。

## 4.2 算术运算符

在除法运算中，如果两个运算对象的符号相同则商为正（如果不为0的话），否则商为负。C++新标准规定商一律向0取整（即直接切除小数部分）。

C++新标准规定：(-m)/n 和 m/(-n)都等于-(m/n), m%(-n)等于m%n, (-m)%n等于-(m%n)。

## 4.6 成员访问运算符

点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr->mem等价于(*p).mem

## 4.7 条件运算符

条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算表达式时，通常需要在它的两端加上括号。

## 4.8 位运算符

左移运算符（<<）在右侧插入值为0的二进制位。右移运算符（>>）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。

## 4.9 sizeof运算符

sizeof运算符返回一条表达式或一个类型名字所占的字节数。

```C++
// 运算符的运算对象有两种形式
sizeof (type)
sizeof expr
// 在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值。
```

![](https://cdn.pkubailu.cn/img/sizeof运算符.png)

因为sizeof不会实际求运算对象的值，所以即使p是一个无效(即未初始化)的指针也不会有什么影响。sizeof不需要真的解引用指针也能知道它所指对象的类型。

sizeof运算符的结果部分地依赖于其作用的类型：

- 对char或者类型为char的表达式执行sizeof运算，结果得1.
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
- 对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。
- 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次siezof运算并将所得结果求和，注意，sizeof运算不会把数组转换成指针来处理。
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

```C++
// sizeof(ia)/sizeof(*ia)返回ia的元素数量
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz]; //正确：sizeof返回一个常量表达式
```

## 4.11 类型转换

在下面这些情况下，编译器会自动地转换运算对象的类型：

- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。

### 4.11.1 算数转换

1. 首先执行整型提升。如果结果的类型匹配，无需进行进一步的转换。如果两个运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。
2. 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。假设两个类型分别是unsigned int 和 int，则int类型的运算对象转换成unsigned int 类型。需要注意的是，如果int型的值恰好为负值，则采用取模的方式转换。
3. 剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

### 4.11.2 其他隐式类型转换

#### 数组转换成指针

在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针

```C++
int ia[10]; 
int *ip = ia; //ia 转换成指向数组首元素的指针
```

当数组被用作decltype关键字、取地址符(&)、sizeof及typeid等运算符的参数时，不会发生转换。

#### 指针的转换

常量整数值0或者字面值nullptr能转换成任意指针类型

指向任意非常量的指针能转换成void*

指向任意对象的指针能转换成const void*

#### 转换成布尔类型

存在一种从算术类型或指针类型向布尔类型自动转换的机制。

```C++
char *cp = get_string();
if (cp)   //如果指针cp不是0，条件为真
while(*cp) // 如果*cp不是空字符，条件为真
```

#### 转换成常量

允许将指向非常量类型的指针转换成指向相应常量类型的指针，对于引用也是这样。

```C++
int i;
const int &j = i; // 非常量转换成const int 的引用
const int *p = &i; //非常量的地址转换成const的地址
int &r = j, *q = p; //错误：不允许const转换成非常量
```

#### 类类型定义的转换

```C++
string s, t = "a value";  // 字符串字面值转换成string类型
while(cin >> s) // while 的条件部分把cin转换成布尔值
```

### 4.11.3 显示转换

#### 命名的强制类型转换

```C++
// 一个命名的强制类型转换具有如下形式：
cast-name<type>(expression);
// type 是转换的目标类型
// expression 是要转换的值
// cast-name 是 static_cast、dynamic_cast、const_cast、reinterpret_cast中的一种
```

####  static_cast

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

```C++
// 进行强制类型转换以便执行浮点数除法
double slope = static_cast<double>(j) / i;
```

当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。

static_cast对于编译器无法自动执行的类型转换也非常有用。

```C++
// 使用static_cast找回存在于void*指针中的值
void* p = &d; // 正确：任何非常量对象的地址都能存入void*
double *dp = static_cast<double*>(p); //正确：将void*转换回初始的指针类型
// 我们必须确保转换后所得的类型就是指针所指的类型
```

#### const_cast

const_cast只能改变运算对象的底层const

```C++
const char *pc;
char *p = const_cast<char*>(pc); // 正确：但是通过p写值是未定义的行为
```

只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。

#### reinterpret_cast

reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。例如：

```C++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。

## 4.12 总结

1. 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。
2. 在除法运算中，如果两个运算对象的符号相同则商为正（如果不为0的话），否则商为负。C++新标准规定商一律向0取整（即直接切除小数部分）。
3. C++新标准规定：(-m)/n 和 m/(-n)都等于-(m/n), m%(-n)等于m%n, (-m)%n等于-(m%n)。
4. 点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr->mem等价于(*p).mem
5. 条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算表达式时，通常需要在它的两端加上括号。
6. 左移运算符（<<）在右侧插入值为0的二进制位。右移运算符（>>）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。
7. sizeof运算符返回一条表达式或一个类型名字所占的字节数
8. 因为sizeof不会实际求运算对象的值，所以即使p是一个无效(即未初始化)的指针也不会有什么影响。sizeof不需要真的解引用指针也能知道它所指对象的类型。
9. sizeof运算符的结果部分地依赖于其作用的类型：
   - 对char或者类型为char的表达式执行sizeof运算，结果得1.
   - 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
   - 对指针执行sizeof运算得到指针本身所占空间的大小。
   - 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。
   - 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次siezof运算并将所得结果求和，注意，sizeof运算不会把数组转换成指针来处理。
   - 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。
10. 首先执行整型提升，将小类型的运算对象转换成较大的类型
11. 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。
12. 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针
13. 当数组被用作decltype关键字、取地址符(&)、sizeof及typeid等运算符的参数时，不会发生转换
14. 指向任意非常量的指针能转换成void\*，指向任意对象的指针能转换成const void*
15. 存在一种从算术类型或指针类型向布尔类型自动转换的机制。
16. 允许将指向非常量类型的指针转换成指向相应常量类型的指针，对于引用也是这样。
17. 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。
18. 当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。
19. static_cast对于编译器无法自动执行的类型转换也非常有用。
20. const_cast只能改变运算对象的底层const

# 第5章 语句

### 5.3.2 switch语句

case关键字和它对应的值一起被成为**case标签**。case标签必须是整型常量表达式：

```C++
char ch = getVal();
int ival = 42;
switch(ch) {
  case 3.14: // 错误：case标签不是一个整数
  case ival: // 错误：case标签不是常量
}
```

## 5.6 try语句块和异常处理

在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。

寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch字句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。

如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数，一般情况下，执行该函数将导致程序非正常退出。

如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。

# 第6章 函数

## 6.1 函数基础

函数有几个形参，我们就必须提供相同数量的实参。

#### 函数的形参列表

```C++
void f1(){} // 隐式地定义空形参列表
void f2(void) {} // 显式的定义空形参列表
```

#### 函数返回类型

函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

### 6.1.1 局部对象

#### 自动对象

我们把只存在于块执行期间的对象称为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

#### 局部静态对象

可以将局部变量定义成static类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对他有影响。

如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。

### 6.1.2 函数声明

函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称为**函数原型**

> Note! 含有函数声明的头文件应该被包含到定义函数的原文件中。

## 6.2 参数传递

### 6.2.3 const形参和实参

和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。

调用fcn函数时，既可以传入const int也可以传入int。忽略掉形参的顶层const可能产生意想不到的结果:

```C++
void fcn(const int i) { // fcn 能够读取i，但是不能向i写值 }
void fcn(int i) {} // 错误：重复定义了fcn(int)
```

当重载函数fcn时发生错误，因为顶层const被忽略掉了，所以在上面的代码中传入两个fcn函数的参数可以完全一样，所以第二个fcn是错误的。

#### 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地现值函数所能接受的实参类型。我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

### 6.2.4 数组形参

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：

1. 不允许拷贝数组
2. 使用数组时（通常）会将其转换成指针

尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：

```C++
// 尽管形式不同，但这三个print函数式等价的
// 每个函数都有一个const int*类型的形参
void print(const int*);
void print(const int[]); // 可以看出来，函数的意图是作用于一个数组
void print(const int[10]); // 这里的维度表示我们期望数组含有多少元素，实际不一定
```

> Warning! 和其他使用数组的代码一样，以数组为形参的函数也必须确保使用数组时不会越界。

#### 使用标记指定数组长度

管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。

```C++
void print(const char *cp) {
  if(cp){  // 若cp不是一个空指针
    while(*cp){ // 只要指针所指的字符不是空字符
      cout << *cp++;
    }
  }
}
```

#### 使用标准库规范

管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库的启发。

```C++
void print (const int *beg, const int *end) {
  while(beg != end) {
    cout << *beg++;
  }
}
```

#### 显示传递一个表示数组大小的形参

第三种管理数组实参的方法是专门定义一个表示数组大小的形参。

```C++
// const int ia[] 等价于const int *ia
// size 表示数组的大小
void print(const int ia[],size_t size) {
  for (size_t i = 0; i < size; ++i) {
    cout << ia[i];
  }
}
```

#### 数组形参和const

三个print函数都把数组形参定义成了指向const的指针。当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。

#### 数组引用形参

形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上。

```C++
// 正确： 形参是数组的引用，维度是类型的一部分
void print(int (&arr)[10]) {
  for (auto elem : arr) 
    cout << elem;
}
```

> **&arr 两端的括号必不可少**
>
> **f(int &arr[10])  // 错误： 将arr声明成了引用的数组**
>
> **f(int (&arr)[10])  //正确： arr是具有10个整数的整型数组的引用**

但是，这一用法也无形中限制了print函数的可用性，我们只能将函数作用于大小为10的数组。

#### 传递多维数组

```C++
void print(int (*matrix)[10], int rowSize) {}
// 上述语句将 matrix 声明成指向含有10个整数的数组的指针
```

> Note!
>
> **\*matrix 两端的括号必不可少：**
>
> **int *matrix[10]; // 10个指针构成的数组**
>
> **int (*matrix)[10]; // 指向含有10个整数的数组的指针**

```C++
void print(int matrix[][10], int rowSize) {}
```

matrix 的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。

### 6.2.5 main: 处理命令行选项

```C++
int main(int argc, char *argv[]) {}
```

第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。

当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

```C++
// 当命令行输入
prog -d -o ofile data0
// argv 应该包含如下的C风格字符串：
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

**当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入。**

#### 6.2.6 含有可变形参的函数

#### initializer_list 形参

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。

![](https://cdn.pkubailu.cn/img/6.1.png)

和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型：

```C++
initializer_list<string> ls; // initializer_list 的元素类型是string
initializer_list<int> li; // initializer_list的元素类型是int
```

和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法修改其中的值。

```C++
void error_msg(initializer_list<string> ls) {
  for (auto beg = ls.begin(); beg != ls.end(); ++beg)
    cout << *beg << endl;
}
// 想向initializer_list形参中传递一个值序列，则必须把序列放在一对花括号内
// expected和actual是string对象
if (expected != actual)
  error_msg({"functionX", expected, actual});
else
  error_msg({"functionX", "okay"})
```

#### 省略符形参

**省略符形参应该仅仅用于C和C++通用的类型。特别注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝**

省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：

```C++
void foo(parm_list,...);
void foo(...);
```

第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参无需类型检查。

### 6.3.2 有返回值函数

#### 不要返回局部对象的引用或指针

函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域：

```C++
const string &manip() {
  string ret;
  if (!ret.empty())
    return ret;  // 错误：返回局部对象的引用！
  else 
    return "Empty"; // 错误： "Empty"是一个局部临时变量
}
```

第一条return 语句来说，显然它返回的是局部对象的引用。

第二条return 语句中，字符串字面值转换成一个局部临时string对象，该对象和ret一样都是局部的。

### 6.3.3 返回数组指针

#### 声明一个返回数组指针的函数

```C++
int arr[10]; //arr 是一个含有10个整数的数组
int *p1[10]; // p1是一个含有10个指针的数组
int (*p1)[10]; // p2 是一个指针，它指向含有10个整数的数组
```

和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：

```c++
Type (*function(parameter_list))[dimension]
// (*function(parameter_list))两端的括号必须存在。
```

具体的例子：

```C++
int (*func(int i))[10];
```

可以按照以下的顺序来逐层理解该声明的含义：

- func(int i) 表示调用func函数时需要一个int类型的实参。
- (*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作
- (*func(int i))[10] 表示解引用func的调用将得到一个大小为10的数组
- int (*func(int i))[10] 表示数组中的元素是int类型

#### 使用尾置返回类型

简化上述func声明的方法，还可以使用**尾置返回类型**。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto:

```C++
// func 接受一个int 类型的实参，返回一个指针，该指针指向含有10个整数的数组
auto func(int i) -> int(*)[10];
```

因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。 

#### 使用 decltype

如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。

```C++
int odd[] = {1,3,5,7,9};
int event[] = {0,2,4,6,8};
// 返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i){
  return (i % 2) ? &odd : &even; //返回一个指向数组的指针
}
```

因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回值真还必须在函数声明时加一个*符号。

## 6.4 函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为**重载函数**。

#### 定义重载函数

对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。

#### 判断两个形参的类型是否相异

有时候两个形参列表看起来不一样，但实际上是相同的：

```C++
// 声明的是同一个函数
Record lookup(const Account &acct);
Record lookup(const Account &);  // 省略了形参的名字
```

#### 重载和const形参

顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：

```C++
Record lookup(Phone);
Record lookup(const Phone); 

Record lookup(Phone*);
Record lookup(Phone* const);
```

另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：

```C++
// 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同
// 定义了4个独立的重载函数
Record lookup(Account &); // 函数作用于Account的引用
Record lookup(Account &); // 新函数，作用于常量引用

Record lookup(Account *); // 新函数，作用于指向Account的指针
Record lookup(const Account *); // 新函数，作用于指向常量的指针
```

#### const_cast 和 重载

const_cast 在重载函数的情景中最有用。举个例子：

```C++
// 比较两个string对象的长度，返回较短的那个引用
const string &shorterString(const string &s1, const string &s2){
  return s1.size() <= s2.size() ? s1 : s2;
}
```

这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string 的引用。因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点：

```C++
string &shorterString(string &s1, string &s2){
  auto &r = shorterString(const_cast<const string&>(s1),const_cast<const string&>(s2));
  return const_cast<string&>r;
}
```

在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string&，这显然是安全的。

#### 调用重载的函数

调用重载函数时有三种可能的结果：

- 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
- 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。
- 有多余一个函数可以匹配，但是没一个都不是最明显的最佳选择。此时也将发生错误，成为二义性调用。

### 6.4.1 重载与作用域

重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。

> Note! 在C++语言中，名字查找发生在类型检查之前。

## 6.5 特殊用途语言特性

### 6.5.1 默认实参

我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值。

```C++
typedef string::size_type sz; 
string screen(sz ht = 24, sz wid = 80, char background = ' ');
```

函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参，例如：要想覆盖background的默认值，必须为ht何wid提供实参：

```C++
window = screen(,,'?'); // 错误：只能省略尾部的实参
window = screen('?'); // 调用screen('?',80,' ')
```

当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。

#### 默认实参声明

一个函数通常只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值得形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

```C++
string screen(sz,sz,char = '');
string screen(sz,sz,char = '*'); // 错误：重复声明
// 但是可以按照如下形式添加默认实参：
string screen(sz = 24, sz = 80, char); //正确：添加默认实参
```

#### 默认实参初始值

局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：

```C++
// wd、def、ht的声明必须出现在函数之外
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);
string window = screen(); //调用 screen(ht(),80,' ')
```

用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：

```C++
void f2(){
  def = '*'; // 改变默认实参的值
  sz wd = 100; // 隐藏了外层定义的wd，但是没有改变默认值
  window = screen(); // 调用了screen(ht(),80,'*');
}
```

### 6.5.2 内联函数和 constexpr 函数

#### 内联函数可避免函数调用的开销

将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。

假设我们把shorterString函数定义成内联函数，则如下调用

```C++
cout << shorterString(s1,s2) << endl;
```

将在编译过程中展开成类似下面的形式

```C++
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
```

从而消除了shorterString函数的运行时开销。

在shorterString函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了:

```C++
inline const string &
shorterString(const string &s1, const string &s2){
  return s1.size() < s2.size() ? s1 : s2; 
}
```

一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。

#### constexpr 函数

constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：

```C++
constexpr int new_sz() {return 42;}
constexpr int foo = new_sz(); // 正确： foo是一个常量表达式
```

执行该初始化任务时，编译器把对constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐士地指定为内联函数。

我们允许constexpr函数的返回值并非一个常量：

```C++
// 如果arg是常量表达式，则scale(arg)也是常量表达式
constexpr size_t scale(size_t cnt) {return new_sze() * cnt; }
// 当scale的实参实参是常量表达式时，它的返回值也是常量表达式：反之则不然：
int arr[scale(2)]; // 正确： scale(2)是常量表达式
int i = 2; // i 不是常量表达式
int a2[scale(i)] // 错误：scale(i)不是常量表达式
```

> Note! constexpr 函数不一定返回常量表达式

#### 把内联函数和constexpr 函数放在头文件内

对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。

### 6.5.3 调试帮助

#### assert 预处理宏

assert是一种预处理宏。所谓预处理宏其实是一个预处理变量，他的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：

```C++
assert(expr);
```

首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。

和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件的程序不能再定义名为assert的变量、函数或者其他实体。在实际编译过程中，即使我们没有包含cassert头文件，也最好不要为了其他目的使用assert。很多头文件都包含了cassert，这就意味着即使你没有直接包含cassert，它也很有可能通过其他途径包含在你的程序中。

```C++
// assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时，程序可以包含一条如下所示的语句：
assert(word.size() > threshold)；
```

#### NDEBUG预处理变量

assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。

我们可以使用一个#define 语句定义NDEBUG，从而关闭调试状态。

除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码：如果定义了NDEBUG，这些代码将被忽略。

## 6.6 函数匹配

#### 确定候选函数和可行函数

1. 选定本次调用对应的重载函数集。
2. 考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数。
3. 从候选函数中选择与本次调用最匹配的函数。

#### 寻找最佳匹配（如果有的话）

基本思想是：实参类型与形参类型越接近，他们匹配的越好。

> Note! 调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

### 6.6.1 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级。

1. 精确匹配，包括以下情况：
   - 实参类型和形参类型相同。
   - 实参从数组类型或函数类型转换成对应的指针类型。
   - 向实参添加顶层const或者从实参中删除顶层const。
2. 通过const转换实现的匹配。
3. 通过类型提升实现的匹配。
4. 通过算术类型转换或指针转换实现的匹配。
5. 通过类类型转换实现的匹配。

#### 函数匹配和const实参

```C++
Record lookup(Account&);
Record lookup(const Account&);
const Account a;
Account b;

lookup(a); // 调用lookup(const Account&)
lookup(b); // 调用lookup(Account&)
```

在第一个调用中，我们传入的是const 对象a。因为不能把普通引用绑定到const对象上，所以此例中唯一可行的函数是以常量引用作为形参的那个函数。

在第二个调用中，两个函数都是可行的，因为我们既可以使用b初始化常量引用也可以用它初始化非常量引用。然而，用非常量对象初始化常量引用需要类型转换。

指针也同样如此！

## 6.7 函数指针

函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参共同决定，与函数名无关。

```C++
// 比较两个string对象的长度
bool lengthCompare(const string &,const string &);
```

该函数的类型是bool（const string&, const string&）。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：

```C++
// pf 指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型
bool (*pf) (const string &,const string &); // 未初始化
```

从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。

> Note! *pf 两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数。

#### 使用函数指针

当我们把函数名作为一个值使用时，该函数自动的转换成指针。例如，按照如下形式我们可以将lengthCompare的地址赋给pf：

```C++
pf = lengthCompare; // pf 指向名为lengthCompare的函数
pf = &lengthCompare; // 等价的赋值语句：取地址符是可选的
```

此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针：

```C++
bool b1 = pf("hello","goodbye"); // 调用lengthCompare函数
bool b2 = (*pf)("hello","goodbye"); // 一个等价的调用
bool b3 = lengthCompare("hello","goodbye"); // 另一个等价的调用
```

在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个函数。

```C++
string::size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0; // 正确：pf不指向任何函数
pf = sumlength; // 错误：返回类型不匹配
pf = cstringCompare; // 错误：形参类型不匹配
pf = lengthCompare; // 正确：函数和指针的类型精确匹配
```

#### 重载函数的指针

当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。如果定义了指向重载函数的指针

```C++
void ff(int*);
void ff(unsigned int);

void (*pf1)(unsigned int) = ff; // pf1 指向 ff(unsigned)
```

编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配

```C++
void (*pf2)(int) = ff; // 错误：没有任何一个ff与该形参列表匹配
double (*pf3)(int*) = ff; // 错误： 返回类型不匹配
```

#### 函数指针形参

和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用：

```C++
// 第三个形参是函数类型，它会自动地转换成指向函数的指针
void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));
// 等价的声明：显示的将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &)); 
// 我们可以直接把函数作为实参使用，此时它会自动转换成指针：
useBigger(s1,s2,lengthCompare);
```

正如useBigger的声明语句所示，直接使用函数指针类型显得冗余而繁琐。类型别名和decltype能让我们简化使用了函数指针的代码：

```C++
没有看懂！！！ P222页
```

#### 返回指向函数的指针

和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而， 我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要向声明一个返回函数指针的函数，最简单的办法是使用类型别名：

```C++
using F = int(int*, int); // F是函数类型，不是指针
using PF = int(*)(int*, int); // PF是指针类型
```

必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显示的将返回类型指定为指针：

```C++
PF f1(int); // 正确： PF 是指向函数的指针，f1返回指向函数的指针
F f1(int); // 错误：F是函数类型，f1不能返回一个函数
F *f1(int); // 正确：显示的指定返回类型是指向函数的指针
```

当然，我们也能用下面的形式直接声明f1:

```C++
int (*f1(int))(int*, int);
// 按照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表，所以f1是一个函数：f1前面有*，所以f1返回一个指针，进一步观察发现，指针的类型本身也含有形参列表，因此指针指向函数，该函数的返回类型是int
```

我们还可以使用尾置返回类型的方式

```C++
auto f1(int) -> int (*)(int*, int);
```

#### 将auto和decltype用于函数指针类型

如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。

```C++
string::size_type sumLength(const string&, const string&);
string::size_type largeLength(const string&, const string&);
// 根据其形参的取值，getFcn函数返回指向 sumLength 或者 largeLength的指针
decltype(sumLength) *getFcn(const string &);
```

声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们需要显示的加上*以表明我们需要返回指针。

# 第7章 类

## 7.1 定义抽象数据类型

### 7.1.2 定义改进的 Sales_data 类

定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，例如add、read和print等，它们的定义和声明都在类的外部。

```C++
// 改进的Sales_data类如下所示
struct Sales_data {
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
// Sales_data的非成员接口函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```

> 定义在类内部的函数是隐式的inline函数

#### 定义成员函数

尽管所有成员都必须在类的内部声明，但是成员函数可以定义在类内也可以定义在类外。对于Sales_data类来说，isbn函数定义在了类内，而combine和avg_price定义在了类外。

```C++
std::string isbn() const { return bookNo; }
```

isbn函数是如何获得bookNo成员所依赖的对象的呢？

#### 引入this

```C++
// 调用isbn函数
total.isbn()
```

当我们调用成员函数时，实际上是在替某个对象调用它。如果isbn指向Sales_data的成员(例如bookNo)，则它隐式地指向调用该函数的对象的成员。

成员函数通过一个名为**this**的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。

```C++
total.isbn()
// 编译器负责把total的地址传递给isbn的隐士形参this，可以认为编译器将该调用重写成了如下的形式
Sales_data::isbn(&total)
```

任何对类成员的直接访问都被看作this的隐式调用，也就是说，当isbn使用bookNo时，它隐式的使用this指向的成员，就像我们书写了this->bookNo一样。

对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或变量的行为都是非法的。我们可以在成员函数体内部使用this，因此尽管没有必要，但我们还是能把isbn定义成如下的形式：

```C++
std::string isbn() const { return this->bookNo; }
```

因为this的目的总是指向“这个”对象，所以this是一个常量指针，我们不允许改变this中保存的地址。

#### 引入const 成员函数

isbn函数的另一个关键之处是紧随参数列表之后的const关键字，这里，const的作用是修改隐式this指针的类型。

默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this的类型是Sales_data *const。尽管this是隐士地，但它仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。

如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn的函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。

所以，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为**常量成员函数**。

因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。

#### 类作用域和成员函数

编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体内可以随意使用类中的其他成员而无须在意这些成员出现的次序。

#### 在类的外部定义成员函数

如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员名字必须包含它所属的类名。

#### 定义一个返回this对象的函数

```C++
Sales_data& Sales_data::combine(const Sales_data &rhs){
  units_sold += rhs.units_sold; // 把rhs成员加到this对象的成员上
  revenue += rhs.revenue;
  return *this; // 返回调用该函数的对象
  // return语句解引用this指针以获得执行该函数的对象，换句话说，上面的这个调用返回total的引用
}
```

### 7.1.3 定义类相关的非成员函数

类的作者常常需要定义一些辅助函数，比如add、read、和print等。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。

我们定义非成员函数的方式与定义其它函数一样，通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。

### 7.1.4 构造函数

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

构造函数的名字和类名相同。和其他函数不一样的是，**构造函数没有返回类型**；类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。

不同于其他成员函数，**构造函数不能被声明成const的**。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。

#### 合成的默认构造函数

类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数**。默认构造函数无须任何实参。

如果我们的类没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。

编译器创建的构造函数又被称为**合成的默认构造函数**。其初始化类的数据成员的规则如下：

- 如果存在类内的初始值，用它来初始化成员。
- 否则，默认初始化该成员。

因为Sales_data为units_sold和revenue提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员；同时，它把bookNo默认初始化成一个空字符串。

#### 某些类不能依赖于合成的默认构造函数

合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：

1. 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。
2. 对于某些类来说，合成的默认构造函数可能执行错误的操作。回忆我们之前介绍过的，如果定义在块中的内置类型或复合类型的对象被默认初始化，则他们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。
3. 有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。

#### 定义Sales_data的构造函数

```C++
struct Sales_data {
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) {}
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  Sales_data(std::istream &);
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
```

#### =default的含义

```C++
Sales_data() = default;
```

因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。我们希望这个函数的作用完全等同于之前使用的合成默认构造函数。

#### 构造函数初始值列表

```C++
Sales_data(const std::string &s): bookNo(s) {}
Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
```

花括号定义了（空的）函数体。

冒号和花括号之间的部分称为**构造函数初始值列表**，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。

只有一个string类型参数的构造函数使用这个string对象初始化bookNo，对于units_sold和revenue则没有显示的初始化。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。在此例中，这样的成员使用类内初始值初始化。等价于

```C++
Sales_data(const std::string &s): bookNo(s), units_sold(0), revenue(0) {}
```

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显示的初始化每个内置类型的成员。

#### 在类的外部定义构造函数

```C++
Sales_data::Sales_data(std::istream &is) {
  read(is, *this); // 从is中读取一条交易记录然后存入this对象中
}
```

没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。

### 7.1.5 拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。

如果我们不主动定义这些操作，则编译器将替我们合成他们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。

#### 某些类不能依赖于合成的版本

对于某些类来说，合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。管理动态内存的类通常不能依赖与上述操作的合成版本。

## 7.2 访问控制与封装

目前为止，我们的类还没有封装。在C++语言中，我们使用**访问说明符**加强类的封装性：

- 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。
- 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装（即隐藏了）类的实现细节。

````C++
// 再一次定义Sales_data类，其新形式如下所示：
class Sales_data {
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) {}
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  Sales_data(std::istream &);
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
private:
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
````

一个类包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。

#### 使用class或struct关键字

使用class和struct定义类的唯一区别是，struct和class的默认访问权限不太一样。

类可以在他的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。

> 使用class和struct定义类唯一的区别就是默认的访问权限。

### 7.2.1 友元

既然Sales_data的数据成员是private的，我们的read、print和add函数也就无法正常编译了，这是因为尽管这几个函数是类的接口的一部分，但他们不是类的成员。

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的**友元**。如果类想把一个函数成为它的友元，只需要增加一条friend关键字开始的函数声明语句即可：

```C++
class Sales_data{
  friend Sales_data add(const Sales_data&， const Sales_data&);
  friend std::istream &read(std::istream&, Sales_data&);
  ...
}
```

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。

#### 友元的声明

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。

为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中。

> 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。

最好为友元函数提供一个独立的函数声明，这样即使更换了一个有强制要求的编译器，也不必改编代码。

## 7.3 类的其他特性

### 7.3.1 类成员再探

#### 定义一个类型成员

除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种：

```C++
class Screen {
public:
  typedef std::string::size_type pos;
private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
}
```

Screen 的用户不应该知道 Screen 使用了一个string对象来存放它的数据，因此通过把pos定义成public成员可以隐藏Screen实现细节。

**用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别**。因此，类型成员通常出现在类开始的地方。

#### Screen类的成员函数

```C++
class Screen {
public:
  typedef std::string::size_type pos;
  Screen() = default;
  Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht*wd, c) {}
  char get() const { return contents[cursor]; } // 读取光标处的字符 隐士内联函数
  inline char get(pos ht, pos wd) const; // 显式内联
  Screen &move(pos r, pos c); // 能在之后被设为内联
private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
}
```

第二个构造函数（接收三个参数）为cursor成员隐式地使用了类内初始值。如果类中不存在cursor的初始值，我们就需要像其他成员一样显示的初始化cursor了。

#### 令成员作为内联函数

定义在类内部的成员函数是自动inline的。因此，Screen的构造函数和返回光标所指字符的get函数默认是inline函数。

我们可以在类的内部把inline作为声明的一部分显式的声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：

```C++
inline
Screen &Screen::move (pos r, pos c) {
  pos row = r * width;
  cursor = row + c;
  return *this;
}
```

#### 重载成员函数

和非成员函数一样，成员函数也可以被重载，只要在函数之间的参数的数量或类型上有所区别就行。

#### 可变数据成员

有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。

一个**可变数据成员**永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。举个例子：

```C++
class Screen {
public:
  void some_member() const;
private:
	mutable size_t access_ctr; // 即使在一个const对象内也能被修改  
};
void Screen::some_member() const {
  ++access_ctr; 
}
```

尽管some_member是一个const成员函数，它仍然能够改变access_ctr的值。该成员是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值。

#### 类数据成员的初始值

定义好Screen类之后，我们将继续定义一个窗口类并用它表示显示器上的一组Screen。

```C++
class Window_mgr {
private:
  // 这个Window_mgr追踪的Screen
  // 默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen
  std::vector<Screen> screens{Screen(24,80,'')};
}
```

当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。在此例中，我们使用一个单独的元素值对vector成员执行了列表初始化。

如我们之前所知的，类内初始值必须使用=的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。

> 当我们提供一个类内初始值时，必须以符号=或者花括号表示。

### 7.3.2 返回*this的成员函数

接下来我们继续添加一些函数，他们负责设置光标所在位置的字符或者其他任一给定位置的字符：

```C++
class Screen {
public:
  Screen &set(char);
  Screen &set(pos, pos, char);
}
inline Scrren &Scrren::set(char c) {
  contents[cursor] = c; // 设置当前光标所在位置的新值
  return *this; // 将this对象作为左值返回
}
inline Scrren &Scrren::set(pos r, pos c, char c) {
  contents[r*width + col] = c; // 设置当前光标所在位置的新值
  return *this; // 将this对象作为左值返回
}
```

set成员的返回值是调用set的对象的引用。返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。

如果我们令move和set返回Screen而非Screen&，则下述语句的行为将大不相同。

```C++
// 如果move返回Screen而非Screen&
Screen temp = myScreen.move(4,0); // 对返回值进行拷贝
temp.set('#'); // 不会改变myScreen的contents
```

假如我们定义的返回类型不是引用，则move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变myScreen的值。

#### 从const成员函数返回*this

从逻辑上来说，显示一个Screen并不需要改变它的内容，因此我们令display为一个const成员，此时，this将是一个指向const的指针而*this是const对象。由此推断，display的返回类型应该是const Sales_data&。然而，如果真的令display返回一个const的引用，则我们将不能把display嵌入到一组动作序列中去：

```C++
Screen myScreen;
// 如果display 返回常量引用，则调用set将引发错误
myScreen.display(cout).set('#');
```

即使myScreen是个非常量对象，对set的调用也无法通过编译。问题在于display的const版本返回的是常量引用，而我们显然无权set一个常量对象。

> 一个const成员函数如果以引用的形式返回*this，那么他的返回类型将是常量引用。

#### 基于const的重载

通过区分成员函数是否是const的，我们可以对其进行重载。

因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。

```C++
class Screen {
public:
  // 根据对象是否是const 重载了display函数
  Screen &display(std::ostream &os) 
  { do_display(os); return *this; }
  const Screen &display(std::ostream &os) const 
  { do_display(os); return *this; }
private:
  // 该函数负责显示Screen的内容
  void do_display(std::ostream &os) const 
  { os << contents; }
};
```

当do_display完成后，display函数各自返回解引用this所得的对象。在非常量版本中，this指向一个非常量对象，因此display返回一个普通的（非常量）引用；而const成员则返回一个常量引用。

当我们在某个对象上调用display时，该对象是否是const决定了应该调用display的哪个版本。

### 7.3.3 类类型

每个类定义了唯一的类型。对于两个类来说，即使他们的成员完全一样，这两个类也是两个不同的类型。

我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面：

```C++
Sales_data item1;
class Sales_data item1;
// 两条声明完全等价
```

#### 类的声明

就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它。

这种声明被称为**前向声明**，他向程序中引入了类的名字（Screen）并且指明Screen是一种类类型，对于类型Screen来说，在它声明之后定义之前是一个**不完全类型**。

不完全类型只能在非常有限的情境下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。

### 7.3.4 友元再探

类可以把普通的非成员函数定义成友元。类还可以把其他的类定义成友元，也可以把其他类的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。

#### 类之间的友元关系

我们的Window_mgr类的某些成员可能需要访问它管理的Screen类的内部数据。例如：Window_mgr类中的函数clear需要访问Screen的私有成员；要想令这种访问合法，Screen需要把Window_mgr指定成它的友元：

```C++
class Screen {
  // Window_mgr 的成员可以访问Screen类的私有部分
  friend class Window_mgr;
}
```

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非共有成员在内的所有成员。

```C++
class Window_mgr {
public:
  using ScreenIndex = std::vector<Screen>::size_type;
  void clear(ScreenIndex);
private:
  std::vector<Screen> screens{Screen(24, 80 ,'')};
}
void Window_mgr::clear(ScreenIndex) {
  Screen &s = screens[ScreenIndex];
  s.contents = string(s.ht * s.wd, '');
}
```

如果clear不是Screen的友元，上面的代码将无法通过编译，因为此时clear将不能访问Screen的成员。

必须要注意的一点是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元不能理所当然地具有访问Screen的特权。

#### 令成员函数作为友元

除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：

```C++
class Screen {
  // Windoew_mgr::clear 必须在Screen类之前被声明
  friend void Windoew_mgr::clear(ScreenIndex);
  ....
}
```

要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：

- 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。
- 接下来定义Screen，包括对于clear的友元声明。
- 最后定义clear，此时它才可以使用Screen的成员。

#### 函数重载和友元

尽管重载函数的名字相同，但它们仍然是不同的函数，因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

#### 友元声明和作用域

类和非成员函数的声明不是必须在他们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。

甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：

```C++
struct X {
  friend void f() {/* 友元函数可以定义在类的内部 */}
  X() { f(); } // 错误：f还没有被声明
  void g();
  void h();
};
void X::g() {return f();} // 错误：f还没有被声明
void f(); // 声明那个定义在X中的函数
void X::h() { return f(); } // 正确：现在f的声明在作用域中了
```

关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。

## 7.4 类的作用域

每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。

#### 作用域和定义在类外部的成员

一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了。

另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。

```C++
// 例如
class Window_mgr {
public:
  // 向窗口添加一个Screen,返回它的编号
  ScreenIndex addScreen(const Screen&);
};
// 首先处理返回类型，之后我们才进入Window_mgr的作用域
Window_mgr::ScreenIndex
Window_mgr::addScreen(const Screen& s) {
  screens.push_back(s);
  return screens.size() - 1;
}
```

因为返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的。

### 7.4.1 名字查找与类的作用域

在目前为止，我们编写的程序中，**名字查找**（寻找与所用名字最匹配的声明的过程）的过程比较直截了当：

- 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。
- 如果没找到，继续查找外层作用域。
- 如果最终没有找到匹配的声明，则程序报错。

对于定义在类内部的成员函数来说，解析其中的名字的方式与上述的查找规则有所区别。类的定义分两步处理：

- 首先，编译成员的声明。
- 直到类全部可见后才编译函数体。

> 编译器处理完类中的全部声明后才会处理成员函数的定义。

#### 用于类成员声明的名字查找

这种两阶段的处理方式只适用于成员函数体中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。

```C++
typedef double Money;
string bal;
class Account {
public:
  Money balance() { return bal; }
private:
  Money bal;
  // .....
};
```

当编译器看到balance函数的声明语句时，他将在Account类的范围内寻找对Money的声明。编译器只考虑Account中在使用Money前出现的声明，因为没找到匹配的成员，所以编译器会接着到Account的外层作用域中查找。另一方面，balance函数体在整个类可见后才被处理，因此，该函数的return语句返回名为bal的成员，而非外层作用域的string对象。

#### 类型名要特殊处理

一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字：

```C++
typedef double Money;
class Account {
public:
  Money balance() { return bal; } // 使用外层作用域中的名字
private:
  typedef double Money; // 错误：不能重新定义Money
  Money bal;
  // .....
};
```

需要特别注意的是，即使Account中定义的Money类型与外层作用域一致，上述代码仍然是错误的。

> 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

#### 成员定义中的普通块作用域的名字查找

成员函数中使用的名字按照如下方式解析：

- 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。
- 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。
- 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。

一般来说不建议使用其他成员的名字作为某个成员函数的参数。

```C++
// 通常情况下不建议为参数和成员使用同样的名字
int height;
class Screen {
public:
  typedef std::string::size_type pos;
  void dummy_fcn(pos height) {
    cursor = width * height; // 哪个height?
  }
private:
  pos cursor = 0;
  pos height = 0, width = 0;
};
```

当编译器处理dummy_fcn中的乘法表达式时，他首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此dummy_fcn函数体内用到的名字height指的是参数声明。

在上述代码中，height参数隐藏了同名的成员。如果想绕开上面的查找规则应该将代码变为：

```C++
void Screen::dummy_fcn(pos height) {
  cursor = width * this->height; // 成员height
  cursor = width * Screen::height; // 成员height
}
```

> 尽管类的成员被隐藏了，但我们任然可通过加上类的名字或显示的使用this指针来强制访问成员。

#### 类作用域之后，在外围的作用域中查找

如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。

如果，我们需要的是外层作用域中的名字，可以显示的通过作用域运算符来进行请求：

```C++
void Screen::dummy_fcn(pos height) {
  cursor = width * ::height // 哪个height?是那个全局的
}
```

#### 在文件中名字的出现处对其进行解析

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。

```C++
int height;
class Screen {
public:
  typedef std::string::size_type pos;
  void setHeight(pos);
  pos height = 0; // 隐藏了外层作用域中的height
};
Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var) {
  // var: 参数
  // height: 类的成员
  // verify: 全局函数
  height = verify(var);
}
```

注意：全局函数verify的声明在Screen类的定义之前是不可见的。然后，名字查找的第三步包括了成员函数出现之前的全局作用域。

## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

如果没有在构造函数的初始值列表中显示的初始化成员，则该成员将在构造函数体之前执行默认初始化。

```C++
Sales_data::Sales_data(const string &s, unsigned cnt, double price) {
  bookNo = s;
  units_sold = cnt;
  revenue = cnt * price;
}
```

原来的版本（构造函数初始化版本）初始化了它的数据成员，而这个版本是对数据成员执行了赋值操作。

#### 构造函数的初始值有时必不可少

有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

```C++
class ConstRef {
public:
  ConstRef(int ii);
private:
  int i;
  const int ci;
  int &ri;
};
```

和其他常量对象或者引用一样，成员ci和ri都必须初始化。

```C++
ConstRef::constRef(int ii){
  i = ii; // 正确
  ci = ii; // 错误： 不能给const赋值
  ri = i; // 错误：ri没被初始化
}
```

随着构造函数体一开始执行，初始化就完成了。我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此构造函数的正确形式应该是：

```C++
// 正确：显示的初始化引用和const成员
ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) {}
```

> Note! 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。

#### 成员初始化的顺序

构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。

成员的初始化顺序与他们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。

> 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。

#### 默认实参和构造函数

```C++
class Sales_data {
public:
  Sales_data(std::string s = ""): bookNo(s) {}
  // ...
}
```

在上面这段程序中，当没有给定实参，或者给定了一个string实参时，两个版本的类创建了相同的对象。因为我们不提供实参也能调用上述的构造函数，所以该构造函数实际上为我们的类提供了默认构造函数。

> 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

### 7.5.2 委托构造函数

C++新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的**委托构造函数**。一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其它构造函数。

在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。

```C++
class Sales_data {
public:
  // 非委托构造函数
  Sales_data(std::string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), revenue(cnt*price) {}
  // 其余构造函数全部委托给另一个构造函数
  Sales_data(): Sales_data("", 0, 0) {}
  Sales_data(std::string s): Sales_data(s, 0, 0) {}
  Sales_data(std::istream &is): Sales_data() { read(is, *this); }
}
```

除了第一个，其他三个构造函数全部委托第一个构造函数完成初始化。

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，执行完后控制权才会交还给委托者的函数体。

### 7.5.3 默认构造函数的作用

当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生：

- 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时。
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
- 当类类型的成员没有在构造函数初始值列表中显示的初始化时。

值初始化在以下情况下发生：

- 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。
- 当我们不使用初始值定义一个局部静态变量时。
- 当我们通过书写形如T()的表达式显示的请求值初始化时，其中T()是类型名（vector的一个构造函数只接受一个实参用于说明vector大小，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。

类必须包含一个默认构造函数以便在上述情况下使用。

> 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。

### 7.5.4 隐式的类类型转换

我们也能为类定义隐式转换规则。如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐士转换机制，有时我们把这种构造函数称作**转换构造函数**。

> 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。

在Sales_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这两种类型向Sales_data隐式转换的规则。也就是说，在需要使用Sales_data的地方，我们可以使用string或者istream作为替代：

```C++
string null_book = "9-999-9999-9";
// 构造一个临时的Sales_data对象
// 该对象的units_sold和revenue等于0,bookNo等于null_book
item.combine(null_book);
```

这里我们用一个string实参调用了Sales_data的combine成员。该调用是合法的，编译器用给定的string自动创建了一个Sales_data对象。新生成的这个（临时）Sales_data对象被传递给combine。因为combine的参数是一个常量引用，所以我们可以给该参数传递一个临时变量。

#### 只允许一步类类型转换

编译器只会自动的执行一步类类型转换。

```C++
// 因为下面的代码隐式的使用了两种转换规则，所以他是错误的
item.combine("9-99-999");
```

#### 抑制构造函数定义的隐式转换

在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为**explicit**加以阻止：

```C++
class Sales_data {
public:
  Sales_data() = default;
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  explicit Sales_data(const std::string &s): bookNo(s) {}
  explicit Sales_data(std::istream&);
};
```

此时，没有任何构造函数能用于隐式地创建Sales_data对象，之前的两种用法都无法通过编译。

```C++
item.combine(null_book); // 错误：string构造函数是explicit的
item.combine(cin); // 错误：istream构造函数是explicit的
```

关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复：

```C++
explicit Sales_data::Sales_data(istream &is) {
  read(is, *this);
}
```

#### explicit 构造函数只能用于直接初始化

发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=）此时，我们只能使用直接初始化而不能使用explicit构造函数：

```C++
Sales_data item1(null_book); // 正确：直接初始化
// 错误：不能将explicit构造函数用于拷贝形式的初始化过程
Sales_data item2 = null_book;
```

> 当我们使用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。

#### 为转换显示地使用构造函数

尽管编译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显示的强制进行转换：

```C++
// 正确： 实参是一个显示构造的Sales_data对象
item.combine(Sales_data(null_book));
// 正确： static_cast可以使用explicit的构造函数
item.combine(static_cast<Sales_data>(cin));
```

#### 标准库中含有显示构造函数的类

我们用过的一些标准库中的类含有单参数的构造函数：

- 接受一个单参数的const char*的string构造函数不是explicit的。
- 接受一个容量参数的vector构造函数是explicit的。

### 7.5.5 聚合类

**聚合类**使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：

- 所有成员都是public的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类，也没有virtual函数。

```C++
// 这是一个聚合类
struct Data {
  int ival;
  string s;
};
```

我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员：

```c++
// val1.ival = 0; val1.s = string("Anna")
Data val1 = {0, "Anna"};
```

初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。

与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。

值得注意的是，显示的初始化类的对象的成员存在三个明显的缺点：

- 要求类的所有成员都是public的
- 将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。
- 添加或删除一个成员之后，所有的初始化语句都需要更新。

### 7.5.6 字面值常量类

constexpr 函数的参数和返回值必须是字面值类型。和其他类不同，字面值类型的类可能含有constexpr函数成员。

数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合以下要求，则它也是一个字面值常量类：

- 数据成员都必须是字面值类型。
- 类必须至少含有一个constexpr构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

#### constexpr 构造函数

尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。

constexpr构造函数可以声明成=default的形式。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句）。综合这两点可知，constexpr构造函数体一般来说应该是空的。

```C++
class Debug {
public:
  constexpr Debug(bool b = true): hw(b), io(b), other(b) {}
  constexpr Debug(bool h, bool i, bool o): hw(h), io(i), other(o) {}
  constexpr bool any() { return hw || io || other; }
  void set_io(bool b) { io = b; }
  void set_hw(bool b) { hw = b; }
  void set_other(bool b) { other = b; }
 
private:
  bool hw;
  bool io;
  bool other;
};
```

constexpr 构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。

constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型。

## 7.6 类的静态成员

有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。

#### 声明静态成员

我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态成员的类型可以是常量、引用、指针、类类型等。

```C++
class Account {
public:
  void calculate() { amount += amount * interestRate; }
  static double rate() { return interestRate; }
  static void rate(double);
private:
  std::string owner;
  double amount;
  static double interestRate;
  static double initRate();
};
```

类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。

类似的，静态成员函数也不与任何对象绑定在一起，他们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。这一限制既适用于this的显示使用，也对调用非静态成员的隐式使用有效。

#### 使用类的静态成员

我们使用作用域运算符直接访问静态成员：

```C++
double r;
r = Account::rate(); 
```

虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员：

```C++
Account ac1;
Account *ac2 = &ac1;
r = ac1.rate();
r = ac2->rate();
```

成员函数不用通过作用域运算符就能直接使用静态成员：

```C++
class Account {
public:
  void calculate() { amount += amount * interestRate; }
private:
  static double interestRate;
}
```

#### 定义静态成员

和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句：

> 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。

因为静态数据成员不属于类的任何一个对象，所以他们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。

类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。

我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：

```C++
double Account::interestRate = initRate();
```

这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以访问类Account中的所有成员。

#### 静态成员的类内初始化

通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以他们能用在所有适合于常量表达式的地方。

```C++
class Account {
public:
  static double rate() { return interestRate; }
  static void rate(double);
private:
  static constexpr int period = 30;
  double daily_tbl[period];
};
```

如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须有一条定义语句。

例如：如果period的唯一用途就是定义daily_tbl的维度，则不需要在Account外面专门定义period。此时，如果我们忽略了这条定义，那么对程序非常微小的改动也可能造成编译错误，因为程序找不到该成员的定义语句。举个例子，当需要把Account::period传递给一个接受const int&的函数时，必须定义period。

如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了：

```C++
constexpr int Account::period; // 初始值在类的定义内提供
```

> 即使一个常量静态数据成员在类的内部被初始化了，通常情况下也应该在类的外部定义一下该成员。

####  静态成员能用于某些场景，而普通成员不能

某些非静态数据成员可能非法的场合，静态成员却可以正常使用。

静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用：

```C++
class Bar {
public:
  // ...
private:
  static Bar mem1; // 正确： 静态成员可以是不完全类型
  Bar *mem2; // 正确： 指针成员可以是不完全类型
  Bar mem3;  // 错误：数据成员必须是完全类型
}
```

静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参：

```C++
class Screen {
public:
  // bkground 表示一个在类中稍后定义的静态成员
  Screen& clear(char = bkground);
private:
  static const char bkground;
};
```

非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。

# 第8章 IO库

## 8.1 IO类

标准库还定义了其他一些IO类型：iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。

![](https://cdn.pkubailu.cn/img/8.1.png)

为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。

#### IO类型间的关系

标准库使我们能忽略这些不同类型的流之间的差异，这是通过**继承机制**实现的。利用模板，我们可以使用具有继承关系的类，而不必了解继承机制如何工作的细节。

简单地说，继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类（继承类）对象当作其基类（所继承的类）对象来使用。

### 8.1.1 IO对象无拷贝或赋值

 不能拷贝或对IO对象赋值：

```C++
ofstream out1, out2;
out1 = out2; // 错误：不能对流对象赋值
ofstream print(ofstream); // 错误：不能初始化ofstream参数
out2 = print(out2); // 错误： 不能拷贝流对象
```

由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。

### 8.1.2 条件状态

下表列出了IO类所定义的一些函数和标志，可以帮助我们访问和操纵流的**条件状态**。

![](https://cdn.pkubailu.cn/img/8.2-1.png)

![](https://cdn.pkubailu.cn/img/8.2-2.png)

一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：

```C++
while(cin >> word)
  // ok:读操作成功.....
```

while循环检查>>表达式返回的流的状态。

#### 查询流的状态

IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用。IO库定义了4个iostate类型的constexpr值，表示特定的位模式。这些值用来表示特定类型的IO条件，可以与位运算符一起使用来一次性检验或设置多个标志位。

badbit表示系统级错误，如不可恢复的读写错误。一旦badbit被置位，流就无法再使用了。在发生可恢复错误后，failbit被置位。如果到达文件结束位置，eofbit和fail都会被置位

goodbit的值为0，表示流未发生错误。如果badbit、failbit、eofbit任一个被置位，则检测流状态的条件会失败。

使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当做条件使用的代码就等价于!fail()。

#### 管理条件状态

流对象的rdstate成员返回一个iostate值，对应流当前状态。setstate操作将给定条件置位，表示发生了对应错误。clear成员是一个重载的成员：它有一个不接收参数的版本，而另一个版本接受一个iostate类型的参数。

clear不接收参数的版本清除（复位）所有错误标志位。执行clear()后，调用good会返回true。

```C++
// 记住cin的当前状态
auto old_state = cin.rdstate(); // 记住cin当前状态
cin.clear(); // 使cin有效
process_input(cin); // 使用cin
cin.setstate(old_state); // 将cin置为原有状态
```

带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。

```C++
cin.clear(cin.rdstate & ~cin.failbit & ~cin.badbit);
```

### 8.1.3 管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据。

```C++
os << "please enter a value";
```

文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。

导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：

- 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。
- 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
- 我们可以使用操作符如endl来显示刷新缓冲区。
- 在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。
- 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区刷新。

#### 刷新输出缓冲区

```C++
cout << "hi!" << endl; // 输出hi和一个换行，然后刷新缓冲区
cout << "hi!" << flush; // 输出hi，然后刷新缓冲区，不附加任何额外字符
cout << "hi!" << ends; // 输出hi和一个空字符，然后刷新缓冲区
```

#### unitbuf 操纵符

如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：

```C++
cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区
cout << nounitbuf; // 回到正常的缓冲方式
```

> Warning! 如果程序异常终止，输出缓冲区不会被刷新。它所输出的数据很可能停留在输出缓冲区中等待打印。

#### 关联输入和输出流

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起。

```c++
cin >> ival;
// 导致cout的缓冲区被刷新
```

tie有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即x.tie(&o)将x流关联到输出流o。

我们既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream：

```C++
cin.tie(&cout); // 标准库将cin和cout关联在一起
ostream *old_tie = cin.tie(nullptr); // cin不再与其他流关联
cin.tie(&cerr); // 读取cin会刷新cerr而不是cout
cin.tie(old_tie); // 重建cin和cout间的正常关联
```

为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了tie。为了彻底揭开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。

## 8.2 文件输入输出

头文件fstream定义了三个类型来支持文件IO: ifstream从一个给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。

这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样。

除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。我们可以对fstream、ifstream和ofstream对象调用这些操作，但不能对其他IO类型调用这些操作。

![](https://cdn.pkubailu.cn/img/8.3.png)

### 8.2.1 使用文件流对象

当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。

创建文件流对象时，我们可以提供文件名（可选的）。如果提供了一个文件名，则open会自动调用：

```C++
ifsream in(ifile); // 构建一个ifstream并打开给定文件
ofstream out; // 输出文件流未关联到任何文件
```

这段代码定义了一个输入流in，它被初始化为从文件读取数据，文件名由string类型的参数ifile指定。第二条语句定义了一个输出流out，未与任何文件关联。文件名既可以是库类型string对象，也可以是C风格字符数组。

#### 用fstream代替iostream&

我们已经提到过。在要求使用基类型对象的地方，我们可以用继承类型的对象来替代。这意味着，接受一个iostream类型引用（或指针）参数的函数，可以用一个对应的fstream（或sstream）类型来调用。

例如：我们假定输入和输出文件的名字是通过传递给main函数的参数来指定的：

![](https://cdn.pkubailu.cn/img/8.2.1.png)

#### 成员函数open和close

如果我们定义了一个空文件流对象，可以随后调用open来将它与文件关联起来：

```C++
ifstream in(ifile); // 构筑一个ifstream并打开给定文件
ofstream out; // 输出文件流未与任何文件相关联
out.open(ifile + ".copy"); // 打开指定文件
```

如果调用open失败，failbit会被置位。因为调用open可能失败，进行open是否成功的检测通常是一个好习惯：

```C++
if (out) // 检查open是否成功
  // open成功执行的操作
```

一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的文件流调用open会失败，并会导致failbit被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一但文件成功关闭，我们可以打开新的文件：

```C++
in.close(); // 关闭文件
in.open(ifile + "2"); // 打开另一个文件
```

如果open成功，则open会设置流的状态，使得good()为true。

#### 自动构造和析构

考虑这样一个程序，它的main函数接受一个要处理的文件列表。这种程序可能会有如下的循环：

```C++
// 对每个传递给程序的文件执行循环操作
for(auto p = argv + 1; p != argv + argc; ++p) {
  ifstream input(*p); // 创建输出流并打开文件
  if (input) { // 如果文件打开成功，处理此文件
    process(input);
  } else 
    cerr << "couldn't open: " + string(*p);
} // 每个循环步 input都会离开作用域，因此会被销毁
```

当一个fstream对象离开其作用域时，与之关联的文件会自动关闭。在下一步循环中，input会再次被创建。

> 当一个fstream对象被销毁时，close会自动被调用。

### 8.2.2 文件模式

每个流都有一个关联的**文件模式**，用来指出如何使用文件。

![](https://cdn.pkubailu.cn/img/8.4.png)

无论用哪种方式打开文件，我们都可以指定文件模式，调用open打开文件时可以，用一个文件名初始化流来隐式打开文件时也可以。指定文件模式有如下限制：

- 只可以对ofstream或fstream对象设定out模式。
- 只可以对ifstream或fstream对象设定in模式。
- 只有当out也被设定时才可设定trunc模式。
- 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显示指定out模式，文件也总是以输出方式被打开。
- 默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保留以out模式打开的文件的内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。
- ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。

每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与ifstream关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；与fstream关联的文件默认以in和out模式打开。

#### 以out模式打开文件会丢弃已有数据

默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定app模式：

```C++
// 在这几条语句中，file1都被截断
ofstream out("file1") // 隐含以输出模式打开文件并截断文件
ofstream out("file1", ofstream::out) // 隐含的截断文件
ofstream out("file1", ofstream::out | ofstream::trunc) 
// 为了保留文件内容，我们必须显示指定app模式
ofstream app("file2", ofstream::app) // 隐含为输出模式
ofstream app("file2", ofstream::out | ofstream::app) 
```

> 保留被ofstream打开的文件中已有数据的唯一方法是显示指定app或in模式

#### 每次调用open时都会确定文件模式

对于一个给定流，每当打开文件时，都可以改变其文件模式。

```C++
ofstream out; // 未指定文件打开模式
out.open("file1"); // 模式隐含设置为输出和截断
out.close(); // 关闭out,以便我们将其用于其他文件
out.open("file2", ofstream::app); // 模式为输出和追加
out.close();
```

第一个open调用未显示指定输出模式，文件隐式地以out模式打开。通常情况下，out模式意味着同时使用trunc模式。因此，当前目录下名为file1的文件的内容将被清空。当打开名为file2的文件时，我们制定了append模式。文件中已有的数据都得以保留，所有写操作都在文件末尾进行。

> 在每次打开文件时，都要设置文件模式，可能是显示设置，也可能是隐式的设置。当程序未指定模式时，就使用默认值。

## 8.3 string 流

istringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream即可从string读数据也可向string写数据。与fstream类型类似，头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。

![](https://cdn.pkubailu.cn/img/8.5.png)

可以对stringstream对象调用这些操作，但不能对其他IO类型调用这些操作。

### 8.3.1 使用istringstream

当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。

![](https://cdn.pkubailu.cn/img/8.3.1.png)

### 8.3.2 使用ostringstream

当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。例如，对比上一节的例子，我们可能想逐个验证电话号码并改变其格式。如果所有号码都是有效的，我们希望输出一个新的文件，包含改变格式后的号码。对于无效的号码，我们不会将它们输出到新文件中，而是打印一条包含人名和无效号码的错误信息。

![](https://cdn.pkubailu.cn/img/8.3.2.png)

# 第9章 顺序容器

一个容器就是一些特定类型对象的集合。**顺序容器**为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

## 9.1 顺序容器概述

所有顺序容器都提供了快速顺序访问元素的能力。

![](https://cdn.pkubailu.cn/img/9.1.png)

除了固定大小的array外，其他容器都提供高校、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作。

> 新标准库的容器比旧版本快得多。现代C++程序应该使用标准库容器，而不是更原始的数据结构。

## 9.2 容器库概览

容器均定义为模板类。例如对vector，我们必须提供额外信息来生成特定的容器类型。对大多数，但不是所有容器，我们还需要额外提供元素类型信息。

```C++
list<Sales_data> // 保存 Sales_data对象的list
deque<double> // 保存double的deque
```

#### 对容器可以保存的元素类型的限制

顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另一个容器。

> 较旧的的编译器可能需要在两个尖括号之间键入空格。

虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。

例如，顺序容器构造函数的一个版本接收容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数。

```C++
// 假定noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10, init); // 正确：提供了元素初始化器
vector<noDefault> v2(10); // 错误： 必须提供一个元素初始化器
```

![](https://cdn.pkubailu.cn/img/9.2.png)

### 9.2.1 迭代器

forward_list 迭代器不支持递减运算符。

算术运算只能应用于string、vector、deque、array的迭代器。我们不能将它们用于其他任何容器类型的迭代器。

一个**迭代器范围**由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。这两个迭代器通常被称为begin和end，他们标记了容器中元素的一个范围。

迭代器范围中的元素包含begin所表示的元素以及从begin开始直至end（但不包含end）之间的所有元素。

这种元素范围被称为**左闭合区间**。

迭代器begin和end必须指向相同的容器。end可以与begin指向相同的位置，但不能指向begin之前的位置。

>如果满足如下条件，两个迭代器begin和end构成一个迭代器范围：
>
>- 他们指向同一个容器中的元素，或者是容器最后一个元素之后的位置。
>- 我们可以通过反复递增begin来到达end。换句话说，end不在begin之前。

#### 使用左闭合范围蕴含的编程假定

标准库使用左闭合范围是因为这种范围有三种方便的性质。

- 如果begin与end相等，则范围为空。
- 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。
- 我们可以对begin递增若干次，使得begin==end

### 9.2.2 容器类型成员

通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。

为了使用这些类型，我们必须显示使用其类名：

```c++
// iter是通过list<string>定义的一个迭代器类型
list<string>::iterator iter;
// count是通过vector<int>定义的一个difference_type类型
vector<int>::difference_type count;
```

#### 9.2.3 begin 和 end 成员

begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围。

实际上有两个名为begin的成员。一个是const成员，返回容器的const_iterator类型。另一个是非常量成员，返回容器的iterator类型。

用c开头的版本是C++新标准库引入的，用以支持auto与begin和end函数结合使用。

```C++
// 显示指定类型
list<string>::iterator it5 = a.begin();
list<string>::const_iterator it6 = a.cbegin();
// 是iterator还是const_iterator依赖于a的类型
auto it7 = a.begin(); // 仅当a是const时，it7是const_iterator
auto it8 = a.cbegin(); // it8是const_iterator
```

当auto与begin和end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代毫不相干。但c开头的版本还是可以获得const_iterator的，而不管容器的类型是什么。

#### 9.2.4 容器定义和初始化

每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。

![](https://cdn.pkubailu.cn/img/9.3.png)

#### 将一个容器初始化为另一个容器的拷贝

将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者拷贝由一个迭代器对指定的元素范围。

为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器得元素类型即可。

```C++
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
list<string> list2(authors); // 正确：类型匹配
deque<string> authList(authors); // 错误：容器类型不匹配
vector<string> words(articles); // 错误：容器元素类型不匹配
// 正确： 可以将const char*元素转换为string
forward_list<string> words(articles.begin(), articles.end());
```

> 当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

当两个迭代器表示一个范围时，我们可以使用这种构造函数来拷贝一个容器中的子序列。

#### 列表初始化

在新标准中，我们可以对一个容器进行列表初始化

```C++
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
```

当这样做时，我们就显示的指定了容器中每个元素的值。对于除array之外的容器类型，初始化列表还隐含的指定了容器的大小：容器将包含与初始值一样多的元素。

#### 与顺序容器大小相关的构造函数

除了与关联容器相同的构造函数外，顺序容器（array除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器：

```C++
vector<int> ivec(10, -1); // 10个int元素，每个都初始化为-1
list<string> svec(10, "hi!"); // 10个string，每个都初始化为"hi!"
forward_list<int> ivec(10); // 10个int元素，每个都初始化为0
deque<string> svec(10); // 10个元素，每个都初始化为空string
```

如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显示的元素初始值。

> 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。

#### 标准库 array具有固定大小

与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小：

```C++
array<int, 42> // 类型为：保存42个int的数组
array<string, 10> // 类型为：保存10个string的数组
```

为了使用array类型，我们必须同时指定元素类型和大小：

```C++
array<int, 10>::size_type i; // 数组类型包括元素类型和大小
array<int>::size_type j; // 错误：array<int>不是一个类型
```

与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化，就像一个内置数组一样。如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行：

```C++
array<int, 10> ia1; // 10个默认初始化的int
array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9}; // 列表初始化
array<int, 10> ia3 = {42}; // ia3[0]为42，剩余元素为0
```

值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制：

```C++
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs; // 错误：内置数组不支持拷贝或赋值
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9}; 
array<int, 10> copy = digits; // 正确：只要数组类型匹配即合法
```

与其他容器一样，array也要求初始值的类型必须与要创建的容器类型相同。此外，array还要求元素类型和大小也都一样，因为大小是array类型的一部分。

### 9.2.5 赋值和swap

赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。

如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同。

与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。

由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持assign，也不允许用花括号包围的值列表进行赋值。

![](https://cdn.pkubailu.cn/img/9.4.png)

#### 使用assign（仅顺序容器）

赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝到左边运算对象中。顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。

```C++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; // 错误：容器类型不匹配
// 正确： 可以将const char*转换为string
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

这段代码中对assign的调用将names中的元素替换为迭代器所指定的范围中的元素的拷贝。

> 由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器。

#### 使用swap

swap操作交换两个相同类型容器的内容。

```C++
vector<string> svec1(10); // 10个元素的vector
vector<string> svec2(24); // 24个元素的vector
swap(svec1, svec2);
```

调用swap后，svec1将包含24个string元素，svec2将包含10个string。除array外，交换两个容器内容的操作保证会很快—元素本身并未交换，swap只是交换了两个容器的内部数据结构。

> 除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。

元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svec1[3]的string，那么在swap之后它指向svec2[3]的元素。与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。

与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。

因此，对于array，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。

### 9.2.6 容器大小操作

每个容器类型都有三个与大小相关的操作。成员函数size返回容器中元素的数目；empty当size为0时返回布尔值true，否则返回false；max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。forward_list支持max_size和empty，但不支持size。

### 9.2.7 关系运算符

每个容器类型都支持（==和!=）；除了无序关联容器外的所有容器都支持关系运算符(>,>=,<,<=)。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。

比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似。

#### 容器的关系运算符使用元素的关系运算符完成比较

> 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。

容器的相等运算符实际上是使用元素的==运算符实现比较的，而其他关系运算符是使用元素的<运算符。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。

## 9.3 顺序容器操作

### 9.3.1 向顺序容器添加元素

除array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态的添加或删除元素来改变容器大小。

![](https://cdn.pkubailu.cn/img/9.5.png)

#### 使用push_back

除了array和forward_list之外，每个顺序容器（包括string）都支持push_back。

> Note! 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值得一个拷贝，而不是对象本身。

#### 使用push_front

list、forward_list和deque容器支持名为push_front的操作。

deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首尾进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首位之外的位置插入元素会很耗时。

#### 在容器中的特定位置添加元素

vector、deque、list、string支持insert成员。

虽然某些容器不支持push_front操作，但它们对于insert操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置。

#### 插入范围内元素

```C++
// 运行时错误： 迭代器表示要拷贝的范围，不能指向与目的位置相同的容器
slist.insert(slist.begin(), slist.begin(), slist.end());
```

在新标准下，接受元素个数或范围的insert版本返回指向第一个新加入元素的迭代器。如果范围为空，不插入任何元素，insert操作会将第一个参数返回。

#### 使用insert的返回值

通过使用insert的返回值，可以在容器中一个特定位置反复插入元素：

```C++
list<string> lst;
auto iter = lst.begin();
while (cin >> word) 
  iter = lst.insert(iter, word); // 等价于调用push_front
```

#### 使用emplace操作

当调用push或insert成员函数时，我们将元素类型的对象传递给他们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。

```C++
// 在C的末尾构造一个Sales_data对象
// 使用三个参数的Sales_data构造函数
c.emplace("978-059232323", 25, 15.99);
// 错误： 没有接受三个参数的push_back版本
c.push_back("978-059232323", 25, 15.99);
// 正确： 创建一个临时的Sales_data对象传递给push_back
c.push_back(Sales_data("978-059232323", 25, 15.99));
```

其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。

> emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。

### 9.3.2 访问元素

![](https://cdn.pkubailu.cn/img/9.6.png)

包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数。

```C++
// 在解引用一个迭代器或调用front或back之前检查是否有元素
if(!c.empty()) {
  auto va1 = *c.begin(), va2 = c.front();
  auto last = c.end();
  auto va3 = *(--last);
  auto va4 = c.back();
}
```

> 对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误。

#### 访问成员函数返回的是引用

在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用。

```C++
if (!c.empty()) {
  c.front = 42; // 将42赋值给第一个元素
  auto &v = c.back(); // 获得指向最后一个元素的值
  v = 1024; // 改变了c中元素的值
  auto v2 = c.back(); // v2 不是一个引用，它是c.back()的一个拷贝
  v2 = 0; // 未改变c中的元素
}
```

与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。

#### 下标操作和安全的随机访问

如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常：

```C++
vector<string> svec; // 空vector
cout << svec[0]; // 运行时错误：svec中没有元素
cout << svec.at(0); //抛出一个out_of_range异常
```

### 9.3.3 删除元素

![](https://cdn.pkubailu.cn/img/9.7.png)

> 删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它们是存在的。

与元素访问成员函数类似，不能对一个空容器执行弹出操作。

```C++
// 删除两个迭代器表示的范围内的元素
// 返回指向最后一个被删元素之后位置的迭代器
elem1 = slist.erase(elem1, elem2); // 调用后，elem1 == elem2
```

迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置。

### 9.3.4 特殊的forward_list操作

![](https://cdn.pkubailu.cn/img/9.8.png)

### 9.3.5 改变容器大小

我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部：

```C++
list<int> ilist(10, 42); // 10个int：每个的值都是42
ilist.resize(15); // 将5个只为0的元素添加到ilist的末尾
ilist.resize(25, -1); // 将10个值为-1的元素添加到ilist的末尾
ilist.resize(5); // 从ilist末尾删除20个元素
```

![](https://cdn.pkubailu.cn/img/9.9.png)

### 9.3.6 容器操作可能使迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题。

在向容器添加元素后：

- 如果容器是vector和string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。
- 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
- 对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，当我们删除一个元素后：

- 对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。
- 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。
- 对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。
- 注意：当我们删除元素时，尾后迭代器总是会失效。

> 由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。

#### 编写改变容器的循环程序

添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步都更新迭代器、引用和指针。

#### 不要保存end返回的迭代器

当我们添加/删除vector或string的元素后，或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器，一直当做容器末尾使用。

```C++
// 灾难：次循环的行为是未定义的
auto begin = v.begin(), end = v.end();
while(begin != end) {
  // 做一些处理
  // 插入新值，对begin重新赋值，否则的话它就会失效
  ++begin;
  begin = v.insert(begin, 42); // 插入新值
  ++begin; // 向前移动begin跳过我们刚刚加入的元素
}
```

此代码的行为是未定义的。在很多标准库实现上，此代码会导致无限循环。问题在于我们将end操作返回的迭代器保存在一个名为end的局部变量中。在循环体中，我们向容器中添加了一个元素，这个操作使保存在end中的迭代器失效了。

## 9.4 vector对象是如何增长的

当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。

#### 管理容量的成员函数

![](https://cdn.pkubailu.cn/img/9.10.png)

> reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。

只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）

如果需求大小小于或者等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。

调用reserve永远也不会减少容器占用的内存空间。类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。

在新标准库中，我们可以调用shrink_to_fit来要求deque、vector、string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。

#### capacity和size

理解capacity和size的区别非常重要。容器的size是指他已经保存的元素的数量：而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。

实际上，只要没有操作需求超出vector的容量，vector就不能重新分配内存空间。

> Note! 每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当迫不得已时才可以分配新的内存空间。

## 9.5 额外的string操作

### 9.5.1 构造string的其他方法

![](https://cdn.pkubailu.cn/img/9.11.png)

这些构造函数接受一个string或一个const char*参数，还接受（可选的）指定拷贝多少个字符的参数。当我们传递给他们的是一个string时，还可以给定一个下标来指出从哪里开始拷贝。

![](https://cdn.pkubailu.cn/img/9.11-1.png)

通常当我们从一个const char*创建string时，指针指向的数据必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。如果我们未传递计数值且数组也未必以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。

#### substr操作

![](https://cdn.pkubailu.cn/img/9.12.png)

### 9.5.2 改变string的其他方法

除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。下标指出了开始删除的位置，或是insert到给定值之前的位置：

```C++
s.insert(s.size(), 5, '!'); // 在s末尾插入5个感叹号
s.erase(s.size() - 5, 5); // 从s删除最后5个字符
```

标准库string类型还提供了接受C风格字符数组的insert和assign版本。例如，我们可以将以空字符结尾的字符数组insert到或assign给一个string：

```C++
const char *cp = "Stately, plump Buck";
s.assign(cp, 7); // s == "Stately"
s.insert(s.size(), cp + 7); // s == "Stately, plump Buck"
```

我们也可以指定将来自其他string或子字符串的字符插入到当前string中或赋予当前string：

```C++
string s = "Some string", s2 = "Some other string";
s.insert(0, s2); // 在s中位置0之前插入s2的拷贝
// 在s[0]之前插入s2中s2[0]开始的s2.size()个字符
s.insert(0, s2, 0, s2.size());
```

#### append 和 replace 函数

![](https://cdn.pkubailu.cn/img/9.13-0.png)

![](https://cdn.pkubailu.cn/img/9.13-1.png)

![](https://cdn.pkubailu.cn/img/9.13-2.png)

#### 改变string的多种重载函数

assign和append函数无需指定要替换string中哪个部分：assign总是替换string中的所有内容，append总是将新字符追加到string末尾。

### 9.5.3 string搜索操作

这些搜索成员函数及其参数。每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义为一个const string::size_type类型，并初始化为值-1。

![](https://cdn.pkubailu.cn/img/9.14-0.png)

![](https://cdn.pkubailu.cn/img/9.14-1.png)

![](https://cdn.pkubailu.cn/img/9.14-2.png)

#### 9.5.4 compare函数

![](https://cdn.pkubailu.cn/img/9.15.png)

### 9.5.5 数值转换

![](https://cdn.pkubailu.cn/img/9.16.png)

## 9.6 容器适配器

除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue、priorty_queue。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。

![](https://cdn.pkubailu.cn/img/9.17.png)

#### 定义一个适配器

每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。

```C++
stack<int> stk(deq); // 从deq拷贝元素到stk
```

默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。

```C++
// 在vector上实现的空栈
stack<string, vector<string>> str_stk;
// str_stk2 在
stack<string, vector<string>> str_stk2(svec);
```

对于一个给定的适配器，可以使用哪些容器是有限制的。所有的适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array之上。类似的，我们也不能用forward_list来构造适配器，因为所有的适配器都要求容器具有添加、删除以及访问尾元素的能力。

#### 栈适配器

![](https://cdn.pkubailu.cn/img/9.18.png)

每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作，而不能使用底层容器类型的操作。

#### 队列适配器

![](https://cdn.pkubailu.cn/img/9.19-1.png)

![](https://cdn.pkubailu.cn/img/9.19-2.png)

# 第10章 泛型算法

> 关键概念：泛型算法永远不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作。算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。

## 10.2 初识泛型算法

虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。理解算法的最基本的方法就是了解他们是否读取元素、改变元素或是重排元素。

### 10.2.1 只读算法

```C++
// 对vec中的元素求和，和的初值是0
int sum = accumulate(vec.cbegin(), vec.cend());
```

accumulate将第三个参数作为求和的起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。

> Note! accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。

```C++
// 由于string定义了+运算符，所以我们可以通过调用accumulate来将vector中所有string元素连接起来
string sum = accumulate(v.cbegin(), v.cend(), string(""));
// 错误：const char* 上没有定义+运算符
string sum = accumulate(v.cbegin(), v.cend(), "");
```

#### 操作两个序列的算法

```C++
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```

由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。例如，在此例中，roster1可以是vector<string>,而roster2是list<const char*>。

但是，equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。

> 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。

### 10.2.2 写容器元素的算法

一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此他们自身不可能改变容器的大小。

#### 算法不检查写操作

一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fill_n接受一个迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。

```C++
vector<int> vec; // 空vector
fill_n(vec.begin(), vec.size(), 0);
// 灾难: 修改vec中的10个（不存在）元素
// 这个调用是一场灾难。我们指定了要写入10个元素，但vec中并没有元素——他是空的，这条语句的结果是未定义的。
fill_n(vec.begin(), 10, 0);
```

#### 介绍back_inserter

一种保证算法有足够元素空间来容纳输出数据的方法是使用**插入迭代器**。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器所指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。

back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。

```C++
vector<int> vec; // 空向量
fill_n(back_inserter(vec), 10, 0);
```

在每步迭代中，fill_n向给定序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。

#### 拷贝算法

拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素。

```C++
// 我们可以用copy实现内置数组的拷贝
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];
//ret 指向拷贝到a2的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2);
```

copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。

多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果。

例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：

```C++
// 将所有值为0的元素改为42
replace(ilst.begin(), ilst.end(), 0, 42);
// 如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置
replace_copy(ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42);
// 此调用后，ilst并未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素在ivec中都变为42
```

### 10.2.3 重排容器元素的算法

某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的<运算符来实现排序的。

#### 消除重复单词

为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分。由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作。

```C++
void elimDups(vector<int> &word) {
  // 按字典排序words，以便查找重复单词
  sort(word.begin(), word.end());
  // unique重排输入范围，使得每个单词只出现一次
  // 排列在范围的前部，返回指向不重复区域之后第一个位置的迭代器
  auto end_unique = unique(word.begin(), word.end());
  // 使用向量操作erase删除重复单词
  word.erase(end_unique, word.end());
}
```

#### 使用unique

![](https://cdn.pkubailu.cn/img/使用unique.png)

> 标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素

## 10.3 定制操作

很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的<或==运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。

例如，sort算法默认使用元素类型的<运算符。但可能我们希望的排序顺序与<所定义的顺序不同，或是我们的序列可能保存的是未定义<运算符的元素类型（如Sales_data）。在这两种情况下，都需要重载sort的默认行为。

### 10.3.1 向算法传递函数

为了按长度重排vector，我们将使用sort的第二个版本，此版本是重载过的，他接受第三个参数，此参数是一个谓词。

#### 谓词

谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：**一元谓词**（意味着他们只接受单一参数）和**二元谓词**（意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。

```C++
bool isShorter(const string &s1, const string &s2) {
  return s1.size() < s2.size();
}
// 按长度由短至长排序words
sort(words.begin(), words.end(), isShorter);
```

#### 排序算法

在我们将words按大小重排的同时，还希望具有相同长度的元素按字典序排列。为了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。

```C++
elimDups(words); // 将words按字典序重排，并消除重复单词
// 按长度重新排序，长度相同的单词维持字典序
stable_sort(words.begin(), words.end(), isShorter);
```

### 10.3.2 lambda 表达式

根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。

举个例子：求大于等于一个给定长度的单词有多少。

![](https://cdn.pkubailu.cn/img/lambda表达式.png)

#### 介绍lambda

我们可以向一个算法传递任何类别的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。

到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针。还有其他两种可调用对象：重载了函数调用运算符的类，以及lambda表达式。

一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何内联函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式：

```C++
[capture list] (parameter list) -> return type {function body}
```

其中，capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）return type、parameter list、function body与任何普通函数一样，分别表示返回类型、参数列表、函数体。但是，与普通函数不同，lambda必须使用尾置返回来指定返回类型。

我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体

```C++
auto f = [] { return 42; };
```

此例中，我们定义了一个可调用对象f，它不接收参数，返回42。

lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符。

在lambda中忽略括号和参数列表等价于制定一个空参数列表。在此例中，当调用f时，参数列表是空的。如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。如果函数体内是一个return语句，则返回类型从返回的表达式的类型推断而来。否则，返回类型为void。

> 如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。

#### 向lambda传递参数

与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，**lambda不能有默认参数**。因此，一个lambda调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。

例子：

```C++
[](const string &s1, const string &s2) { return s1.size() < s2.size(); }
```

空捕获列表表明此lambda不使用他所在函数中的任何局部变量。

```C++
stable_sort(words.begin(), words.end(), 
           [](const string &s1, const string &s2) 
            { return s1.size() < s2.size(); });
```

当stable_sort需要比较两个元素时，他就会调用给定的这个lambda表达式。

#### 使用捕获列表

虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需的信息。

```C++
// 在本例中，我们的lambda会捕获sz，并只有单一的string参数。其函数体会将string的大小与捕获的sz的值进行比较：
[sz](const string &s)
	{ return s.size() >= sz; };
```

由于此lambda捕获sz，因此lambda的函数体可以使用sz。lambda没有捕获words,因此不能访问此变量。

> 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。

#### 调用find_if

使用此lambda，我们就可以查找第一个长度大于等于sz的元素：

```C++
// 获取一个迭代器，指向第一个满足size() >= sz 的元素
auto wc = find_if(words.begin(), words.end(), 
           [sz](const string &s) 
            { return s.size() < sz; });
```

我们可以使用find_if返回的迭代器来计算从它开始到words的末尾一共有多少个元素：

```C++
auto count = words.end() - wc;
```

#### for_each 算法

打印words中长度大于等于sz的元素。为了达到这一目的，我们可以使用for_each算法。此算法接受一个可调用对象，并对输入序列中每个元素调用此对象：

```C++
for_each(wc, words.end(), 
        [](const string &s){ cout << s << "" });
```

捕获列表为空，是因为我们只对lambda所在函数中定义的（非static）变量使用捕获列表。一个lambda可以直接使用定义在当前函数之外的名字。cout不是定义在biggies中的局部名字，而是定义在头文件iostream中。

#### 完整的 biggies

![](https://cdn.pkubailu.cn/img/完整的biggies.png)

### 10.3.3 lambda 捕获和返回

当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。

默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。

#### 值捕获

类似参数传递，变量的捕获方式也可以是值或引用。到目前为止，我们的lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。

```C++
void fcn1() {
  size_t v1 = 42;
  auto f = [v1] { return v1; };
  v1 = 0;
  auto j = f(); // j是42；f保存了我们创建它时v1的拷贝
}
```

#### 引用捕获

我们定义lambda时可以采用引用方式捕获变量。

```C++
void fcn1() {
  size_t v1 = 42;
  auto f = [&v1] { return v1; };
  v1 = 0;
  auto j = f(); // j是0；f保存v1的引用，而非拷贝
}
```

v1之前的&指出v1应该以引用方式捕获。一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。

引用捕获与返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。

我们也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。

> 当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。

![](https://cdn.pkubailu.cn/img/lambda建议.png)

#### 隐式捕获

除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式。

```C++
// sz 为隐式捕获，值捕获方式
wc = find_if(words.begin(), words.end(), 
           [=](const string &s) 
            { return s.size() < sz; });
```

如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：

```C++
void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ') {
  // os隐式捕获，引用捕获；c显式捕获，值捕获
  for_each(words.begin(), words.end(), 
           [&, c](const string &s) { os << s << c; });
  // os显式捕获，引用捕获；c隐式捕获，值捕获
  for_each(words.begin(), words.end(), 
           [=, &os](const string &s) { os << s << c; });
}
```

当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。此符号指定了默认捕获方式为引用或值。

**当混合使用隐式捕获和显式捕获时，显示捕获的变量必须使用与隐式捕获不同的方式。**

![](https://cdn.pkubailu.cn/img/10.1.png)

#### 可变lambda

默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表：

```C++
void fcn3() {
  size_t v1 = 42;
  auto f = [=] () mutable { return ++v1; };
  v1 = 0;
  auto j = f(); // j是43
}
```

一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型。

```C++
void fcn4() {
  size_t v1 = 42;
  // v1是一个非const变量的引用
  auto f = [&] () { return ++v1; };
  v1 = 0;
  auto j = f(); // j是1
}
```

#### 指定lambda 返回类型

默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。与其他返回void的函数类似，被推断返回void的lambda不能返回值。

函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。

```C++
// lambda体是单一的return语句，返回一个条件表达式的结果。我们无须指定返回类型，因为可以根据条件运算符的类型推断出来
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i){ return i < 0 ? -i : i; });
// 错误：不能推断lambda的返回类型
// 编译器推断这个版本的lambda返回类型为void，但它返回了一个int值
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i){ if(i<0) return -i; else return i; });
// 当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i) -> int
         { if(i<0) return -i; else return i; });
```

### 10.3.4 参数绑定

对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作中，通常应该定义一个函数，而不是多次编写相同的lambda表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。

如果lambda的捕获列表为空，通常可以用函数来代替它。

但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。

例如，我们用在find_if调用中的lambda比较一个string和一个给定大小。我们可以很容易地编写一个完成同样工作的函数：

```C++
bool check_size(const string &s, string::size_type sz) {
  return s.size() >= sz;
}
```

但是，我们不能用这个函数作为find_if的一个参数。find_if接受一个一元谓词，因此传递给find_if的可调用对象必须接受单一参数。

#### 标准库bind函数

bind的标准库函数，它定义在头文件functional中，可以将bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。

```C++
// 调用bind的一般形式为：
auto newCallable = bind(callable, arg_list);
```

其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。

arg_list中的参数可能包含形如\_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，她们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，\_2为第二个参数，依此类推。

#### 绑定check_size 的sz参数

作为一个简单的例子，我们将使用bind生成一个调用check_size的对象。

```C++
// check6 是一个可调用对象，接受一个string类型的参数
// 并用此string和值6来调用check_size
auto check6 = bind(check_size, _1, 6);
```

此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const string&。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。

使用bind，我们可以将原来基于lambda的find_if调用替换为如下形式：

```C++
// lambda 形式
auto wc = find_if(words.begin(), words.end(), 
           [sz](const string &s) 
            { return s.size() < sz; });
// bind形式
auto wc = find_if(words.begin(), words.end(), 
           bind(check_size, _1, sz));
```

#### 使用placeholders名字

名字_n都定义在一个名为placeholders中，而此命名空间又定义在命名空间std中。

为了使用这些名字，两个命名空间都要写上。与我们的其他例子类似，对bind的调用代码假定之前已经恰当地使用了using声明。

```C++
// 例如，_1对应的using声明为：
using std::placeholders::_1;
```

此声明说明我们要使用的名字_1定义在命名空间placeholders中，而此命名空间又定义在命名空间std中。

对每个占位符名字，我们都必须提供一个单独的using声明。编写这样的声明很烦人，也很容易出错。可以使用另外一种不同形式的using语句，而不是分别声明每个占位符。

```C++
using namespace namespace_name;
```

这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。

```C++
using namespace std::placeholders;
```

使得由placeholders定义的所有名字都可用。与bind函数一样，placeholders命名空间也定义在functional头文件中。

#### bind 的参数

我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。例如，假定f是一个可调用对象，它有5个参数，则下面对bind的调用

```C++
// g 是一个有两个参数的可调用对象
auto g = bind(f, a, b, _2, _c, _1);
```

生成一个新的可调用对象，它有两个参数，分别用占位符\_2和_1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参数分别被绑定到给定值a、b和c上。

传递给g的参数按位置绑定到占位符。即，第一个参数绑定到_1，第二个参数绑定到\_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。实际上，这个bind调用会将

```C++
g(_1, _2);
// 映射为
f(a, b, _2, c, _1);
// 例如，调用g(X,Y)会调用
f(a, b, Y, c, X);
```

#### 用bind重排参数顺序

我们可以用bind颠倒isShorter的含义：

```C++
// 按单词长度由短至长排序
sort(words.begin(), words.end(), isShorter);
// 按单词长度由长至短排序
sort(words.begin(), words.end(), bind(isShorter, _2, _1));
```

在第一个调用中，当sort需要比较两个元素A和B时，它会调用isShorter(A,B)。

在第二个对sort的调用中，传递给isShorter的参数被交换过来了。因此，当sort比较两个元素时，就好像调用isShorter(B,A)一样。

#### 绑定引用参数

默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。

但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。

```C++
// 错误： 不能拷贝os
for_each(words.begin(), words.end(), bind(print, os, _1, ' '));
```

原因在于bind拷贝其参数，而我们不能拷贝一个ostream。如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库**ref**函数：

```C++
for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));
```

函数ref返回一个对象，包含给定的的引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文件functional中。

## 10.4 再探迭代器

除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。

- **插入迭代器**：这些迭代器被绑定到一个容器上，可用来向容器插入元素。
- **流迭代器**：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流
- **反向迭代器**：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。
- **移动迭代器**：这些专用的迭代器不是拷贝其中的元素，而是移动它们。

### 10.4.1 插入迭代器

插入器是一种迭代器适配器，他接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。

![](https://cdn.pkubailu.cn/img/10.2.png)

插入器有三种类型，差异在于元素插入的位置：

- **back_inserter**：创建一个使用push_back的迭代器。
- **front_inserter**：创建一个使用push_front的迭代器。
- **inserter**：创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。

> Note! 只有在容器支持push_front的情况下，我们才可以使用front_inserter。类似的，只有在容器支持push_back的情况下，我们才能使用back_inserter。

理解插入器的工作过程是很重要的：当调用inserter(c,iter)时，我们得到一个迭代器，接下来使用它时，会将元素插入到iter原来所指向的元素之前的位置。即，如果it是由inserter生成的迭代器。

```C++
*it = val;
// 其效果与下面代码一样
it = c.insert(it, val); // it指向新加入的元素
++it; // 递增it使它指向原来的元素
```

front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当我们使用front_inserter时，元素总是插入到容器第一个元素之前。即使我们传递给inserter的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：

```C++
list<int> lst = {1,2,3,4};
list<int> lst2, lst3; // 空list
// 拷贝完成后，lst2包含4 3 2 1 
copy(lst.cbegin(), lst.cend(), front_inserter(lst2));
// 拷贝完成后，lst3包含1 2 3 4
copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));
```

当调用front_inserter(c)时，我们得到一个插入迭代器，接下来会调用push_front。当每个元素被插入到容器c中时，它变为c的新的首元素。因此，front_inserter生成的迭代器会将插入的元素序列的顺序颠倒过来，而inserter和back_inserter则不会。

### 10.4.2 iostream 迭代器

虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器。**istream_iterator**读取输入流，**ostream_iterator**向一个输出流写数据。这些迭代器将他们对应的流当作一个特定类型的元素序列来处理。通过使用迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。

#### istream_iterator 操作

当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个istream_iterator使用>>来读取流。因此，istream_iterator要读取的类型必须定义了输入运算符。当创建一个istream_iterator时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当做尾后值使用的迭代器。

```C++
istream_iterator<int> int_it(cin); // 从cin读取int
istream_iterator<int> int_eof; // 尾后迭代器
ifstream in("afile");
istream_iterator<string> str_it(in); // 从"afile"读取字符串
```

例子：用istream_iterator从标准输入读取数据，存入一个vector

```C++
istream_iterator<int> in_iter(cin); // 从cin读取int
istream_iterator<int> eof; // 尾后迭代器
while (in_iter != eof) {
  // 后置递增运算读取流，返回迭代器的旧值
  // 解引用迭代器，获得从流读取的前一个值
  vec.push_back(*in_iter++);
}
```

此循环从cin读取int值，保存在vec中。在每个循环步中，循环体代码检查in_iter是否等于eof。eof被定义为空的istream_iterator，从而可以当做尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器相等。

我们可以将程序重写为如下形式，这体现了istream_iterator更有用的地方：

```C++
istream_iterator<int> in_iter(cin), eof; // 从cin读取int
vector<int> vec(in_iter, eof); // 从迭代器范围构造vec
```

本例中我们用一对表示元素范围的迭代器来构造vec。这两个迭代器是istream_iterator，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据为止。从流中读取的数据用来构造vec。

![](https://cdn.pkubailu.cn/img/10.3.png)

#### 使用算法操作流迭代器

由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。

```C++
// 我们可以用一对istream_iterator来调用accumulate
isstream_iterator<int> in_iter(cin), eof;
cout << accumulate(in_iter, eof, 0) << endl;
// 此调用会计算出从标准输入读取的值的和
```

#### istream_iterator 允许使用懒惰求值

当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。

#### ostream_iterator 操作

我们可以对任何具有输出运算符（<<运算符）的类型定义ostream_iterator。当创建一个ostream_iterator时，我们可以提供（可选的）第二个参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面值常量或者一个指向以空字符结尾的字符数组的指针）。必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator。

![](https://cdn.pkubailu.cn/img/10.4.png)

我们可以用ostream_iterator来输出值的序列：

```C++
ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec)
  *out_iter++ = e; // 赋值语句实际上将元素写到cout
cout << endl;
```

此程序将vec中的每个元素写到cout，每个元素后加一个空格。每次向out_iter赋值时，写操作就会被提交。

值得注意的是，当我们向out_iter赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子：

```C++
for (auto e : vec)
  out_iter = e;
```

运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。

可以通过调用copy来打印vec中的元素，这比编写循环更为简单：

```C++
copy(vec.begin(), vec.end(), out_iter);
cout << endl;
```

#### 使用流迭代器处理类类型

![](https://cdn.pkubailu.cn/img/使用流迭代器处理类类型.png)

### 10.4.3 反向迭代器

反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素：递减一个迭代器（--it）会移动到下一个元素。

除了forward_list之外，其他容器都支持反向迭代器。我们可以通过调用rbegin、rend、crbegin和crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有const和非const版本。

![](https://cdn.pkubailu.cn/img/反向迭代器.png)

虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做是我们可以用算法透明的向前或向后处理容器。例如，可以通过向sort传递一对反向迭代器来将vector整理为递减排序

```C++
sort(vec.begin(), vec.end()); // 按”正常序“排列vec
sort(vec.rbegin(), vec.rend()); // 按”逆序“排列vec
```

#### 反向迭代器需要递减运算符

不必惊讶，我们只能从既支持++也支持--的迭代器来定义反向迭代器。毕竟反向迭代器的目的是在序列中反向移动。除了forward_list之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个forward_list或一个流迭代器创建反向迭代器。

#### 反向迭代器和其他迭代器间的关系

![](https://cdn.pkubailu.cn/img/反向迭代器和其他迭代器间的关系.png)

图10.2中的对象显示了普通迭代器与反向迭代器之间的关系。例如，rcomma和rcomma.base()指向不同的元素，line.crbegin和line.cend()也是如此。这些不同保证了元素范围无论是正向处理还是反向处理都是相同的。

> Note! 反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要的结果：当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。

## 10.5 泛型算法结构

任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如find，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如sort，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别。

![](https://cdn.pkubailu.cn/img/10.5.png)

第二种算法分类的方式是按照是否读、写或是重排序列中的元素来分类。

### 10.5.1  5类迭代器

类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另外一些只有特定类别的迭代器才支持。例如，ostream_iterator只支持递增、解引用和赋值。vector、string和deque的迭代器除了这些操作外，还支持递减、关系和算术运算。

迭代器是按他们所提供的操作来分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。

C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如，find算法在一个序列上进行一边扫描，对元素进行只读操作，因此至少需要输入迭代器。replace函数需要一对迭代器，至少是前向迭代器。对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。

> 对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或提示。

#### 迭代器类别

**输入迭代器**：可以读取序列中的元素。一个输入迭代器必须支持

- 用于比较两个迭代器的相等和不相等运算符（==、!=）
- 用于推进迭代器的前置和后置递增运算（++）
- 用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧
- 箭头运算符（->），等价于(*it).member，即，解引用迭代器，并提取对象的成员

输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法find和accumulate要求输入迭代器；而istream_iterator是一种输入迭代器。

**输出迭代器**：可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：

- 用于推进迭代器的前置和后置递增运算（++）
- 解引用运算符（*），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）

我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，copy函数的第三个参数就是输出迭代器。ostream_iterator类型也是输出迭代器

**前向迭代器**：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。

**双向迭代器**：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（--）。算法reverse要求双向迭代器。除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。

**随机迭代器**：提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持：

- 用于比较两个迭代器相对位置的关系运算符（<、<=、>和>=）
- 迭代器和一个整数值的加减运算（+、+=、-和-=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置
- 用于两个迭代器上的减法运算符（-），得到两个迭代器的距离。
- 下标运算符（iter[n])，与*(iter[n])等价

算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。

### 10.5.2 算法形参模式

在任何其他算法分类之上，还有一组参数规范。理解这些参数规范对学习新算法很有帮助——通过理解参数的含义，你可以将注意力集中在算法所做的操作上。大多数算法具有如下4种形式之一：

```C++
alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
```

#### 接受单个目标迭代器的算法

dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定：按其需要写入数据，不管写入多少个元素都是安全的。

> Warning! 向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。

如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的元素内。更常见的情况是，dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因而保证空间是足够的。ostream_iterator会将数据写入到一个输出流，同样不管写入多少个元素都没有问题。

#### 接受第二个输入序列的算法

> 接收单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。

### 10.5.3 算法命名规范

除了参数规范，算法还遵循一套命名和重载规范。这些规范处理诸如：如何提供一个操作代替默认的<或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。

#### 一些算法使用重载形式传递一个谓词

接受谓词参数来代替<或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替<或==：

```C++
unique(beg, end); // 使用 == 运算符比较元素
unique(beg, end, comp); // 使用comp比较元素
```

两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的==运算符来检查重复元素；第二个则调用comp来确定两个元素是否相等。由于两个版本的函数在参数个数上不相等，因此具体应该调用哪个版本不会产生歧义。

#### _if版本的算法

接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。**接受谓词参数的算法都有附加的_if前缀：**

```C++
find(beg, end, val); // 查找输入范围中val第一次出现的位置
find_if(beg, end, pred); // 查找第一个令pred为真的元素
```

这两个算法提供了命名上差异的版本，而非重载版本，因为这两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但是为了避免任何可能的歧义，标准库选择提供不同名字的版本而不是重载。

#### 区分拷贝元素的版本和不拷贝的版本

默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个_copy：

```C++
reverse(beg, end); // 反转输入范围中元素的顺序
reverse_copy(beg, end, dest); // 将元素按逆序拷贝到dest
```

一些算法同时提供_copy和\_if版本。这些版本接受一个目的位置迭代器和一个谓词：

```C++
// 从v1中删除奇数元素
remove_if(v1.begin(), v1.end(), [](int i){ return i%2; });
// 将奇数元素从v1拷贝到v2;v1不变
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i){ return i%2; });
```

## 10.6 特定容器算法

与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法。特别是，它们定义了独有的sort、merge、remove、reverse和unique。通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器。

链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个列表可以通过改变元素间的链接而不是真的交换他们的值来快速”交换“元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。

> 对于list和forward_list，应该优先使用成员函数版本的算法而不是通用算法。

![](https://cdn.pkubailu.cn/img/10.6-1.png)

![](https://cdn.pkubailu.cn/img/10.6-2.png)

#### splice 成员

此算法是链表数据结构所特有的。

![](https://cdn.pkubailu.cn/img/10.7.png)

#### 链表特有的操作会改变容器

多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。

例如，通用版本的merge将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的merge函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。

# 第11章 关联容器

关联容器支持高效的关键字查找和访问。两个主要的**关联容器**类型是map和set。map中的元素是一些（关键字-值）对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素只包含一个关键字；set支持高效的关键字查询操作—检查一个给定关键字是否在set中。例如，在某些文本处理过程中，可以用一个set来保存想要忽略的单词。字典则是一个很好的使用map的例子：可以将单词作为关键字，将单词释义作为值。

标准库提供8个关联容器。这8个容器间的不同体现在三个维度上：

1. 或者是一个set，或者是一个map；
2. 或者要求不重复的关键字，或者允许重复关键字；
3. 按顺序保存元素，或无序保存。

允许重复关键字的容器的名字中都包含单词multi；

不保持关键字按顺序存储的容器的名字都以单词unordered开头。

无序容器使用哈希函数来组织元素。

![](https://cdn.pkubailu.cn/img/11.1.png)

## 11.1 使用关联容器

map通常被称为**关联数组**。关联数组与”正常数组“类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。

与之相对，set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。

#### 使用 map

![](https://cdn.pkubailu.cn/img/使用map.png)

#### 使用 set

![](https://cdn.pkubailu.cn/img/使用set-1.png)

![](https://cdn.pkubailu.cn/img/使用set-2.png)

## 11.2 关联容器概述

关联容器都支持9.2节中介绍的普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如push_front、push_back。原因是关联容器中元素是根据关键字存储的。

关联容器的迭代都是双向的。

### 11.2.1 定义关联容器

当定义一个map时，必须即指明关键字类型又指明值类型；而定义一个set时，只需指明关键字类型就行。

```C++
map<string, size_t> word_count; // 空容器
// 列表初始化
set<string> exclude = {"the", "but", "and"};
// 三个元素；authors将姓映射为名
map<string, string> authors = { {"Joyce", "james"},
                               {"Austen", "Jane"},
                               {"Dickens", "Charles"}
                              };
```

初始化器必须能转换为容器中元素的类型。

当初始化一个map时，必须提供关键字类型和值类型。我们将每个关键字—值对包围在花括号中：{key, value}。

#### 初始化multimap 或 multiset

一个map或set中的关键字必须是唯一的。容器multimap和multiset没有此限制，它们都允许多个元素具有相同的关键字。

```C++
vector<int> ivec;
for(vector<int>::size_type i = 0; i != 10; ++i){
  ivec.push_back(i);
  ivec.push_back(i);
}
// ivec 包含来自ivec的不重复的元素；miset包含所有20个元素
set<int> iset(ivec.cbegin(), ivec.cend());
multiset<int> miset(ivec.cbegin(), ivec.cend());
```

即使我们用整个ivec容器来初始化iset，它也只含有10个元素：对应ivec中每个不同的元素。另一方面，miset有20个元素，与ivec中的元素数量一样多。

### 11.2.2 关键字类型的要求

关联容器对其关键字类型有一些限制。对于有序容器——map、multimap、set、multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<运算符来比较两个关键字。

> Note! 传递给排序算法的可调用对象必须满足与关联容器中关键字一样的类型要求。

#### 有序容器的关键字类型

可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的<运算符。所提供的操作必须在关键字类型上定义一个**严格弱序**。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质：

- 两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2，那么k2决不能“小于等于”k1。
- 如果k1“小于等于”k2，且k2”小于等于“k3，那么k1必须”小于等于“k3。
- 如果存在两个关键字，任何一个都不”小于等于“另一个，那么我们称这两个关键字是”等价“的。

如果两个关键字是等价的，那么容器将他们视为相等来处理。当用作map的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个来访问对应的值。

> Note! 在实际编程中，重要的是，如果一个类型定义了”行为正常“的<运算符，则它可以用作关键字类型。

#### 使用关键字类型的比较函数

用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。

在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。

<img src="https://cdn.pkubailu.cn/img/使用关键字类型的比较函数.png"  />

### 11.2.3 pair 类型

一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样：

```C++
pair<string, string> anon; // 保存两个string
pair<string, size_t> word_count; // 保存一个string和一个size_t
pair<string, vector<int>> line; // 保存string和vector<int>
```

pair的默认构造函数对数据成员进行值初始化。因此，anon是一个包含两个空string的pair，word_count中的size_t成员值为0，而string成员被初始化为空。

我们也可以为每个成员提供初始化器：

```C++
pair<string, string> author{"James", "Joyce"};
```

与其他标准库类型不同，pair的数据成员是public的。两个成员分别命名为first和second。我们用普通的成员访问符号（.）来访问他们。

![](https://cdn.pkubailu.cn/img/11.2.png)

#### 创建pair对象的函数

想象有一个函数需要返回一个pair。在新标准下，我们可以对返回值进行列表初始化

```C++
pair<string, int> process(vector<int> &v) {
  // 处理v
  if(!v.empty())
    return {v.back(), v.back().size()}; // 列表初始化
  else
    return pair<string, int>(); // 隐式构造返回值
}
// 显式构造返回值
if(!v.empty()) {
  return pair<string, int>(v.back(), v.back().size());
}
// 使用make_pair来生成pair对象，pair的两个类型来自于make_pair的参数
if(!v.empty()) {
  return make_pair(v.back(), v.back().size());
}
```

## 11.3 关联容器操作

除了表9.2中列出的类型，关联容器还定义了以下列出的类型。这些类型表示容器关键字和值的类型。

![](https://cdn.pkubailu.cn/img/11.3.png)

对于set类型，key_type和value_type是一样的；set中保存的值就是关键字。在一个map中，元素是关键字—值对。即，每个元素是一个pair对象，包含一个关键字和一个关联的值。由于我们不能改变一个元素的关键字，因此这些pair的关键字部分是const的：

```C++
set<string>::value_type v1; // v1是一个string
set<string>::key_type v2; // v2是一个string
map<string, int>::value_type v3; // v3是一个pair<const string, int>
map<string, int>::key_type v4; // v4是一个string
map<string, int>::mapped_type v5; // v5是一个int
```

与顺序容器一样，我们使用作用域运算符来提取一个类型的成员——例如，map<string, int>::key_type。

只有map类型（unordered_map、unordered_multimap、multimap、map）才定义了mapped_type。

### 11.3.1 关联容器迭代器

当解引用一个关联迭代器时，我们会得到一个类型为容器的value_type的值的引用。

```C++
// 获得指向word_count中一个元素的迭代器
auto map_it = word_count.begin();
// *map_it是一个指向pair<const string, size_t>对象的引用
cout << map_it->first; // 打印此元素的关键字
cout << map_it->second // 打印此元素的值
map_it->first = "new key"; // 错误：关键字是const的
++map_it->second; // 正确：我们可以通过迭代器改变元素
```

> Note! 必须记住，一个map的value_type是一个pair，我们可以改变pair的值，但不能改变关键字成员的值。

#### set的迭代器是const的

虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改：

```C++
set<int> iset = {0,1,2,3,4,5};
set<int>::iterator set_it = iset.begin();
if(set_it != iset.end()){
  *set_it = 42; // 错误：set中的关键字是只读的
  cout << *set_it <<endl; // 正确：可以读关键字
}
```

#### 遍历关联容器

map和set类型都支持表9.2中的begin和end操作。与往常一样，我们可以用这些函数获取迭代器，然后用迭代器来遍历容器。

```C++
// 获得一个指向首元素的迭代器
auto map_it = word_count.cbegin();
while(map_it != word_count.cend()){
  cout << map_it->first;
  cout << map_it->second;
  ++map_it; // 递增迭代器，移动到下一个元素
}
```

> Note! 本程序的输出是按字典序排列的。当使用一个迭代器遍历一个map、multimap、set、multiset时，迭代器按关键字升序遍历元素

#### 关联容器和算法

我们通常不对关联容器使用泛型算法。关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是const的，map中的元素是pair，其第一个成员是const的。

关联容器可用于只读取元素的算法。但是，很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行（快速）查找，因此对其使用泛型搜索算法几乎总是个坏主意。例如，关联容器定义了一个名为find的成员，它通过一个给定的关键字直接获取元素。我们可以用泛型find算法来查找一个元素，但此算法会进行顺序搜索。使用关联容器定义的专用的find成员会比调用泛型find快得多。

在实际编程中，如果我们真要对一个关联容器使用算法，要么是将它当做一个源序列，要么当做一个目的位置。

### 11.3.2 添加元素

关联容器的insert成员向容器中添加一个元素或一个元素范围。由于map和set（以及对应的无序类型）包含不重复的关键字，因此插入一个已经存在的元素对容器没有任何影响：

```C++
vector<int> ivec = {2,4,6,8,2,4,6,8};
set<int> set2;
set2.insert(ivec.begin(), ivec.end()); // set2有4个元素
set2.insert({1,3,5,7,1,3,5,7}); // set2 现在有8个元素
```

insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，这两个版本的行为类似对应的构造函数——对于一个给定的关键字，只有第一个带此关键字的元素才被插入到容器中。

#### 向map添加元素

对一个map进行insert操作时，必须记住元素类型是pair。通常对于想要插入的数据，并没有一个现成的pair对象。可以在insert的参数列表中创建一个pair：

```C++
// 向word_count插入word的4种方法
word_count.insert({word, 1});
word_count.insert(make_pair(word, 1));
word_count.insert(pair<string, size_t>(word, 1));
word_count.insert(map<string, size_t>::value_type(word, 1));
```

如我们所见，在新标准下，创建一个pair最简单的方法是在参数列表中使用花括号初始化。

![](https://cdn.pkubailu.cn/img/11.4.png)

#### 检测insert的返回值

insert（或emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，告诉我们插入操作是否成功。pair的first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则insert什么事情也不做，且返回值中的bool部分为false。如果关键字不存在，元素被插入容器中，且bool值为true。

例子：用insert重写单词计数程序：

```C++
map<string, size_t> word_count;
string word;
while(cin >> word){
  auto ret = word_count.insert({word, 1});
  if(!ret.second) // word 已在word_count中
    ++ret.first->second; // 递增计数器
}
```

#### 展开递增语句

在这版本的单词计数程序中，递增计数器的语句很难理解。通过添加一些括号来反映出运算符的优先级，会使表达式更容易理解一些：

```C++
++((ret.first)->second); // 等价的表达式
```

下面我们一步一步来解释此表达式：

ret 保存insert返回的值，是一个pair。

ret.first是pair的第一个成员，是一个map迭代器，指向具有给定关键字的元素。

ret.first->解引用此迭代器，提取map中的元素，元素也是一个pair。

ret.first->second map中元素的值部分。

++ret.first->second递增此值。

#### 向multiset 或 multimap添加元素

我们的单词计数程序依赖于这样一个事实：一个给定的关键字只能出现一次。我们有时希望能添加具有相同关键字的多个元素。例如，可能想建立作者到他所著书籍题目的映射。

```C++
multimap<string, string> authors;
// 插入第一个元素，关键字为Barth, John
authors.insert({"Barth, John", "Sot-Weed Factor"});
// 正确：添加第二个元素，关键字也是Barth, John
authors.insert({"Barth, John", "Lost in the Funhouse"});
```

对允许重复关键字的容器，接收单个元素的insert操作返回一个指向新元素的迭代器。这里无须返回一个bool值，因为insert总是向这类容器中加入一个新元素。

### 11.3.3 删除元素

![](https://cdn.pkubailu.cn/img/11.5.png)

关联容器定义了三个版本的erase。与顺序容器一样，我们可以通过传递给erase一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。

关联容器提供一个额外的erase操作，它接受一个key_value参数。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。

```C++
// 删除一个关键字，返回删除的元素数量
if(word_count.erase(removal_word))
  cout << "OK: " << removal_word << "removed\n";
else 
  cout << "oops: " << removal_word << "not found!\n";
```

对于保存不重复关键字的容器，erase的返回值总是0或1。若返回值为0，则表明想要删除的元素并不在容器中

对允许重复关键字的容器，删除元素的数量可能大于1：

```C++
auto cnt = authors.erase("Barth, John");
// cnt的值为2
```

### 11.3.4 map的下标操作

![](https://cdn.pkubailu.cn/img/11.6.png)

map和unordered_map容器提供了下标运算符和一个对应的at函数。set类型不支持下标因为set中没有与关键字相关联的”值“。元素本身就是关键字。我们不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。

类似我们用过的其他下标运算符，map下标运算符接受一个索引（即，一个关键字），获取与此关键字相关联的值。但是，与其他下标运算符不同的是，如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化。

```C++
// 例如，如果我们编写如下代码
map <string, size_t> word_count; // empty map
word_count["Anna"] = 1;
```

将会执行如下操作

- 在word_count中搜索关键字为Anna的元素，未找到。
- 将一个新的关键字—值对插入到word_count中。关键字是一个const string，保存Anna。值进行值初始化，在本例中意味着值为0.
- 提取出新插入的元素，并将值1赋予它。

由于下标运算符可能插入一个新元素，我们只可以对非const的map使用下标操作。

#### 使用下标操作的返回值

map的下标运算符与我们用过的其他下标运算符的另一个不同之处是其返回类型。通常情况下，解引用一个迭代器所返回的类型与下标运算符返回的类型是一样的。但对map则不然：当对一个map进行下标操作时，会获得一个mapped_type对象；当解引用一个map迭代器时，会得到一个value_type对象。

与其他下标运算符相同的是，map的下标运算符返回一个左值。由于返回的是一个左值，所以我们既可以读也可以写元素：

```C++
cout << word_count["Anna"]; // 用Anna作为下表提取元素；会打印出1
++word_count["Anna"]; // 提取元素，将其增1
cout << word_count["Anna"];
```

> Note! 与vector和string不同，map的下标运算符返回的类型与解引用map迭代器得到的类型不同。

有时只是想知道一个元素是否已在map中，但在不存在的时候并不想添加元素。在这种情况下就不能使用下标运算符。

### 11.3.5 访问元素

关联容器提供多种查找一个指定元素的方法，应该使用哪个操作依赖于我们要解决什么问题。如果我们所关心的只不过是一个特定元素是否已在容器中，可能find是最佳选择。对于不允许重复关键字的容器，可能使用find还是count没什么区别。但对于允许重复关键字的容器，count还会做更多的工作：如果元素在容器中，它还会统计有多少个元素有相同的关键字。如果不需要计数，最好使用find：

```C++
set<int> iset = {0,1,2,3,4,5};
iset.find(1); // 返回一个迭代器，指向key == 1 的元素
iset.find(11); // 返回一个迭代器，指向iset.end()
iset.count(1); // 返回1
iset.count(11); // 返回0
```

![](https://cdn.pkubailu.cn/img/11.7-1.png)

![](https://cdn.pkubailu.cn/img/11.7-2.png)

#### 对map使用find代替下标操作

对map和unordered_map类型，下标运算符提供了最简单的提取元素的方法。但是，使用下标运算符有一个严重的副作用：如果关键字还未在map中，下标操作会插入一个具有给定关键字的元素。

但有时，我们只是想知道一个给定关键字是否在map中，而不想改变map。这种情况下，应该使用find。

#### 在multimap或multiset中查找元素

在允许重复关键字的容器中查找一个元素其过程较为复杂：在容器中可能有很多元素具有给定的关键字。如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。

![](https://cdn.pkubailu.cn/img/在multimap中查找元素.png)

> Note! 当我们遍历一个multimap或multiset时，保证可以得到序列中所有具有给定关键字的元素。

#### 一种不同的，面向迭代器的解决办法

我们还可以用lower_bound和upper_bound来解决此问题。如果关键字在容器中，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置。如果元素不在multimap中，则lower_bound和upper_bound会返回相等的迭代器——指向一个不影响排序的关键字插入位置。因此，用相同的关键字调用lower_bound和upper_bound会得到一个迭代器范围，表示所有具有该关键字的元素的范围。

当然，这两个操作返回的迭代器可能是容器的尾后迭代器。

> lower_bound返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键字不在容器中，则lower_bound会返回关键字的第一个安全插入点——不影响容器中元素顺序的插入位置

```C++
// 重写前面的程序
for(auto beg = authors.lower_bound(search_item), end = authors.upper_bound(search_item); beg != end; ++beg)
  cout << beg->second << endl; // 打印每个题目
```

#### equal_range 函数

解决此问题的最后一种方法是三种方法中最直接的：不必再调用upper_bound和lower_bound，直接调用equal_range即可。此函数接受一个关键字，返回一个迭代器pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。

```C++
for(auto pos = authors.equal_range(search_item); pos.first != pos.end; ++pos.first)
  cout << pos.first->second << endl;
```

## 11.4 无序容器

新标准定义了4个无序关联容器，这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。

> 如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。

#### 使用无序容器

除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作。这意味着我们曾用于map和set的操作也能用于unordered_map和unordered_set。

因此，通常可以用一个无序容器替换对应的有序容器，反之亦然。但是，由于元素未按顺序存储，一个使用无序容器的程序的输出（通常）会与使用有序容器的版本不同。

#### 管理桶

无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，他指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。

无序容器提供了一组管理桶的函数。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。

![](https://cdn.pkubailu.cn/img/11.8.png)

#### 无序容器对关键字类型的要求

默认情况下，无序容器使用关键字类型的==运算符来比较元素，他们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和智能指针类型定义了hash。因此，我们可以直接定义关键字是内置类型（包括指针）、string还是智能指针类型的无序容器。

但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。

![](https://cdn.pkubailu.cn/img/无序容器重载hash.png)

如果我们的类定义了==运算符，则可以只重载哈希函数：

```C++
// 使用FooHash 生成哈希值； Foo必须有==运算符
unorder_set<Foo, decltype(FooHash)*> fooSet(10, FooHash);
```

# 第12章 动态内存

静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。

除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作**自由空间**或**堆**。程序用堆来存储动态分配的对象——即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不在使用时，我们的代码必须显示的销毁他们。

> Warning! 虽然使用动态内存有时是必要的，但众所周知，正确的管理动态内存是非常棘手的。

## 12.1 动态内存与智能指针

在C++中，动态内存的管理是通过一对运算符来完成的：new,在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

为了容易（同时也更安全）地使用动态内存，新的标准库提供了两种**智能指针**类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：**shared_ptr**允许多个指针指向同一个对象；**unique_ptr**则”独占“所指向的对象。标准库还定义了一个名为**weak_ptr**的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。

### 12.1.1 shared_ptr 类

类似vector，智能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。

```C++
shared_ptr<string> p1; // shared_ptr,可以指向string
shared_ptr<list<int>> p2; // shared_ptr,可以指向int的list
```

默认初始化的智能指针中保存着一个空指针

智能指针的使用方式与普通指针类似。解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空：

```C++
// 如果p1不为空，检查他是否指向一个空string
if(p1 && p1->empty())
  *p1 = "hi"; // 如果p1指向一个空string，解引用p1,将一个新值赋予string
```

![](https://cdn.pkubailu.cn/img/12.1.png)

#### make_shared 函数

最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。

```C++
// 指向一个值为42的int的shared_ptr
shared_ptr<int> p3 = make_shared<int>(42);
// 指向一个值为"9999999999"的string
shared_ptr<string> p4 = make_shared<string>(10,'9');
```

类似顺序容器的emplace成员，make_shared用其参数来构造给定类型的对象。例如，调用make_shared<string>时传递的参数必须与string的某个构造函数相匹配，调用make_shared<int>时传递的参数必须能用来初始化一个int，依次类推。如果我们不传递任何参数，对象就会进行值初始化。

当然，我们通常用auto定义一个对象来保存make_shared的结果，这种方式较为简单：

```C++
auto p6 = make_shared<vector<string>>();
```

#### shared_ptr 的拷贝和赋值

当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：

```C++
auto p = make_shared<int>(42); // p指向的对象只有p一个引用者
auto q(p); // p和q指向相同对象，此对象有两个引用者
```

我们可以认为每个shared_ptr都有一个关联的计数器，通常称为**引用计数**。无论何时我们拷贝一个shared_ptr，计数器都会递增。当我们给shared_ptr赋予一个值或是shared_ptr被销毁时，计数器就会递减。

一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。

#### shared_ptr 自动销毁所管理的对象......

当指向一个对象的最后一个shared_ptr被销毁时，shared_ptr类会自动销毁此对象。它是通过另一个特殊的成员函数——析构函数完成销毁工作的。类似于构造函数，每个类都有一个析构函数。

shared_ptr的析构函数会递减它所指向的对象的引用计数。如果引用计数变为0，shared_ptr的析构函数就会销毁对象，并释放它占用的内存。

#### .......shared_ptr 还会自动释放相关联的内存

当动态对象不再被使用时，shared_ptr类会自动释放动态对象，这一特性使得动态内存的使用变得非常容易。例如：我们可能有一个函数，他返回一个shared_ptr，指向一个Foo类型的动态分配的对象，对象是通过一个类型为T的参数进行初始化的：

![](https://cdn.pkubailu.cn/img/shared_ptr释放内存.png)

> Note! 如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得使用erase删除不再需要的那些元素。

#### 使用了动态生存期的资源的类

程序使用动态内存出于以下三种原因之一：

1. 程序不知道自己需要使用多少对象
2. 程序不知道所需对象的准确类型
3. 程序需要在多个对象间共享数据

容器类是出于第一种原因而使用动态内存的典型例子。

到目前为止，我们使用过的类中，分配的资源都与对应对象生存期一致。例如，每个vector”拥有“其自己的元素。由一个vector分配的元素只有当这个vector存在时才存在。当一个vector被销毁时，这个vector中的元素也都被销毁。

但某些类分配的资源具有与原对象相独立的生存期。

一般而言，如果两个对象共享底层的数据，当某个对象被销毁时，我们不能单方面的销毁底层数据：

```C++
Blob<string> b1; // 空Blob
{ // 新作用域
  Blob<string> b2 = {"a", "an", "the"};
  b1 = b2; // b1 和 b2 共享相同的元素
} // b2 被销毁了，但b2中的元素不能销毁
  // b1 指向最初由b2创建的元素
```

在此例中，b1和b2共享相同的元素，当b2离开作用域时，这些元素必须保留，因为b1仍然在使用它们。

> 使用动态内存的一个常见原因是允许多个对象共享相同的状态

#### 定义StrBlob类

我们不能在一个Blob对象内直接保存vector，因为一个对象的成员在对象销毁时也会被销毁。为了保证vector中的元素继续存在，我们将vector保存在动态内存中。

为了实现我们所希望的数据共享，我们为每个StrBlob设置一个shared_ptr来管理动态分配的vector。此shared_ptr的成员将记录有多少个StrBlob共享相同的vector，并在vector的最后一个使用者被销毁时释放vector。

![](https://cdn.pkubailu.cn/img/StrBlob类.png)

#### StrBlob 构造函数

两个构造函数都使用初始化列表来初始化其data成员，令它指向一个动态分配的vector。默认构造函数分配一个空vector：

```C++
StrBlob::StrBlob(): data(make_shared<vector<string>>()) {}
StrBlob::StrBlob(initializer_list<string> i1): data(make_shared<vector<string>>(i1)) {}
```

接受一个initializer_list的构造函数将其参数传递给对应的vector构造函数。此构造函数通过拷贝列表中的值来初始化vector的元素。

#### 元素访问成员函数

pop_back、front和back操作访问vector中的元素。这些操作在试图访问元素之前必须检查元素是否存在。由于这些成员函数需要做相同的检查操作，我们为StrBlob定义了一个名为check的private工具函数，它检查一个给定索引是否在合法范围内。除了索引，check还接受一个string参数，它还会将此参数传递给异常处理程序，这个string描述了错误内容：

![](https://cdn.pkubailu.cn/img/元素访问成员函数.png)

#### StrBlob 的拷贝、赋值和销毁

类似Sales_data类，StrBlob使用默认版本的拷贝、赋值和销毁成员函数来对此类型的对象进行这些操作。默认情况下，这些操作拷贝、赋值和销毁类的数据成员。我们的StrBlob类只有一个数据成员，它是shared_ptr类型。因此，当我们拷贝、赋值或销毁一个StrBlob对象时，它的shared_ptr成员会被拷贝、赋值或销毁。

如前所见，拷贝一个shared_ptr会递增其引用计数；将一个shared_ptr赋予另一个shared_ptr会递增赋值号右侧shared_ptr的引用计数，而递减左侧shared_ptr的引用计数。如果一个shared_ptr的引用计数变为0，它所指向的对象会被自动销毁。因此，对于由StrBlob构造函数分配的vector，当最后一个指向它的StrBlob对象销毁时，它会随之被自动销毁。

### 12.1.2 直接管理内存

C++语言定义了两个运算符来分配和释放动态内存。运算符new分配内存，delete释放new分配的内存。

相对于智能指针，使用这两个运算符管理内存非常容易出错。而且，自己直接管理内存的类与使用智能指针的类不同，他们不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。

#### 使用new动态分配和初始化对象

在自由空间分配的内存是无名的，因此new无法为其分配的对象命名，而是返回一个指向该对象的指针：

```C++
int *pi = new int; // pi指向一个动态分配的、未初始化的无名对象
```

默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化：

```C++
string *ps = new string; // 初始化为空string
int *pi = new int; // pi指向一个未初始化的int
```

我们可以使用直接初始化方式来初始化一个动态分配的对象。我们可以使用传统的构造方式（使用圆括号），在新标准下，也可以使用列表初始化（使用花括号）：

```C++
int *pi = new int(1024); // pi指向的对象的值为1024
string *ps = new string(10, '9'); // *ps为"999999999"
vector<int> *pv = new vector<int>{0,1,2,3,4,5};
```

也可以对动态分配的对象进行值初始化，只需在类型名之后跟一对空括号即可：

```C++
string *ps1 = new string; // 默认初始化
string *ps = new string(); // 值初始化为空string
int *pi1 = new int; // 默认初始化
int *pi2 = new int(); // 值初始化
```

对于定义了自己的构造函数的类类型来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。

如果我们提供了一个括号包围的初始化器，就可以使用auto从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto：

```C++
auto p1 = new auto(obj); // p指向一个与obj类型相同的对象
													// 该对象用obj进行初始化
auto p2 = new auto{a,b,c}; // 错误：括号中只能有单个初始化器
```

p1的类型是一个指针，指向从obj自动推断出的类型。若obj是一个int，那么p1就是int \*；若obj是一个string，那么p1是一个string*；新分配的对象用obj的值进行初始化。

#### 动态分配的const对象

用new 分配const对象是合法的：

```C++
// 分配并初始化一个const int
const int *pci = new const int(1024);
// 分配并默认初始化一个const的空string
const string *pcs = new const string;
```

类似其他任何const对象，一个动态分配的const对象必须进行初始化。对于一个定义了默认构造函数的类类型，其const动态对象可以隐式初始化，而其他类型的对象就必须显示初始化。由于分配的对象是const的，new返回的指针是一个指向const的指针。

#### 内存耗尽

虽然现代计算机通常都配备大容量内存，但是自由空间被耗尽的情况还是有可能发生。一旦一个程序用光了它所有可用的内存，new表达式就会失败。默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc的异常。我们可以改变使用new的方式来阻止它抛出异常：

```C++
int *p1 = new int; // 如果分配失败，new抛出std::bad_alloc
int *p2 = new (nothrow) int; // 如果分配失败，new返回一个空指针
```

我们称这种形式的new为**定位new**。定位new表达式允许我们向new传递额外的参数。

#### 释放动态内存

为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过**delete表达式**来将动态内存归还给系统。delete表达式接受一个指针，指向我们想要释放的对象：

```C++
delete p; // p必须指向一个动态分配的对象或是一个空指针
```

与new类型类似，delete表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。

#### 指针值和delete

我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的：

```C++
int i, *pi1 = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;
delete i; // 错误： i不是一个指针
delete pi1; // 未定义：pi1指向一个局部变量
delete pd; // 正确
delete pd2; // 未定义：pd2指向的内存已经被释放了
delete pi2; // 正确： 释放一个空指针总是没有错误的
```

执行delete pi1和pd2所产生的错误则更具潜在危害：通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。

虽然一个const对象的值不能被改变，但它本身是可以被销毁的。如同任何其他动态对象一样，想要释放一个const动态对象，只要delete指向它的指针即可：

```C++
const int *pci = new const int(1024);
delete pci; // 正确：释放一个const对象
```

#### 动态对象的生存期直到被释放时为止

由shared_ptr管理的内存在最后一个shared_ptr销毁时会被自动释放。但对于通过内置指针类型来管理的内存，就不是这样了。对于一个由内置指针管理的动态对象，直到被显式释放之前它都是存在的。

返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存：

```C++
// factory返回一个指针，指向一个动态分配的对象
Foo *factory(T arg){
  return new Foo(arg); // 调用者负责释放此内存
}
```

factory的调用者负责在不需要此对象时释放它。不幸的是，调用者经常忘记释放对象：

```C++
void use_factory(T arg){
  Foo *p = factory(arg);
  // 使用p但不delete它
}// p离开了它的作用域，但它所指向的内存没有被释放！
```

当use_factory返回时，局部变量p被销毁。此变量是一个内置指针，而不是一个智能指针。

与类类型不同，内置类型的对象被销毁时什么也不会发生。特别是，当一个指针离开其作用域时，它所指向的对象什么也不会发生。如果这个指针指向的是动态内存，那么内存将不会被自动释放。

> Warning! 由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在。

在本例中，p是指向factory分配的内存的唯一指针。一旦use_factory返回，程序就没有办法释放这块内存了。

![](https://cdn.pkubailu.cn/img/动态内存管理非常容易出错-1.png)

![](https://cdn.pkubailu.cn/img/动态内存管理非常容易出错-2.png)

#### delete 之后重置指针值........

当我们delete一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。在delete之后，指针就变成了人们所说的**空悬指针**，即，指向一块曾经保存数据对象但现在已经无效的内存的指针。

未初始化指针的所有缺点空悬指针也都有。有一种方法可以避免空悬指针的问题：在指针即将要离开其作用域之前释放掉它所关联的内存。这样，在指针关联的内存被释放掉之后，就没有机会继续使用指针了。如果我们需要保留指针，可以在delete之后将nullptr赋予指针，这样就清楚地指出指针不指向任何对象。

#### .......这只是提供了有限的保护

动态内存的一个基本问题是可能有多个指针指向相同的内存。在delete内存之后重置指针的方法只针对这个指针有效，对其他任何仍指向（已释放的）内存的指针是没有作用的

```C++
int *p(new int(100));
auto q = p;
delete p; // p和q均变为无效
p = nullptr; // 指出p不再绑定到任何对象
```

本例中p和q指向相同的动态分配的对象。我们delete此内存，然后将p置为nullptr，指出它不再指向任何对象。但是，重置p对q没有任何作用，在我们释放p所指向的（同时也是q所指向的！）内存时，q也变为无效了。在实际系统中，查找指向相同内存的所有指针是异常困难的。

### 12.1.3 shared_ptr和new结合使用

如果我们不初始化一个智能指针，它就会被初始化为一个空指针。我们还可以用new返回的指针来初始化智能指针：

```C++
shared_ptr<double> p1;
shared_ptr<int> p2(new int(42)); // p2指向一个值为42的int
```

接受指针参数的智能指针构造函数是explicit的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针：

```C++
shared_ptr<int> p1 = new int(1024); // 错误：必须使用直接初始化形式
shared_ptr<int> p2(new int(1024)); // 正确：使用了直接初始化形式
```

p1的初始化隐式地要求编译器用一个new返回的int*来创建一个shared_ptr。由于我们不能进行内置指针到智能指针间的隐式转换，因此这条初始化语句是错误的。出于相同的原因，**一个返回shared_ptr的函数不能在其返回语句中隐式转换一个普通指针：**

```C++
shared_ptr<int> clone(int p){
	return new int(p); // 错误：隐式转换为shared_ptr<int>
}
```

我们必须将shared_ptr显式绑定到一个想要返回的指针上：

```c++
shared_ptr<int> clone(int p){
  // 正确：显式的用int*创建shared_ptr
	return shared_ptr<int> (new int(p)); 
}
```

默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。我们可以将智能指针绑定到一个指向其他类型的资源的指针上，但是为了这样做，必须提供自己的操作来代替delete。

![](https://cdn.pkubailu.cn/img/12.3-1.png)

![](https://cdn.pkubailu.cn/img/12.3-2.png)

#### 不要混合使用普通指针和智能指针......

shared_ptr可以协调对象的析构，但这仅限于其自身的拷贝（也是shared_ptr）之间。这也是为什么我们推荐使用make_shared而不是new的原因。这样，我们就能在分配对象的同时就将shared_ptr与之绑定，从而避免了无意中将同一块内存绑定到多个独立创建的shared_ptr上。

![](https://cdn.pkubailu.cn/img/混合使用普通指针和智能指针.png)

> Warning! 使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。

#### .......也不要使用get初始化另一个智能指针或为智能指针赋值

智能指针类型定义了一个名为get的函数，它返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况而设计的：我们需要向不能使用智能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针。

```C++
shared_ptr<int> p(new int(42)); // 引用计数为1
int *q = p.get(); // 正确：但使用q时要注意，不要让它管理的指针被释放
{
  // 未定义：两个独立的shared_ptr指向相同的内存
  shared_ptr<int>(q);
} // 程序块结束，q被销毁，它指向的内存被释放
int foo = *p; // 未定义：p指向的内存已经被释放了
```

在本例中，p和q指向相同的内存。由于它们是相互独立创建的，因此各自的引用计数都是1。当q所在的程序块结束时，q被销毁，这会导致q指向的内存被释放。从而p变成一个空悬指针，意味着当我们试图使用p时，将发生未定义的行为。而且，当p被销毁时，这块内存会被第二次delete。

> Warning! get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。

#### 其他shared_ptr 操作

我们可以用reset来将一个新的指针赋予一个shared_ptr：

```C++
p = new int(1024); // 错误：不能将一个指针赋予shared_ptr
p.reset(new int(1024)); // 正确：p指向一个新对象
```

与赋值类似，reset会更新引用计数，如果需要的话，会释放p指向的对象。reset成员经常与unique一起使用，来控制多个shared_ptr共享的对象。在改变底层对象之前，我们检查自己是否是当前对象仅有的用户。如果不是，在改变之前要制作一份新的拷贝：

```C++
if(!p.unique())
  p.reset(new string(*p)); // 我们不是唯一用户；分配新的拷贝
*p += newVal; // 现在我们知道自己是唯一的用户，可以改变对象的值
```

### 12.1.4 智能指针和异常

5.6.2节中介绍了使用异常处理的程序能在异常发生后令程序流程继续，我们注意到，这种程序需要确保在异常发生后资源能被正确的释放。一个简单的确保资源被释放的方法是使用智能指针。

如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放：

```C++
void f() {
  shared_ptr<int> sp(new int(42));
  // 这段代码抛出一个异常，且在f中未被捕获
}// 在函数结束时shared_ptr自动释放内存
```

函数的退出有两种可能，正常处理结束或者发生了异常，无论哪种情况，局部对象都会被销毁。在上面的程序中，sp是一个shared_ptr，因此sp销毁时会检查引用计数。在此例中，sp是指向这块内存的唯一指针，因此内存会被释放掉。

与之相对的，当发生异常时，我们直接管理得内存是不会自动释放的。如果使用内置指针管理内存，且在new之后在对应的delete之前发生了异常，则内存不会被释放：

```C++
void f() {
  int *ip = new int(42); 
  // 这段代码抛出一个异常，且在f中未被捕获
  delete ip;
}
```

如果在new和delete之间发生异常，且异常未在f中被捕获，则内存就永远不会被释放了。在函数f之外没有指针指向这块内存，因此就无法释放它了。

#### 智能指针和哑类

![](https://cdn.pkubailu.cn/img/智能指针和哑类.png)

#### 使用我们自己的释放操作

![](https://cdn.pkubailu.cn/img/删除器.png)

当p被销毁时，它不会对自己保存的指针执行delete，而是调用end_connection。接下来，end_connection会调用disconnect，从而确保链接被关闭。如果f正常退出，那么p的销毁会作为结束处理的一部分。如果发生了异常，p同样会被销毁，从而链接被关闭。

**智能指针陷阱**

智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：

- 不使用相同的的内置指针初始化（或reset）多个智能指针。
- 不delete get() 返回的指针。
- 不使用get() 初始化或reset另一个智能指针。
- 如果你使用get() 返回的指针，记住当最后一个对应的智能指针销毁后，你得指针就变为无效了。
- 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。

### 12.1.5 unique_ptr

一个unique_ptr“拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定的对象。当unique_ptr被销毁时，它所指向的对象也被销毁。

与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。当我们定义一个unique_ptr时，需要将其绑定到一个new返回的指针上。类似shared_ptr，初始化unique_ptr必须采用直接初始化形式：

```C++
unique_ptr<double> p1;
unique_ptr<int> p2(new int(42));
```

由于一个unique_ptr拥有它所指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作：

```C++
unique_ptr<string> p1(new string("Stegosaurus"));
unique_ptr<string> p2(p1) // 错误：unique_ptr不支持拷贝
unique_ptr<string> p3;
p3 = p2; // 错误：unique_ptr不支持赋值
```

![](https://cdn.pkubailu.cn/img/12.4.png)

虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique：

```C++
// 将所有权从p1(指向string Stegosaurus)转移给p2
unique_ptr<string> p2(p1.release()); // release将p1置为空
unique_ptr<string> p3(new string("trex"));
// 将所有权从p3转移给p2
p2.reset(p3.release()); // reset 释放了p2原来指向的内存
```

release成员返回unique_ptr当前保存的指针并将其置为空。因此，p2被初始化为p1原来保存的指针，而p1被置为空。

reset成员接受一个可选的指针参数，令unique_ptr重新指向给定的指针。如果unique_ptr不为空，他原来指向的对象被释放。因此，对p2调用reset释放了用"Stegosaurus"初始化的string所使用的内存，将p3对指针的所有权转移给了p2，并将p3置为空。

调用release会切断unique_ptr和它原来管理的对象间的联系。release返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。在本例中，管理内存的责任简单地从一个智能指针转移给另一个。但是，如果我们不用另一个智能指针来保存release返回的指针，我们的程序就要负责资源的释放：

```C++
p2.release(); // 错误：p2不会释放内存，而且我们丢失了指针
auto p = p2.realse(); // 正确，但我们必须记得delete p
```

#### 传递unique_ptr参数和返回unique_ptr

不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr：

```C++
unique_ptr<int> clone(int p) {
  // 正确：从int*创建一个unique_ptr<int>
  return unique_ptr<int>(new int(p));
}
```

还可以返回一个局部对象的拷贝：

```C++
unique_ptr<int> clone(int p) {
  unique_ptr<int> ret(new int(p));
  return ret;
}
```

对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”。

#### 向 unique_ptr 传递删除器

类似shared_ptr，unique_ptr默认情况下用delete释放它指向的对象。与shared_ptr一样，我们可以重载一个unique_ptr中默认的删除器。但是，unique_ptr管理删除器的方式与shared_ptr不同。

![](https://cdn.pkubailu.cn/img/向unique_ptr传递删除器.png)

### 12.1.6 weak_ptr

weak_ptr是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放，因此，weak_ptr的名字抓住了这种智能指针“弱”共享对象的特点。

![](https://cdn.pkubailu.cn/img/12.5.png)

当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它：

```C++
auto p = make_shared<int>(42);
weak_ptr<int> wp(p); // wp弱共享p:p的引用计数未改变
```

本例中wp和p指向相同的对象。由于是弱共享，创建wp不会改变p的引用计数；wp指向的对象可能被释放掉。

由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。此函数检查weak_ptr指向的对象是否仍存在。如果存在，lock返回一个指向共享对象的shared_ptr。与任何其他shared_ptr类似，只要此shared_ptr存在，它所指向的底层对象也就会一直存在。

```C++
if(shared_ptr<int> np = wp.lock()){ // 如果np不为空则条件成立
  // 在if中，np与p共享对象
}
```

在这段代码中，只有当lock调用返回true时我们才会进入if语句体。在if中，使用np访问共享对象是安全的。

#### 核查指针类

作为weak_ptr用途的一个展示，我们将为StrBlob类定义一个伴随指针类。我们的指针类命名为StrBlobPtr，会保存一个weak_ptr，指向StrBlob的data成员，这是初始化时提供给它的。通过使用weak_ptr，不会影响一个给定的StrBlob所指向的vector的生存期。但是，可以阻止用户访问一个不再存在的vector的企图。

![](https://cdn.pkubailu.cn/img/核查指针类.png)

#### 指针操作

定义名为 deref 和 incr 的函数，分别用来解引用和递增StrBlobPtr。

![](https://cdn.pkubailu.cn/img/指针操作.png)

## 12.2 动态数组

new和delete运算符一次分配/释放一个对象，但某些应用需要依次为很多对象分配内存的功能。

为了支持这种需求，C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。

> 大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容器出现内存管理错误并且可能有更好的性能。

使用容器的类可以使用默认版本的拷贝、赋值和析构操作。分配动态数组的类则必须定义自己版本的操作，在拷贝 、赋值以及销毁对象时管理所关联的内存。

### 12.2.1 new 和数组

为了让new 分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。

```C++
// 调用 get_size确定分配多少个int
int *pia = new int[get_size()]; // pia指向第一个int
```

方括号中的大小必须是整型，但不必是常量。

也可以用一个表示数组类型的类型别名来分配一个数组，这样，new表达式中就不需要方括号了：

```C++
typedef int arrT[42]; // arrT表示42个int的数组类型
int *p = new arrT; // 分配一个42个int的数组；p指向第一个int
```

#### 分配一个数组会得到一个元素类型的指针

虽然我们通常称new T[] 分配的内存为“动态数组”，但这种叫法某种程度上有些误导。当用new分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。即使我们使用类型别名定义了一个数组类型，new也不会分配一个数组类型的对象。new返回的是一个元素类型的指针。

由于分配的内存并不是一个数组类型，因此也不能对动态数组调用begin或end。这些函数使用数组维度（维度是数组类型的一部分）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围 for 语句来处理（所谓的）动态数组中的元素。

> Warning! 要记住我们所说的动态数组并不是数组类型，这是很重要的。

#### 初始化动态分配对象的数组

默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。

```C++
int *pia = new int[10]; // 10个未初始化的int
int *pia2 = new int[10](); // 10个值初始化为0的int
string *psa = new string[10]; // 10个空string
string *psa2 = new string[10](); // 10个空string
```

在新标准中，我们还可以提供一个元素初始化器的花括号列表：

```C++
// 10个int分别用列表中对应的初始化器初始化
int *pia3 = new int[5]{1,2,3,4,5}; 
// 10个string，前4个用给定的初始化器初始化，剩余的进行值初始化
string *psa3 = new string[10]{"a","an","the",string(3,"x")};
```

虽然我们用空括号对数组中元素进行值初始化，但不能在括号中给出初始化器，这意味着不能用auto分配数组。

#### 动态分配一个空数组是合法的

可以用任意表达式来确定要分配的对象的数目：

```C++
size_t n = get_size(); // get_size返回需要的元素的数目
int *p = new int[n]; // 分配数组保存元素
for(int *q = p; q != p + n; ++q)
  // 处理数组
```

这产生了一个有意思的问题：如果get_size返回0，会发生什么？答案是代码仍能正常工作。虽然我们不能创建一个大小为0的静态数组，但当n等于0时，调用 new[n]是合法的：

```C++
char arr[0]; // 错误：不能定义长度为0的数组
char *cp = new char[0]; // 正确：但cp不能解引用
```

当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针。此指针保证与new返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样，我们可以像使用尾后迭代器一样使用这个指针。可以用此指针进行比较操作，就像上面循环代码中那样。可以向此指针加上（或从此指针减去）0，也可以从此指针减去自身从而得到0。但此指针不能解引用——毕竟它不指向任何元素。

#### 释放动态数组

为了释放动态数组，我们是用一种特殊形式的delete——在指针前面加上一个空方括号对：

```C++
delete p; // p必须指向一个动态分配的对象或为空
delete [] pa; // pa必须指向一个动态分配的数组或为空
```

第二条语句销毁pa指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。

当我们释放一个指向数组的指针时，空方括号对是必需的：它指示编译器此指针指向一个对象数组的第一个元素。如果我们在delete一个指向数组的指针时忽略了方括号（或者在delete一个指向单一对象的指针时使用了方括号），其行为是未定义的。

当我们使用一个类型别名来定义一个数组类型时，在new表达式中不使用[]。即使是这样，在释放一个数组指针时也必须使用方括号：

```C++
typedef int arrT[42]; // arrT表示42个int的数组类型
int *p = new arrT; // 分配一个42个int的数组；p指向第一个int
delete [] p; // 方括号是必须的，因为我们当初分配的是一个数组
```

不管外表如何，p指向一个对象数组的首元素，而不是一个类型为arrT的单一对象。因此，在释放p时我们必须使用[]。

> 如果我们在delete一个数组指针时忘记了方括号，或者在delete一个单一对象的指针时使用了方括号，编译器很可能不会给出警告。我们的程序可能在执行过程中在没有任何警告的情况下行为异常

#### 智能指针和动态数组

标准库提供了一个可以管理new 分配的数组的 unique_ptr 版本。为了用一个 unique_ptr 管理动态数组，我们必须在对象类型后面跟一对空方括号：

```C++
// up指向一个包含10个未初始化int的数组
unique_ptr<int[]> up(new int[10]);
up.release(); // 自动用delete[] 销毁其指针
```

类型说明符中的方括号（<int []>）指出up指向一个int数组而不是一个int。由于up指向一个数组，当up销毁它管理的指针时，会自动使用delete[]。

指向数组的unique_ptr提供的操作与我们在12.1.5节中使用的那些操作有一些不同，当一个unique_ptr指向一个数组时，我们不能使用点和箭头成员运算符。毕竟unique_ptr指向的是一个数组而不是单个对象，因此这些运算符是无意义的。另一方面，当一个unique_ptr指向一个数组时，我们可以使用下标运算符来访问数组中的元素：

```C++
for(size_t i = 0; i != 10; ++i)
  up[i] = i; // 为每个元素赋予一个新值
```

![](https://cdn.pkubailu.cn/img/12.6.png)

与unique_ptr 不同，shared_ptr 不直接支持管理动态数组。如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器：

```C++
// 为了使用 shared_ptr，必须提供一个删除器
shared_ptr<int> sp(new int[10], [](int *p) { delete []p; });
sp.reset(); // 使用我们提供的lambda释放数组，他使用delete[]
```

本例中我们传递给shared_ptr一个lambda作为删除器，它使用delete[]释放数组。

如果未提供删除器，这段代码将是未定义的。默认情况下，shared_ptr使用delete销毁它指向的对象。如果此对象是一个动态数组，对其使用delete所产生的问题与释放一个动态数组指针时忘记[]产生的问题一样。

shared_ptr不直接支持动态数组管理这一特性会影响我们如何访问数组中的元素：

```C++
// shared_ptr 未定义下标运算符，并且不支持指针的算术运算
for(size_t i = 0; i != 10; ++i)
  *(sp.get() + i) = i; // 使用get获取一个内置指针
```

shared_ptr未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访问数组中的元素，必须用get获取一个内置指针，然后用它来访问数组元素。

### 12.2.2 allocator 类

new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。我们分配单个对象时，通常希望将内存分配和对象初始化组合在一起。因为在这种情况下，我们几乎肯定知道对象应有什么值。

当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定的开销）。

一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费。

```C++
string *const p = new string[n]; // 构造n个空string
string s;
string *q = p; // q指向第一个string
while(cin >> s && q != p + n)
  *q++ = s; // 赋予*q一个新值
const size_t size = q - p; // 记住我们读取了多少个string
// 使用数组
delete [] p;
```

new 表达式分配并初始化了n个string。但是，我们可能不需要n个string，少量string可能就够了。这样，我们就可能创建了一些永远也用不到的对象。而且，对于那些确实要使用的对象，我们也在初始化之后立即赋予了它们新值。每个使用到的元素都被赋值了两次：第一次是在默认初始化时，随后是在赋值时。

更重要的是，那些没有默认构造函数的类就不能动态分配数组了。

#### allocator 类

标准库allocator类帮助我们将内存和对象构造分离开来。它提供一种类型感知的内存分配方法，他分配的内存是原始的、未构造的。

类似vector，allocator是一个模板。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当地内存大小和对齐位置：

```C++
allocator<string> alloc; // 可以分配string的allocator对象
auto const p = alloc.allocate(n); // 分配n个未初始化的string
```

![](https://cdn.pkubailu.cn/img/12.7.png)

#### allocator 分配未构造的内存

allocator分配的内存是未构造的。我们按需要在此内存中构造对象。在新标准库中，construct成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。类似make_shared的参数，这些额外参数必须是与构造的对象的类型相匹配的合法的初始化器：

```C++
auto q = p; // q指向最后构造的元素之后的位置
alloc.construct(q++); // *q为空字符串
alloc.construct(q++, 10, 'c'); // *q为cccccccccc
alloc.construct(q++, "hi"); // *q为hi
```

在早期版本的标准库中，construct只接受两个参数：指向创建对象位置的指针和一个元素类型的值。因此，我们只能将一个元素拷贝到未构造空间中，而不能用元素类型的任何其他构造函数来构造一个元素。

```C++
// 还未构造对象的情况下就使用原始内存是错误的
cout << *p << endl; // 正确：使用string的输出运算符
cout << *q << endl; // 灾难： q指向未构造的内存
```

> Warning! 为了使用allocator返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的。

当我们用完对象后，必须对每个构造的元素调用destory来销毁它们。函数destory接受一个指针，对指向的对象执行析构函数：

```C++
while(q != p)
  alloc.destroy(--q); // 释放我们真正构造的string
```

在循环开始出，q指向最后构造的元素之后的位置。我们在调用destroy之前对q进行了递减操作。因此，第一次调用destroy时，q指向最后一个构造的元素。最后一步循环中我们destroy了第一个构造的元素，随后q将与p相等，循环结束。

> Warning! 我们只能对真正构造了的元素进行destroy操作。

一旦元素被销毁后，就可以重新使用这部分内存来保存其他string，也可以将其归还给系统。释放内存通过调用deallocate来完成：

```C++
alloc.deallocate(p, n);
```

我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。

#### 拷贝和填充未初始化内存的算法

标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。

![](https://cdn.pkubailu.cn/img/12.8.png)

作为一个例子，假定有一个int的vector，希望将其内容拷贝到动态内存中。我们将分配一块比vector中元素所占用空间大一倍的动态内存，然后将原vector中的元素拷贝到前一半空间，对后一半空间用一个给定值进行填充：

```C++
// 分配比vi中元素所占用空间大一倍的动态内存
auto p = alloc.allocate(vi.seze() * 2);
// 通过拷贝vi中的元素来构造从p开始的元素
auto q = uninitialized_copy(vi.begin(), vi.end(), p);
// 将剩余元素初始化为42
uninitialized_fill_n(q, vi.size(), 42);
```

类似拷贝算法，uninitialized_copy接受三个迭代器参数。前两个表示输入序列，第三个表示这些元素将要拷贝到的目的空间。传递给uninitialized_copy的目的位置迭代器必须指向未构造的内存。与copy不同，uninitialized_copy在给定目的位置构造元素。

类似copy，uninitialized_copy返回（递增后的）目的位置迭代器。因此，一次uninitialized_copy调用会返回一个指针，指向最后一个构造的元素之后的位置。在本例中，我们将此指针保存在q中，然后将q传递给uninitialized_fill_n。此函数类似fill_n，接受一个指向目的位置的指针、一个记数和一个值。他会在目的位置指针指向的内存中创建给定数目个对象，用给定值对他们进行初始化。

## 12.3 使用标准库：文本查询程序



# 第 13 章 拷贝控制

当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：**拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数**。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为**拷贝控制操作**。

如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。但是，对一些类来说，依赖这些操作的默认会导致灾难。

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

如果一个构造函数的第一个参数是自身类类型的引用，**且任何额外参数都有默认值**，则此构造函数是拷贝构造函数。

```C++
class Foo {
  public:
  Foo(); // 默认构造函数
  Foo(const Foo&); // 拷贝构造函数
}
```

拷贝构造函数的第一个参数必须是一个引用类型。虽然我们可以定义一个接受非 const 引用的拷贝构造函数，但此参数几乎总是一个const 的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是explicit的。

#### 合成拷贝构造函数

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。

对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非 static 成员拷贝到正在创建的对象中。

每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐个元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行 拷贝。

![](https://cdn.pkubailu.cn/img/合成拷贝构造函数.png)

当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用**拷贝初始化**时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

拷贝初始化通常使用拷贝构造函数来完成。但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。

拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。

#### 参数和返回值

在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用法的结果。

拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。

#### 拷贝初始化的限制

如前所述，如果我们使用的初始化值要求通过一个explicit的构造函数来进行类型转换，那么使用拷贝构造初始化还是直接初始化就不是无关紧要的了：

```C++
vector<int> v1(10); // 正确：直接初始化
vector<int> v2 = 10; // 错误：接受大小参数的构造函数是explicit的
void f(vector<int>); // f的参数进行拷贝初始化
f(10); // 错误：不能用一个explicit的构造函数拷贝一个实参
f(vector<int>(10)); // 正确： 从一个int直接构造一个临时vector
```

直接初始化v1是合法的，但是看起来与之等价的拷贝初始化v2则是错误的，因为vector的接收单一大小参数的构造函数是explicit的。出于同样的原因，当传递一个实参或从函数返回一个值时，我们不能隐士使用一个explicit构造函数。如果我们希望使用一个explicit构造函数，就必须显示地使用，像代码中最后一行那样。

#### 编译器可以绕过拷贝构造函数

在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝、移动构造函数，直接创建对象。即，编译器允许将下面的代码

```C++
string null_book = "9-999-9999"; // 拷贝初始化
// 改写为
string null_book("9-999-9999"); // 编译器略过了拷贝构造函数
```

但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的（例如，不能是 private 的）。

### 13.1.2 拷贝赋值运算符

与类控制其对象如何初始化一样，类也可以控制其对象如何赋值：

```C++
Sales_data trans, accum;
trans = accum; // 使用 Sales_data 的拷贝赋值运算符
```

与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

#### 重载赋值运算符

重载运算符本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为 operator= 的函数。类似于任何其他函数，运算符也有一个返回类型和一个参数列表。

重载运算符的参数表示运算符的运算对象。**某些运算符，包括赋值运算符，必须定义为成员函数**。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 this 参数。对于一个二元运算符，比如赋值运算符，其右侧运算对象作为显示参数传递。

拷贝赋值运算符接受一个与其所在类相同类型的参数：

```C++
class Foo {
  public:
  Foo& operator=(const Foo&); // 赋值运算符
}
```

为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。另外值得注意的是，**标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。**

> Note! 赋值运算符通常应该返回一个指向其左侧运算对象的引用。

#### 合成拷贝赋值运算符

与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**。类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的每个非 static 成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

作为一个例子，下面的代码等价于 Sales_data 的合成拷贝赋值运算符：

```C++
// 等价于合成拷贝赋值运算符
Sales_data&
Sales_data::operator=(const Sales_data &rhs){
  bookNo = rhs.bookNo; // 调用 string::operator=
  units_sold = rhs.units_sold;
  revenue = rhs.revenue;
  return *this;
}
```

### 13.1.3 析构函数

析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static成员。

析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数：

```C++
class Foo {
  public:
  ~Foo(); // 析构函数
};
```

由于析构函数不接收参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。

#### 析构函数完成什么工作

如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，**首先执行函数体，然后销毁成员**，成员按初始化顺序的逆序销毁。

在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。

在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时发生什么完全依赖与成员的类型。销毁类类型成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。

> Note! 隐式销毁一个内置指针类型的成员不会delete他所指向的对象。

与普通指针不同，智能指针是类类型，所以具有析构函数。因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁。

#### 什么时候会调用析构函数

无论何时一个对象被销毁，就会自动调用其析构函数：

- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。
- 对于动态分配的对象，当对指向他的指针应用delete运算符时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁

由于析构函数自动运行，我们的程序可以按需要分配资源，而（通常）无须担心何时释放这些资源。

> Note! 当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

#### 合成析构函数

当一个类未定义自己的析构函数时，编译器会为它定义一个**合成析构函数**。类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。

```C++
// 例如，下面的代码片段等价于Sales_data的合成析构函数
class Sales_data {
  public:
  ~Sales_data() {}
};
```

在（空）析构函数体执行完毕后，成员会被自动销毁。特别的，string的析构函数会被调用，它将释放bookNo成员所用的内存。

认识到析构函数体本身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。

### 13.1.4 三/五法则

#### 需要析构函数的类也需要拷贝和赋值操作

当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显。如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。

![](https://cdn.pkubailu.cn/img/HasPtr只有析构函数.png)

在这个版本的类定义中，构造函数中分配的内存将在HasPtr对象销毁时被释放。但不幸的是，我们引入了一个严重的错误！这个版本的类使用了合成的拷贝构造函数和拷贝赋值运算符。这些函数简单拷贝指针成员，这意味着多个HasPtr对象可能指向相同的内存：

```C++
HasPtr f(HasPtr hp){ // HasPtr是传值参数，所以将被拷贝
  HasPtr ret = hp; // 拷贝给定的HasPtr
  // 处理 ret
  return ret; // ret 和 hp被销毁
}
```

当f返回时，hp和ret都被销毁，在两个对象上都会调用HasPtr的析构函数。此析构函数会delete ret和hp中的指针成员。但这两个对象包含相同的指针。此代码会导致此指针被delete两次，这显然是一个错误。将要发生什么是未定义的。

此外，f的调用者还会使用传递给f的对象：

```C++
HasPtr p("some values");
f(p); // 当f结束时，p.ps指向的内存被释放
HasPtr p(q); // 现在p和q都指向无效内存！
```

p(以及q)指向的内存不再有效，在hp（或ret!）销毁时它就被归还给系统了。

> Note! 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符。

#### 需要拷贝操作的类也需要赋值操作，反之亦然

虽然很多类需要定义所有（或是不需要定义任何）拷贝控制成员，但某些类所要完成的工作，只需要拷贝或赋值操作，不需要析构函数。

作为一个例子，考虑一个类为每个对象分配一个独有的、唯一的序号。这个类需要一个拷贝构造函数为每个新创建的对象生成一个新的、独一无二的序号。除此之外，这个拷贝构造函数从给定对象拷贝所有其他数据成员。这个类还需要自定义拷贝赋值运算符来避免将序号赋予目的对象。但是，这个类不需要自定义析构函数。

这个类引出了第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然！然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。

### 13.1.5 使用=default

我们可以通过将拷贝控制成员定义为=default来显示的要求编译器生成合成的版本：

```C++
class Sales_data {
  public:
  Sales_data() = default;
  Sales_data(const Sales_data&) = default;
  Sales_data& operator=(const Sales_data &);
  ~Sales_data() = default;
};
Sales_data& Sales_data::operator=(const Sales_data&) = default;
```

当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样。

> Note! 我们只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）。

### 13.1.6 阻止拷贝

> Note! 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。

虽然大多数类应该定义（而且通常也定义了）拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的：如果我们的类未定义这些操作，编译器为它生成合成的版本。

#### 定义删除的函数

在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数**来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的：

```C++
struct NoCopy {
  NoCopy() = default; // 使用合成的默认构造函数
  NoCopy(const NoCopy&) = delete; // 阻止拷贝
  NoCopy &operator=(const NoCopy&) = delete; // 阻止赋值
  ~NoCopy() = default; // 使用合成的析构函数
};
```

=delete通知编译器（以及我们代码的读者），我们不希望定义这些成员。

**与=default不同，=delete必须出现在函数第一次声明的时候**，这个差异与这些声明的含义在逻辑上是吻合的。一个默认的成员只影响为这个成员而生成的代码，因此=default直到编译器生成代码时才需要。另一方面，编译器需要知道一个函数是删除的，以便禁止试图使用它的操作。

**与=default的另一个不同之处是，我们可以对任何函数指定=delete（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）**。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。

#### 析构函数不能是删除的成员

值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类型的临时对象。而且，如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。因为如果一个成员的析构函数是删除的，则该成员无法被销毁。而如果一个成员无法被销毁，则对象整体也就无法被销毁了。

对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象：

```C++
struct NoDtor {
  NoDtor() = default; // 使用合成的默认构造函数
  ~NoDtor() = delete; // 我们不能销毁NoDtor类型的对象
}
NoDtor nd; // 错误：NoDtor的析构函数是删除的
NoDtor *p = new NoDtor(); // 正确：但我们不能delete p
delete p; // 错误：NoDtor的析构函数是删除的
```

> Note! 对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。

#### 合成的拷贝控制成员可能是删除的

如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。类似的，如果一个类未定义构造函数，编译器会为其合成一个默认构造函数。对某些类来说，编译器将这些合成的成员定义为删除的函数：

- 如果类的某个成员的析构函数是删除的或不可访问的（例如，是private的），则类的合成析构函数被定义为删除的。
- 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。
- 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除的。

本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应的成员函数将被定义为删除的。

一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，这看起来可能有些奇怪。其原因是，如果没有这条原则，我们可能会创建出无法销毁的对象。

对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数，这应该不奇怪。同样不出人意料的规则是：如果一个类有const成员，则它不能使用合成的拷贝赋值运算符。毕竟，此运算符试图赋值所有成员，而将一个新值赋予一个const对象是不可能的。

虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

> Note! 本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。

#### private 拷贝控制

在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝：

```C++
class PrivateCopy {
  // 拷贝控制成员是private的，因此普通用户代码无法访问
  PrivateCopy(const PrivateCopy&);
  PrivateCopy &operator=(const PrivateCopy&);
public:
  PrivateCopy() = default;
  ~PrivateCopy(); // 用户可以定义此类型的对象，但无法拷贝它们
}
```

由于析构函数是public的，用户可以定义PrivateCopy类型的对象。但是，由于拷贝构造函数和拷贝赋值运算符是private的，用户代码将不能拷贝这个类型的对象。但是，友元和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为private的，但并不定义它们。

声明但不定义一个成员函数是合法的，对此只有一个例外。试图访问一个未定义的成员将导致一个连接时错误。通过声明（但不定义）private的拷贝构造函数，我们可以预先阻止任何拷贝此类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误：成员函数或友元函数中的拷贝操作将会导致连接时错误。

> Note! 希望阻止拷贝的类应该使用=delete 来定义他们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的。

## 13.2 拷贝控制和资源管理

通常，管理类外资源的类必须定义拷贝控制成员。这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。

为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。

类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值得对象时，副本和源对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。

行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和源对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

在我们使用过的标准库类中，标准库容器和string类的行为像一个值。而不出意外地，shared_ptr类提供类似指针的行为，就像我们的StrBlob类一样，IO类型和unique_ptr不允许拷贝或赋值，因此它们的行为既不像值也不像指针。

为了说明这两种方式，我们会为练习中的HasPtr类定义拷贝控制成员。首先，我们将令类的行为像一个值；然后重新实现类，使它的行为像一个指针。

我们的HasPtr类有两个成员，一个int和一个string指针。通常，类直接拷贝内置类型（不包括指针）成员；这些成员本身就是值，因此通常应该让它们的行为像值一样。我们如何拷贝指针成员决定了像HasPtr这样的类是具有类值行为还是类指针行为。

### 13.2.1 行为像值的类

为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。这意味着对于ps指向的string，每个HasPtr对象都必须有自己的拷贝。为了实现类值行为，HasPtr需要

- 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针
- 定义一个析构函数来释放string
- 定义一个拷贝赋值运算符来释放对象当前的string，并从右侧运算对象拷贝string。

类值版本的HasPtr如下所示

```C++
class HasPtr {
public:
  HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0) {}
  // 对ps指向的string，每个HasPtr对象都有自己的拷贝
  HasPtr(const HasPtr &p): ps(new std::string(*p.ps)), i(p.i) {}
  HasPtr &operator=(cosnt HasPtr &);
  ~HasPtr() {delete ps}
private:
  std::string *ps;
  int i;
};
```

我们的类足够简单，在类内就已定义了除赋值运算符之外的所有成员函数。第一个构造函数接受一个（可选的）string参数。这个构造函数动态分配它自己的string副本，并将指向string的指针保存在ps中。拷贝构造函数也分配他自己的string副本。析构函数对指针成员ps执行delete，释放构造函数中分配的内存。

#### 类值拷贝赋值运算符

赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。但是，非常重要的一点是，这些操作是以正确的顺序执行的，即使将一个对象赋予它自身，也保证正确。而且，如果可能，我们编写的赋值运算符还应该是异常安全的——当发生异常时能将左侧运算对象置于一个有意义的状态。

在本例中，通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证在异常发生时代码也是安全的。在完成拷贝后，我们释放左侧运算对象的资源，并更新指针指向新分配的string：

```C++
HasPtr & HasPtr::operator=(const HasPtr &p) {
  auto newp = new std::string(*p.ps);
  delete ps; // 释放旧内存
  ps = newp; // 从右侧运算对象拷贝数据到本对象
  i = p.i;
  return *this;
}
```

在这个赋值运算符中，非常清楚，我们首先进行了构造函数的工作：newp的初始化器等价于HasPtr 的拷贝构造函数中ps的初始化器。接下来与析构函数一样，我们delete当前ps指向的string。然后就只剩下拷贝指向新分配的string的指针，以及从p拷贝int值到本对象了。

> **关键概念**
>
> 当你编写赋值运算符时，有两点需要记住：
>
> - 如果将一个对象赋予它自身，赋值运算符必须能正确工作。
> - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。
>
> 当你编写一个赋值运算符时，一个好的模式是将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。

为了说明防范自赋值操作的重要性，考虑如果赋值运算符如下编写将会发生什么

```C++
HasPtr & HasPtr::operator=(const HasPtr &p) {
  delete ps; // 释放对象指向的string
  ps = new std::string(*p.ps);
  i = p.i;
  return *this;
}
```

如果p和本对象是同一个对象，delete ps会释放 *this 和 rhs 指向的 string。接下来，当我们在 new 表达式中试图拷贝 *(p.ps) 时，就会访问一个指向无效内存的指针，其行为和结果是未定义。

> Warnning! 对于一个赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也要能正常工作。一个好的方法是在销毁左侧对象资源之前拷贝右侧运算对象。

### 13.2.2 定义行为像指针的类

对于行为像指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的string。我们的类仍然需要自己的析构函数来释放接受string参数的构造函数分配的内存。但是，在本例中，析构函数不能单方面的释放关联的string。只有当最后一个指向string的HasPtr销毁时，他才可以释放string。

令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。拷贝（或赋值）一个shared_ptr会拷贝（赋值）shared_ptr所指向的指针。shared_ptr 类自己记录有多少用户共享它所指向的对象。当没有用户使用对象时，shared_ptr 类负责释放资源。

但是，有时我们希望直接管理资源。在这种情况下，使用**引用计数**就很有用了。为了说明引用计数如何工作，我们将重新定义HasPtr，令其行为像指针一样，但我们不使用 shared_ptr，而是设计自己的引用计数。

#### 引用计数

引用计数的工作方式如下：

- 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。
- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。
- 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。
- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。

唯一的难题是确定在哪里存放引用计数。计数器不能直接作为HasPtr 对象的成员。

下面的例子说明了原因：

```C++
HasPtr p1("hiya!");
HasPtr p2(p1);
HasPtr p3(p1); // p1 p2 p3 都指向相同的 string
```

如果引用计数保存在每个对象中，当创建p3时我们应该如何正确更新它呢？可以递增p1中的计数器并将其拷贝到p3中，但如何更新p2中的计数器呢？

解决此问题的一种方法是将计数器保存在动态内存中。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。

#### 定义一个使用引用计数的类

通过使用引用计数，我们就可以编写类指针的HasPtr版本了：

```C++
class HasPtr {
public:
  HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0), use(new std::size_t(1)) {}
  // 对ps指向的string，每个HasPtr对象都有自己的拷贝
  HasPtr(const HasPtr &p): ps(p.ps), i(p.i), use(p.use) {++*use;}
  HasPtr &operator=(cosnt HasPtr &);
  ~HasPtr();
private:
  std::string *ps;
  int i;
  std::size_t *use; // 用来记录有多少个对象共享*ps的成员
};
```

在此，我们添加了一个名为use的数据成员，它记录有多少对象共享相同的string。接受string参数的构造函数分配新的计数器，并将其初始化为1，指出当前有一个用户使用本对象的string成员。

#### 类指针的拷贝成员“篡改”引用计数

当拷贝或赋值一个HasPtr对象时，我们希望副本和原对象都指向相同的string。即，当拷贝一个HasPtr时，我们将拷贝ps本身，而不是ps指向的string。当我们进行拷贝时，还会递增该string关联的计数器。

（我们在类内定义的）拷贝构造函数拷贝给定HasPtr的所有三个数据成员。这个构造函数还递增use成员，指出ps和p.ps指向的string又有了一个新的用户。

析构函数不能无条件的delete ps——可能还有其他对象指向这块内存。析构函数应该递减引用计数，指出共享string的对象少了一个。如果计数器变为0，则析构函数释放ps和use指向的内存：

```C++
HasPtr::~HasPtr() {
  if(--*use == 0) {
    delete ps; // 释放string 内存
    delete use; // 释放计数器内存
  }
}
```

拷贝赋值运算符与往常一样执行类似拷贝构造函数和析构函数的工作。即，它必须递增右侧运算对象的引用计数（即，拷贝构造函数的工作），并递减左侧运算对象的引用计数，在必要时释放使用的内存（即，析构函数的工作）。

而且与往常一样，赋值运算符必须处理自符值。我们通过先递增 rhs 中的计数然后再递减左侧运算对象中的计数来实现这一点。通过这种方法，当两个对象相同时，在我们检查ps（及use）是否应该释放之前，计数器就已经被递增过了：

```C++
HasPtr & HasPtr::operator=(const HasPtr &rhs) {
  ++*rhs.use;
  if(--*use == 0) {
    delete ps;
    delete use;
  }
  ps = rhs.ps;
  i = rhs.i;
  use = rhs.use;
  return *this;
}
```

## 13.3 交换操作

除了定义拷贝控制成员，管理资源的类通常还定义一个名为swap的函数。对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap。

如果一个类定义了自己的swap，那么算法将使用类自定义版本。否则，算法将使用标准库定义的swap。虽然与往常一样我们不知道swap是如何实现的，但理论上很容易理解，为了交换两个对象我们需要进行一次拷贝和两次赋值。例如，交换两个类值HasPtr对象的代码可能像下面这样：

```C++
HasPtr temp = v1;
v1 = v2;
v2 = temp;
```

这段代码将原来v1中的string拷贝了两次——第一次是HasPtr的拷贝构造函数将v1拷贝给temp，第二次是赋值运算符将temp赋予v2。将v2赋予v1的语句还拷贝了原来v2中的string。如我们所见，拷贝一个类值的HasPtr会分配一个新string并将其拷贝到HasPtr指向的位置。

理论上，这些内存分配都是不必要的。我们更希望 swap 交换指针，而不是分配string的新副本。即，我们希望这样交换两个HasPtr：

```C++
string *temp = v1.ps;
v1.ps = v2.ps;
v2.ps = temp;
```

#### 编写我们自己的 swap 函数

可以在我们的类上定义一个自己版本的 swap 来重载 swap 的默认行为。swap 的典型实现如下：

```C++
class HasPtr {
  friend void swap(HasPtr&, HasPtr&);
  // 其他成员定义
};
inline void swap(HasPtr &lhs, HasPtr &rhs){
  using std::swap;
  swap(lhs.ps, rhs.ps); // 交换指针，而不是string数据
  swap(lhs.i, rhs.i); // 交换int成员
}
```

我们首先将swap定义为friend，以便能访问HasPtr的（private的）数据成员。由于swap的存在就是为了优化代码，我们将其声明为inline函数。swap的函数体对给定对象的每个数据成员调用。我们首先 swap 绑定到 rhs 和 lhs 的对象的指针成员，然后是int成员。

> 与拷贝控制成员不同，swap 并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。

#### swap 函数应该调用 swap，而不是std::swap

此代码中有一个很重要的微妙之处：虽然这一点在这个特殊的例子中并不重要，但在一般情况下它非常重要——swap 函数中调用的 swap 不是 std::swap。在本例中，数据成员是内置类型的，而内置类型是没有特定版本的 swap 的，所以在本例中，对 swap 的调用会调用标准库 std::swap。

但是，如果一个类的成员有自己类型特定的 swap 函数，调用 std::swap 就是错误的了。例如，假定我们有另一个命名为 Foo 的类，它有一个类型为HasPtr的成员h。如果我们未定义 Foo 版本的 swap，那么就会使用标准库版本的 swap。如我们所见，标准库 swap 对 HasPtr 管理的 string 进行了不必要的拷贝。

我们可以为Foo编写一个 swap 函数，来避免这些拷贝。但是，如果这样编写 Foo 版本的 swap：

```C++
void swap(Foo &lhs, Foo &rhs) {
  // 错误：这个函数是用了标准库版本的swap，而不是 HasPtr 版本
  std::swap(lhs.h, rhs.h);
}
```

此编码会编译通过，且正常运行。但是，使用此版本与简单使用默认版本的  swap 并没有任何性能差异。问题在于我们显示地调用了标准库版本的 swap。但是，我们不希望使用 std 中的版本，我们希望调用为 HasPtr 对象定义的版本。

正确的 swap 函数如下所示：

```C++
void swap(Foo &lhs, Foo &rhs) {
  using std::swap;
  swap(lhs.h, rhs.h); // 使用 HasPtr 版本的 swap
}
```

每个 swap 调用应该都是未加限定的。即，每个调用都应该是 swap,而不是 std::swap。如果存在类型特定的 swap 版本，其匹配程度会优于 std 中定义的版本。因此，如果存在类型特定的 swap 版本，swap 调用会与之匹配。如果不存在类型特定的版本，则会调用 std 中的版本（假定作用域中有 using 声明）。

非常仔细的读者可能会奇怪为什么 swap 函数中的 using 声明没有隐藏 HasPtr 版本 swap 的声明。

#### 在赋值运算符中使用 swap 

定义 swap 的类通常用 swap 来定义他们的赋值运算符。这些运算符使用了一种名为**拷贝并交换**的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换：

```C++
// 注意rhs是按值传递的，意味着HasPtr 的拷贝构造函数
// 将右侧运算对象中的 string 拷贝到 rhs
HasPtr& HasPtr::operator=(HasPtr rhs) {
  // 交换左侧运算对象和局部变量 rhs 的内容
  swap(*this, rhs); // rhs 现在指向本对象曾经使用的内存
  return *this; // rhs 被销毁，从而delete 了rhs中的指针
}
```

在这个版本的赋值运算符中，参数并不是一个引用，我们将右侧运算对象以传值方式传递给了赋值运算符。因此，rhs 是右侧运算对象的一个副本。参数传递时拷贝 HasPtr 的操作会分配该对象的 string 的一个新副本。

在赋值运算符的函数体中，我们调用 swap 来交换 rhs 和 *this 中的数据成员。这个调用将左侧运算对象中原来保存的指针存入 rhs 中，并将 rhs 中原来的指针存入 *this 中。因此，在 swap 调用之后，\*this 中的指针成员将指向新分配的 string——右侧运算对象中 string 的一个副本。

当赋值运算符结束时，rhs 被销毁，HasPtr的析构函数将执行。此析构函数 delete rhs 现在指向的内存，即，释放掉左侧运算对象中原来的内存。

这个技术的有趣之处是它自动处理了自赋值情况且天然就是异常安全的。它通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确，这与我们在原来的赋值运算符中使用的方法是一致的。他保证异常安全的方法也与原来的赋值运算符实现一样。代码中唯一可能抛出异常的是拷贝构造函数中的 new 表达式。如果真发生了异常，他也会在我们改变左侧运算对象之前发生。

> Note! 使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。

## 13.4 拷贝控制示例

虽然通常来说分配资源的类更需要拷贝控制，但资源管理并不是一个类需要定义自己的拷贝控制成员的唯一原因。一些类也需要拷贝控制成员的帮助来进行薄记工作或其他操作。

作为类需要拷贝控制来进行簿记操作的例子，我们将概述两个类的设计，这两个类可能用于邮件处理应用中。两个类命名为 Message 和 Folder，分别表示电子邮件（或者其他类型的）消息和消息目录。每个Message对象可以出现在多个 Folder 中。但是，任意给定的 Message 的内容只有一个副本。这样，如果一条 Message 的内容被改变，则我们从它所在的任何 Folder 来浏览此 Message 时，都会看到改变后的内容。

为了记录 Message 位于哪些 Folder 中，每个 Message 都会保存一个他所在 Folder 的指针的 set，同样的，每个 Folder 都保存一个它包含的 Message 的指针的 set。图13.1 说明了这种设计思路。

![](https://cdn.pkubailu.cn/img/13.1.png)

![](https://cdn.pkubailu.cn/img/拷贝控制示例.png)

#### Message 类

![](https://cdn.pkubailu.cn/img/Message类.png)

#### save 和 remove 成员

![](https://cdn.pkubailu.cn/img/save和remove成员.png)

#### Message 类的拷贝控制成员

![](https://cdn.pkubailu.cn/img/Message类的拷贝控制成员.png)

#### Message 的析构函数

当一个Message 被销毁时，我们必须从指向此Message的Folder中删除它。拷贝赋值运算符也要执行此操作，因此我们会定义一个公共函数来完成此工作：

![](https://cdn.pkubailu.cn/img/Message的析构函数.png)

#### Message 的拷贝赋值运算符

![](https://cdn.pkubailu.cn/img/Message的拷贝赋值运算符.png)

#### Message 的 swap 函数

![](https://cdn.pkubailu.cn/img/Message的swap函数-1.png)

![](https://cdn.pkubailu.cn/img/Message的swap函数-2.png)

## 13.5 动态内存管理类

某些类需要在运行时分配可变大小的内存空间。这种类通常可以（并且如果它们确实可以的话，一般应该）使用标准库容器来保存它们的数据。例如，我们的StrBlob类使用一个vector来管理其元素的底层内存。

但是，这一策略并不是对每个类都适用；某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。

例如，我们将实现标准库vector类的一个简化版本。我们所做的一个简化是不使用模板，我们的类只用于string。因此，它被命名为StrVec。

#### StrVec 类的设计

回忆一下，vector类将其元素保存在连续内存中。为了获得可接受的性能，vector预先分配足够的内存来保存可能需要的更多元素。vector的每个添加元素的成员函数会检查是否有空间容纳更多的元素。如果有，成员函数会在下一个可用位置构造一个对象。如果没有可用空间，vector就会重新分配空间：它获得新的空间，将已有元素移动到新空间中，释放旧空间，并添加新元素。

![](https://cdn.pkubailu.cn/img/StrVec类的设计.png)

#### StrVec 类定义

![](https://cdn.pkubailu.cn/img/StrVec类定义-1.png)

![](https://cdn.pkubailu.cn/img/StrVec类定义-2.png)

#### 使用 construct

![](https://cdn.pkubailu.cn/img/使用construct.png)

#### alloc_n_copy 成员

![](https://cdn.pkubailu.cn/img/alloc_n_copy成员.png)

#### free成员

![](https://cdn.pkubailu.cn/img/free成员.png)

#### 拷贝控制成员

实现了 alloc_n_copy 和 free 成员后，为我们的类实现拷贝控制成员就很简单了。

![](https://cdn.pkubailu.cn/img/拷贝控制成员.png)

#### 在重新分配内存的过程中移动而不是拷贝元素

在编写 reallocate 成员函数之前，我们稍微思考一下此函数应该做什么。他应该

- 为一个新的、更大的 string 数组分配内存
- 在内存空间的前一部分构造对象，保存现有元素
- 销毁原内存空间中的元素，并释放这块内存

观察这个步骤，我们可以看出，为一个 StrVec 重新分配内存空间会引起从旧内存空间到新内存空间逐个拷贝 sring。虽然我们不知道 string 的实现细节，但我们知道 string 具有类值行为。当拷贝一个 string 时，新 string 和原 string 是相互独立的。改变原 string 不会影响到副本，反之亦然。

由于 string 的行为类似值，我们可以得出结论，每个 string 对构成它的所有字符都会保存自己的一份副本。拷贝一个 string 必须为这些字符分配内存空间，而销毁一个 string 必须释放所占用的内存。

拷贝一个 string 就必须真的拷贝数据，因为在通常情况下，在我们拷贝了一个 string 之后，他就会有两个用户。但是，如果是reallocate 拷贝 StrVec 中的 string，则在拷贝之后，每个 string 只有唯一的用户。一旦将元素从旧空间拷贝到了新空间，我们就会立即销毁原 string。

因此，拷贝这些 string 中的数据是多余的。在重新分配内存空间时，如果我们能避免分配和释放 string 的额外开销，StrVec 的性能会好得多。

#### 移动构造函数和 std::move

![](https://cdn.pkubailu.cn/img/移动构造函数和move.png)

#### reallocate 成员

![](https://cdn.pkubailu.cn/img/reallocate成员.png)

动构造函数。由于我们使用了移动构造函数，这些 string 管理的内存将不会被拷贝。相反，我们构造的每个 string 都会从 elem 指向的 string 那里接管内存的所有权。

在元素移动完毕后，我们调用 free 销毁旧元素并释放 StrVec 原来使用的内存。

string 成员不再管理他们曾经指向的内存；其数据的管理职责已经转移给新 StrVec 内存中的元素了。我们不知道旧 StrVec 内存中的 string 包含什么值，但我们保证对它们执行 string 的析构函数是安全的。

剩下的就是更新指针，指向新分配并已初始化过的数组了。first_free 和 cap 指针分别被设置为指向最后一个构造的元素之后的位置及指向新分配空间的尾后位置。

## 13.6 对象移动

新标准的一个最主要的特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。

如我们已经看到的，我们的 StrVec 类是这种不必要的拷贝的一个很好的例子。在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。使用移动而不是拷贝的另一个原因源于IO类或unique_ptr 这样的类。这些类都包含不能被共享的资源（如指针或IO缓冲）。因此，这些类型的对象不能拷贝但可以移动。

在旧C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配的内存空间（如string），进行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。

> Note! 标准库容器、string 和 shared_ptr 类既支持移动也支持拷贝。IO类和 unique_ptr 类可以移动但不能拷贝。

### 13.6.1 右值引用

为了支持移动操作，新标准引入了一种新的引用类型——右值引用。所谓右值引用就是必须绑定到右值的引用。我们通过&&而不是&来获得右值引用。如我们将要看到的，**右值引用有一个重要的性质——只能绑定到一个将要销毁的对象**。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。

回忆一下，左值和右值是表达式的属性。一些表达式生成或要求左值，而另外一些则生成或要求右值。一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。

类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。如我们所知，对于常规引用（为了与右值引用区分开来，我们可以称之为左值引用），我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上：

```C++
int i = 42;
int &r = i;
int &&rr = i; // 错误：不能将一个右值引用绑定到一个左值上
int &r2 = i * 42; // 错误：i * 42是一个右值
const int &r3 = i * 42; // 正确: 我们可以将一个const的引用绑定到一个右值上
int &&rr2 = i * 42; // 正确：将rr2绑定到乘法结果上
```

返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。

返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个const 的左值引用或者一个右值引用绑定到这类表达式上。

#### 左值持久；右值短暂

考察左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。

由于右值引用只能绑定到临时对象，我们得知

- 所引用的对象将要被销毁
- 该对象没有其他用户

这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。

> Note! 右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态。

#### 变量是左值

变量可以看做只有一个运算对象而没有运算符的表达式，虽然我们很少这样看待变量。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上，这有些令人惊讶：

```C++
int &&rr1 = 42; // 正确： 字面常量是右值
int &&rr2 = rr1; // 错误：表达式rr1是左值！
```

其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，变量是持久的，直至离开作用域时才被销毁。

> Note! 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。

#### 标准库 move 函数

虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显示的将一个左值转换为对应的右值引用类型。我们还可以通过一个名为**move**的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。move函数使用了我们将在16.2.6中描述的机制来返回给定对象的右值引用。

```C++
int &&rr3 = std::move(rr1); // OK
```

move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用move就意味着承诺：除了对rr1赋值或销毁它以外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。

> Note! 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。

如前所述，与大多数标准库名字的使用不同，对move我们不提供using声明。我们直接调用std::move 而不是 move。

> WARNING! 使用move的代码应该使用 std::move 而不是move。这样做可以避免潜在的名字冲突。

### 13.6.2 移动构造函数和移动赋值运算符

![](https://cdn.pkubailu.cn/img/移动构造函数.png)

#### 移动操作、标准库容器和异常

由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库。我们将看到，除非标准库知道我们的移动构造函数不会抛出异常，否则他会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。

一种通知标准库的方法是在我们的构造函数中指明 noexcept。noexcept 是新标准库引入的。目前重要的是要知道，noexcept是我们承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表后指定noexcept。在一个构造函数中，noexcept 出现在参数列表和初始化列表开始的冒号之间：

```C++
class StrVec {
public:
  StrVec(StrVec &&) noexcept; // 移动构造函数
};
StrVec::StrVec(StrVec &&s) noexcept : /*成员初始化器*/ { /*构造函数体*/ }
```

我们必须在类头文件的声明中和定义中（如果定义在类外的话）都指定noexcept。

> Note! 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。

搞清楚为什么需要 noexcept 能帮助我们深入理解标准库是如何与我们自定义的类型交互的。我们需要指出一个移动操作不抛出异常，这是因为两个相互关联的事实：首先，虽然移动操作通常不抛出异常，但抛出异常也是允许的；其次，标准库容器能对异常发生时其自身的行为提供保障。例如，vector 保证，如果我们调用push_back 时发生异常，vector 自身不会发生改变。

现在让我们思考push_back 内部发生了什么。类似对应的StrVec 操作，对一个vector 调用 push_back 可能要求为 vector 重新分配内存空间。当重新分配 vector 的内存时，vector 将元素从旧空间移动到新内存中，就像我们在 reallocate 中所做的那样。

如我们刚刚看到的那样，移动一个对象通常会改变它的值。如果重新分配过程使用了移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题。就空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。在此情况下，vector 将不能满足自身保持不变的要求。

另一方面，如果vector 使用了拷贝构造函数且发生了异常，他可以很容易的满足要求。在此情况下，当在新内存中构造元素时，旧元素保持不变。如果此时发生了异常，vector 可以释放新分配的（但还未成功构造的）内存并返回。vector 原有的元素仍然存在。

为了避免这种潜在的问题，除非 vector 知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，他就必须使用拷贝构造函数而不是移动构造函数。如果希望在 vector 重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显示的告诉标准库我们的移动构造函数可以安全的使用。我们通过将移动构造函数（及移动赋值运算符）标记为noexcept 来做到这一点。

#### 移动赋值运算符

移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcept。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：

```C++
StrVec& StrVec::operator=(StrVec &&rhs) noexcept {
  if (this != &rhs) {
    free(); // 释放已有元素
    elements = rhs.elements; // 从 rhs 接管资源
    first_free = rhs.first_free;
    cap = rhs.cap;
    rhs.elements = rhs.first_free = rhs.cap = nullptr;
  }
  return *this;
}
```

在此例中，我们直接检查this指针与 rhs 的地址是否相同。如果相同，右侧和左侧运算对象指向相同的对象，我们不需要做任何事情。否则，我们释放左侧运算对象所使用的内存，并接管给定对象的内存。与移动构造函数一样，我们将 rhs 中的指针置为 nunllptr。

我们费心的去检查自赋值情况看起来有些奇怪。毕竟，移动赋值运算符需要右侧运算对象的一个右值。我们进行检查的原因是此右值可能是 move 调用的返回结果。与其他任何赋值运算符一样，关键点是我们不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源（可能是相同的资源）。

#### 移后源对象必须可析构

从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。我们的 StrVec 的移动操作满足这一要求，这是通过将移后源对象的指针成员置为 nullptr 来实现的。

除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。一般来说，对象有效就是指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。另一方面，移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。

例如，当我们从一个标准库 string 或容器对象移动数据时，我们知道移后源对象仍然保持有效。因此，我们可以对它执行诸如empty 或 size 这些操作。但是，我们不知道将会得到什么结果。我们可能期望一个移后源对象是空的，但这并没有保证。

我们的 StrVec 类的移动操作将移后源对象置于与默认初始化的对象相同的状态。因此，我们可以继续对移后源对象执行所有的 StrVec 操作，与任何其他默认初始化的对象一样。而其他内部结构更复杂的类，可能表现出完全不同的行为。

> WARNNING! 在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。

#### 合成的移动操作

与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。但是，合成移动操作的条件与合成拷贝操作的条件大不相同。

回忆一下，如果我们不声明自己的拷贝构造函数或拷贝赋值运算符，编译器总会为我们合成这些操作。拷贝操作要么被定义为逐成员拷贝，要么被定义为对象赋值，要么被定义为删除的函数。

与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，**如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了**。因此，某些类就没有移动构造函数或移动赋值运算符。如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。

**只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时**，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员：

```C++
// 编译器会为 X 和 hasX 合成移动操作
struct X {
  int i; // 内置类型可以移动
  std::string s; // string定义了自己的移动操作
};
struct hasX {
  X mem; // X 有合成的移动操作
};
X x, x2 = std::move(x); // 使用合成的移动构造函数
hasX hx, hx2 = std::move(hx); // 使用合成的移动构造函数
```

> Note! 只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译期才会为它合成移动构造函数或移动赋值运算符。

与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显示地要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。除了一个重要例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则：

- 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。
- 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。
- 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。
- 类似拷贝赋值运算符，如果有类成员是 const 的或是引用，则类的移动赋值运算符被定义为删除的。

例如，假定 Y 是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数：

```C++
struct hasY {
  hasY() = default;
  hasY(hasY&&) = default;
  Y mem; // hasY 将有一个删除的移动构造函数
};
hasY hy, hy2 = std::move(hy); // 错误：移动构造函数是删除的
```

编译器可以拷贝类型为 Y 的对象，但不能移动他们。类 hasY 显式地要求一个移动构造函数，但编译器无法为其生成。因此，hasY 会有一个删除的移动构造函数。如果 hasY 忽略了移动构造函数的声明，则编译器根本不能为它合成一个。如果移动操作可能被定义为删除的函数，编译器就不会合成他们。

移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。

> Note! 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。

#### 移动右值，拷贝左值.....

如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。例如，在我们的 StrVec 类中，拷贝构造函数接受一个 const StrVec 的引用。因此，他可以用于任何可以转换为 StrVec 的类型。而移动构造函数接受一个StrVec&&，因此只能用于实参是(非 static )右值得情形：

```C++
StrVec v1, v2;
v1 = v2; // v2 是左值；使用拷贝赋值
StrVec getVec(istream &); // getVec 返回一个右值
v2 = getVec(cin); // getVec(cin) 是一个右值；使用移动赋值
```

在第一个赋值中，我们将 v2 传递给赋值运算符。v2的类型是 StrVec，表达式 v2 是一个左值。因此移动版本的赋值运算符是不可行的，因为我们不能隐式地将一个右值引用绑定到一个左值。因此，这个赋值语句使用拷贝赋值运算符。

在第二个赋值中，我们赋予 v2 的是 getVec 调用的结果。此表达式是一个右值。在此情况下，两个赋值运算符都是可行的——将 getVec 的结果绑定到两个运算符的参数都是允许的。调用拷贝赋值运算符需要进行一次到 const 的转换，而 StrVec&& 则是精确匹配。因此，第二个赋值会使用移动赋值运算符。

#### ......但如果没有移动构造函数，右值也被拷贝

如果一个类有一个拷贝构造函数但未定义移动构造函数，会发生什么呢？在此情况下，编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数但不会有移动构造函数。如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用 move 来移动它们时也是如此：

```C++
class Foo {
public:
  Foo() = default;
  Foo(const Foo&); // 拷贝构造函数
};
Foo x;
Foo y(x); // 拷贝构造函数；x是一个左值
Foo z(std::move(x)); // 拷贝构造函数，因为未定义移动构造函数
```

在对z进行初始化时，我们调用了move(x)，他返回一个绑定到x的 Foo&&。Foo 的拷贝构造函数是可行的，因为我们可以将一个 Foo&&转换为一个 const Foo&。因此，z 的初始化将使用 Foo 的拷贝构造函数。

值得注意的是，用拷贝构造函数代替移动构造函数几乎肯定是安全的（赋值运算符的情况类似）。一般情况下，拷贝构造函数满足对应的移动构造函数的要求：它会拷贝给定对象，并将原对象置于有效状态。实际上，拷贝构造函数甚至都不会改变源对象的值。

> Note! 如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。

#### 拷贝并交换赋值运算符和移动操作

我们的 HasPtr 版本定义了一个拷贝并交换赋值运算符，它是函数匹配和移动操作间相互关系的一个很好的示例。如果我们为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符：

```C++
class HasPtr {
public:
  // 添加的移动构造函数
  HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;}
  // 赋值运算符既是移动赋值运算符，也是拷贝赋值运算符
  HasPtr& operator=(HasPtr rhs) {swap(*this, rhs); return *this;}
};
```

在这个版本中，我们为类添加了一个移动构造函数，它接管了给定实参的值。构造函数体将给定的 HasPtr 的指针置为0，从而确保销毁移后源对象是安全的。此函数不会抛出异常，因此我们将其标记为 noexcept。

现在我们来观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。

例如，假定 hp 和 hp2 都是 HasPtr 对象：

```C++
hp = hp2; // hp2 是一个左值；hp2通过拷贝构造函数来拷贝
hp = std::move(hp2); // 移动构造函数移动hp2
```

在第一个赋值中，右侧运算对象是一个左值，因此移动构造函数是不可行的。rhs将使用拷贝构造函数来初始化。拷贝构造函数将分配一个新的 string，并拷贝 hp2 指向的 string。

在第二个赋值中，我们调用 std::move 将一个右值引用绑定到 hp2 上。在此情况下，拷贝构造函数和移动构造函数都是可行的。但是，由于实参是一个右值引用，移动构造函数是精确匹配的。移动构造函数从 hp2 拷贝指针，而不会分配任何内存。

不管使用的是拷贝构造函数还是移动构造函数，赋值运算符的函数体都 swap 两个运算对象的状态。交换 HasPtr 会交换两个对象的指针（及int）成员。在 swap 之后，rhs 中的指针将指向原来左侧运算对象所拥有的 sring。当 rhs 离开作用域时，这个 string 将被销毁。

> **建议：更新三/五法则**
>
> 所有五个拷贝控制成员应该看做一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外的开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。

#### Message 类的移动操作

定义了自己的拷贝构造函数和拷贝赋值运算符的类通常也会从移动操作受益。例如，我们的 Message 和 Folder 类就应该定义移动操作。通过定义移动操作，Message 类可以使用 string 和 set 的移动操作来避免拷贝 contents 和 folders成员的额外开销。

但是，除了移动 folders 成员，我们还必须更新每个指向原 Message 的 Folder。我们必须删除指向旧 Message 的指针，并添加一个指向新 Message 的指针。

移动构造函数和移动赋值运算符都需要更新 Folder 指针，因此我们首先定义一个操作来完成这一共同的工作：

```C++
// 从本 Message 移动 Folder 指针
void Message::move_Folders(Message *m) {
  folders = std::move(m->folders); // 使用 set 的移动赋值运算符
  for (auto f : folders) {
    f->remMsg(m); // 从 Folder 中删除旧 Message
    f->addMsg(this); // 将本 Message 添加到 Folder 中
  }
  m->folders.clear(); // 确保销毁m是无害的
}
```

此函数首先移动 folders 集合。通过调用 move，我们使用了 set 的移动赋值运算符而不是它的拷贝赋值运算符。如果我们忽略了 move 调用，代码仍能正常工作，但带来了不必要的拷贝。然后遍历所有 Folder，从其中删除指向原 Message 的指针并添加指向新 Message 的指针。

值得注意的是，向 set 插入一个元素可能会抛出一个异常——向容器添加元素的操作要求分配内存，意味着可能会抛出一个 bad_alloc 异常。因此，与我们的 HasPtr 和 StrVec 类的移动操作不同，Message 的移动构造函数和移动赋值运算符可能会抛出异常。因此，我们未将它们标记为 noexcept 。

函数最后对 m.folders 调用 clear。在执行了 move 之后，我们知道 m.folders 是有效的，但不知道它包含什么内容。由于 Message 的析构函数遍历 folders，我们希望能确定 set 是空的。

Message 的移动构造函数调用 move 来移动 contents，并默认初始化自己的folders 成员：

```C++
Message::Message(Message &&m): contents(std::move(m.contents)){
  move_Folders(&m); // 移动folders并更新Folder指针
}
```

在构造函数体中，我们调用了 move_Folders 来删除指向 m 的指针并插入指向本 Message 的指针。

移动赋值运算符直接检查自赋值情况：

```C++
Message& Message::operator=(Message &&rhs){
  if (this != &rhs) { // 直接检查自赋值情况
    remove_from_Folders();
    contents = std::move(rhs.contents); // 移动赋值运算符
    move_Folders(&rhs); // 重置Folders指向本 Message
  }
  return *this;
}
```

与任何赋值运算符一样，移动赋值运算符必须销毁左侧运算对象的旧状态。在本例中，销毁左侧运算对象要求我们从现有的 folders 中删除指向本 Message 的指针，我们调用 remove_from_Folders 来完成这一工作。完成删除工作后，我们调用 move 从 rhs 将 contents 移动到 this 对象。剩下的就是调用 move_Message 来更新 Folder 指针了。

#### 移动迭代器

StrVec 的 reallocate 成员使用了一个 for 循环来调用 construct 从旧内存将元素拷贝到新内存中。作为一种替换方法，如果我们能调用 uninitialized_copy 来构造新分配的内存，将比循环更为简单。但是，uninitialized_copy 恰如其名：它对元素进行拷贝操作。标准库中并没有类似的函数将对象“移动”到未构造的内存中。

新标准库中定义了一种**移动迭代器**适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。

我们通过调用标准库的 make_move_iterator 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。

原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。特别是，可以将移动迭代器传递给 uninitialized_copy：

```C++
void StrVec::reallocate(){
  // 分配大小两倍与当前规模的内存空间
  auto newcapacity = size() ? 2 * size() : 1;
  auto first = alloc.allocate(newcapacity);
  // 移动元素
  auto last = uninitialized_copy(make_move_iterator(begin())， make_move_iterator(end()), first);
  free();
  elements =first;
  first_free = last;
  cap = elements + newcapacity;
}
```

uninitialized_copy 对输入序列中的每个元素调用 construct 来将元素“拷贝”到目的位置。此算法使用迭代器的解引用运算符从输入序列中提取元素。由于我们传递给他的是移动迭代器，因此解引用运算符生成的是一个右值引用，这意味着 construct 将使用移动构造函数来构造元素。

值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。

> **建议：不要随意使用移动操作**
>
> 由于一个移后源对象具有不确定的状态，对其调用 std::move 是危险的。当我们调用 move 时，必须绝对确定移后源对象没有其他用户。
>
> 通过在类代码中小心的使用 move，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。
>
> Note! 在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用 std::move。

### 13.6.3 右值引用和成员函数

除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式——一个版本接受一个指向 const 的左值引用，第二个版本接受一个指向非 const 的右值引用。

例如，定义了 push_back 的标准库容器提供两个版本：一个版本有一个右值引用参数，而另一个版本有一个 const 左值引用。假定 x 是元素类型，那么这些容器就会定义以下两个 push_back 版本：

```C++
void push_back(const X&); // 拷贝：绑定到任意类型的X、
void push_back(X&&); // 移动：只能绑定到类型X的可修改的右值
```

我们可以将能转换为类型 X 的任何对象传递给第一个版本的 push_back。此版本从其参数拷贝数据。对于第二个版本，我们只可以传递给它非 const 的右值。此版本对于非 const 的右值是精确匹配（也是更好的匹配）的，因此当我们传递一个可修改的右值时，编译器会选择运行这个版本。此版本会从其参数窃取数据。

一般来说，我们不需要为函数操作定义接受一个 const X&&或是一个（普通的）X& 参数的版本。当我们希望从实参“窃取”数据时，通常传递一个右值引用。为了达到这一目的，实参不能是 const 的。类似的，从一个对象进行拷贝的操作不应该改变该对象。因此，通常不需要定义一个接受一个（普通的）X& 参数的版本。

> Note! 区分移动和拷贝的重载函数通常有一个版本接受一个 const T&，而另一个版本接受一个 T&&。

![](https://cdn.pkubailu.cn/img/右值引用和成员函数.png)

![](https://cdn.pkubailu.cn/img/右值引用和成员函数-2.png)

#### 右值和左值引用成员函数

![](https://cdn.pkubailu.cn/img/右值和左值引用成员函数.png)

#### 重载和引用函数

![](https://cdn.pkubailu.cn/img/重载和引用函数.png)

本例中声明了一个没有参数的 const 版本的 sorted，此声明是错误的。因为 Foo 类中还有一个无参的 sorted 版本，它有一个引用限定符，因此 const 版本也必须有引用限定符。另一方面，接受一个比较操作的 sorted 版本是没问题的，因为两个函数都没有引用限定符。

> Note! 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。

# 第 14 章 重载运算与类型转换

当运算符被用于类类型的对象时，C++语言允许我们为其指定新的含义；同时，我们也能自定义类类型之间的转换规则。和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。

当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含义。明智地使用运算符重载能令我们的程序更易于编写和阅读。举个例子，因为在 Sales_data 类中定义了输入、输出和加法运算符，所以可以通过下述形式输出两个 Sales_item 的和：

```C++
cout << item1 + item2; // 输出两个 Sales_item 的和
```

相反的，由于我们的 Sales_data 类还没有重载这些运算符，，因此它的加法代码显得比较冗长而不清晰：

```C++
print(cout, add(data1, data2)); // 输出两个 Sales_data 的和
```

## 14.1 基本概念

重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。

重载运算符函数的参数数量是与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。除了重载的函数调用运算符 operator() 之外，其他重载运算符不能含有默认实参。

如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的 this 指针上，因此，成员运算符函数的（显示）参数数量比运算符的运算对象总数少一个。

> Note! 当一个重载的运算符是成员函数时，this 绑定到左侧运算对象。成员运算符函数（显示）参数数量比运算对象的数量少一个。

对于一个运算符函数来说，他或是类的成员，或者至少含有一个类类型的参数

```C++
// 错误：不能为int重定义内置的运算符
int operator+(int, int);
```

这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。

我们可以重载大多数（但不是全部）运算符。表14.1指明了哪些运算符可以被重载，哪些不行。

我们只能重载已有的运算符，而无权发明新的运算符号。例如，我们不能提供 operator** 来执行幂操作。

有四个符号(+、-、*、&) 既是一元运算符也是二元运算符，所有这些运算符都能被重载，从参数的数量我们可以推断到底定义的是哪种运算符。

对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。

![](https://cdn.pkubailu.cn/img/14.1.png)

#### 直接调用一个重载的运算符函数

通常情况下，我们将运算符作用于类型正确的实参，从而以这种间接方式“调用”重载的运算符函数。然而，我们也能像调用普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参：

```C++
// 一个非成员运算符函数的等价调用
data1 + data2; // 普通的表达式
operator+(data1, data2); // 等价的函数调用
```

这两次调用是等价的，它们都调用了非成员函数 operator+，传入 data1 作为第一个实参、传入 data2 作为第二个实参。

我们像调用其他成员函数一样显示的调用成员运算符函数。具体做法是，首先指定运行函数的对象（或指针）的名字，然后使用点运算符（或箭头运算符）访问希望调用的函数：

```C++
data1 += data2;
data1.operator+=(data2); // 对成员运算符函数的等价调用
```

这两条语句都调用了成员函数 operator+=，将 this 绑定到 data1 的地址、将 data2 作为实参传入了函数。

#### 某些运算符不应该被重载

回忆之前介绍过的，某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是，逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。除此之外，&&和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。

因为上述运算符的重载版本无法保留求值顺序和/或短路求值属性，因此不建议重载它们。当代码使用了这些运算符的重载版本时，用户可能会突然发现它们一直习惯的求值规则不再适用了。

还有一个原因使得我们一般不重载逗号运算符和取地址运算符；C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说他们不应该被重载，否则他们的行为将异于常态，从而导致类的用户无法适应。

> Note! 通常情况下不应该重载逗号、取地址符、逻辑与和逻辑或运算符。

#### 使用与内置类型一致的含义

当你开始设计一个类时，首先应该考虑的是这个类将提供哪些操作。在确定类需要哪些操作之后，才能思考到底应该把每个类操作设成普通函数还是重载的运算符。如果某些操作在逻辑上与运算符相关，则它们适合于定义成重载的运算符：

- 如果类执行IO操作，则定义移位运算符使其与内置类型的IO保持一致。
- 如果类的某个操作是检查相等性，则定义 operator==；如果类有了 operator==，意味着它通常也应该有!=。
- 如果类包含一个内在的单序比较操作，则定义 operator<；如果类有了 operator<，则它也应该含有其他关系操作。
- 重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用。

#### 赋值和复合赋值运算符

赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。重载的赋值运算应该继承而非违背其内置版本的含义。

如果类含有算术运算符或者位运算符，则最好也提供对应的复合赋值运算符。无需赘言，+=运算符的行为显然应该与其内置版本一致，即先执行+，再执行=。

#### 选择作为成员或者非成员

当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员；另一些情况下，运算符作为普通函数比作为成员更好。

下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：

- 赋值（=）、下标（[]）、调用（( )）和成员访问箭头（->）运算符必须是成员。
- 复合赋值运算符一般来说应该是成员，但并非是必须，这一点与赋值运算符略有不同。
- 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此他们通常应该是普通的非成员函数。

程序员希望能在含有混合类型的表达式中使用对称性运算符。例如，我们能求一个 int 和一个 double 的和，因为它们中的任意一个都可以是左侧运算对象或右侧运算对象，所以加法是对称的。如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。

当我们把运算符定义成成员函数时，**它的左侧运算对象必须是运算符所属类的一个对象**。例如：

```C++
string s = "world";
string t = s + "!"; // 正确：我们能把一个 const char* 加到一个string对象中
string u = "hi" + s; // 如果+是 string 的成员，则产生错误
```

如果 operator+ 是 string 类的成员，则上面的第一个加法等于 s.operator+("!")。

同样的， "hi"+s 等价于 "hi".operator+(s)。显然"hi"的类型是 const char*，这是一种内置类型，根本就没有成员函数。

因为 string 将 + 定义成了普通的非成员函数，所以 "hi"+s 等价于 operator("hi",s)。和任何其他函数调用一样，每个实参都能被转换为形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误的转换成 string。

## 14.2 输入和输出运算符

如我们所知，IO标准库分别使用 >> 和 << 执行输入和输出操作。对于这两个运算符来说，IO库定义了用其读写内置类型的版本，而类则需要自定义适合其对象的新版本以支持IO操作。

### 14.2.1 重载输出运算符 <<

通常情况下，输出运算符的第一个形参是一个非常量 ostream 对象的引用。之所以 ostream 是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个 ostream 对象。

第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量是因为（通常情况下）打印对象不会改变对象的内容。

为了与其他输出运算符保持一致，operator<< 一般要返回它的 ostream 形参。

#### Sales_data 的输出运算符

举个例子，我们按照如下形式编写 Sales_data 的输出运算符：

```C++
ostream &operator<<(ostream &os, const Sales_data &item){
  os << item.isbn() << " " << item.units_sold << " "
     << item.revenue << " " << item.avg_price();
  return os;
}
```

除了名字之外，这个函数与之前的 print 函数完全一样。打印一个 Sales_data 对象意味着要分别打印它的三个数据成员以及通过计算得到的平均销售价格，每个元素以空格隔开。完成输出后，运算符返回刚刚使用的 ostream 的引用。

#### 输出运算符尽量减少格式化操作

用于内置类型的输出运算符不太考虑格式化操作，尤其不会打印换行符，用户希望类的输出运算符也像如此行事。如果运算符打印了换行符，则用户就无法在对象的同一行内接着打印一些描述性的文本了。相反，令输出运算符尽量减少格式化操作可以使用户有权控制输出的细节。

> Note! 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。

#### 输入输出运算符必须是非成员函数

与 iostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象：

```C++
Sales_data data;
data << cout; // 如果 operator<<是 Sales_data的成员
```

假设输入输出运算符是某个类的成员，则它们也必须是 istream 或 ostream 的成员。

然而，这两个类属于标准库，并且我们无法给标准库中的类添加任何成员。

因此，如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数。当然，IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。

#### 14.2.2 重载输入运算符 >> 

通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。

#### Sales_data 的输入运算符

举个例子，我们将按照如下形式编写 Sales_data 的输入运算符：

```C++
istream &operator>>(istream &is, Sales_data &item) {
  double price;
  is >> item.bookNo >> item.units_sold >> price;
  if(is)
    	item.revenue = item.units_sold * price;
  else
    	item = Sales_data();
  return is;
}
```

除了 if 语句之外，这个定义与之前的 read 函数完全一样。if 语句检查读取操作是否成功，如果发生了 IO 错误，则运算符将给定的对象重置为空 Sales_data，这样可以确保对象处于正确的状态。

> Note! 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。

#### 输入时的错误

在执行输入运算符时可能发生下列错误：

- 当流含有错误类型的数据时读取操作可能失败。例如在读取完 bookNo 后，输入运算符假定接下来读入的是俩个数字数据，一旦输入的不是数字数据，则读取操作及后续对流的其他使用都将失败。
- 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。

在程序中我们没有逐个检查每个读取操作，而是等读取了所有数据后赶在使用这些数据前一次性检查。

如果读取操作失败，则 price 的值将是未定义的。因此，在使用 price 之前我们需要首先检查输入流的合法性，然后才能执行计算并将结果存入 revenue。如果发生了错误，我们无须在意到底是哪部分输入失败，只要将一个新的默认初始化的 Sales_data 对象赋予 item 从而将其重置为空 Sales_data 就可以了。执行这样的赋值后，item 的 bookNo 成员将是一个空 string，revenue 和 units_sold成员将等于0。

如果在发生错误前对象已经有一部分被改变，则适时地将对象置为合法状态显得异常重要。例如在这个输入运算符中，我们可能在成功读取新的 bookNo 后遇到错误，这意味着对象的 units_sold 和 revenue 成员并没有被改变，因此有可能会将这两个数据与一条完全不匹配的 bookNo 组合在一起。

通过将对象置为合法的状态，我们能（略微）保护使用者免于受到输入错误的影响。此时的对象处于可用状态，即它的成员都是被正确定义的。而且该对象也不会产生误导性的结果，因为它的数据在本质上确实是一体的。

> Note! 当读取操作发生错误时，输入运算符应该负责从错误中恢复。

#### 标识错误

一些输入运算符需要做更多数据验证的工作。例如，我们的输入运算符可能需要检查 bookNo 是否符合规范的格式。在这样的例子中，即使从技术上来看 IO 是成功的，输入运算符也应该设置流的条件状态以标识出失败信息。通常情况下，输入运算符只设置 failbit。除此之外，设置 eofbit 表示文件耗尽，而设置 badbit 表示流被破坏。最好的方式是由 IO标准库自己来标识这些错误。

## 14.3 算术和关系运算符

通常情况下，我们把算数和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。

算术运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果。如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符：

```C++
// 假设两个对象指向同一本书
Sales_data
operator+(const Sales_data &lhs, const Sales_data &rhs) {
  Sales_data sum = lhs;
  sum += rhs;
  return sum;
}
```

这个定义与原来的 add 函数是完全等价的。我们把 lhs 拷贝给局部变量 sum，然后使用 Sales_data 的复合赋值运算符将 rhs 的值加到 sum 中，最后函数返回 sum 的副本。

> Tip! 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。

### 14.3.1 相等运算符

通常情况下，C++中的类通过定义相等运算符来检验两个对象是否相等。也就是说，它们会比较对象的每一个数据成员，只有当所有对应的成员都相等时才认为两个对象相等。依据这一思想，我们的 Sales_data 类的相等运算符不但应该比较 bookNo，还应该比较具体的销售数据：

```C++
bool operator==(const Sales_data &lhs, const Sales_data &rhs) {
  return lhs.isbn() == rhs.isbn &&
    		 lhs.units_sold == rhs.units_sold &&
    	   lhs.revenue == rhs.revenue;
}
bool operator!=(const Sales_data &lhs, const Sales_data &rhs) {
  return !(lhs == rhs);
}
```

就上面这些函数的定义本身而言，他们似乎比较简单，也没什么价值，对于我们来说重要的是从这些函数中体现出来的设计准则：

- 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成 operator== 而非一个普通的命名函数：因为用户肯定希望能使用 == 比较对象，此外，类定义了 == 运算符之后也更容易使用标准库容器和算法。
- 如果类定义了 operator==，则该运算符应该能判断一组给定的对象中是否含有重复数据。
- 通常情况下，相等运算符应该具有传递性，换句话说，如果 a==b 和 b==c 都为真，则 a==c 也应该为真。
- 如果类定义了 operator==，则这个类也应该定义 operator!=。对于用户来说，当它们能使用 == 时肯定也希望能使用 !=，反之亦然。
- 相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。

> Note! 如果某个类在逻辑上有相等性的含义，则该类应该定义 operator==，这样做可以使得用户更容易使用标准库算法来处理这个类。

### 14.3.2 关系运算符

定义了相等运算符的类也常常（但不总是）包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义 operator< 会比较有用。

通常情况下关系运算符应该

1. 定义顺序关系，令其与关联容器中对关键字的要求一致。
2. 如果类同时也含有 == 运算符的话，则定义一种关系令其与 == 保持一致。特别是，如果两个对象是 != 的，那么一个对象应该 < 另外一个。

尽管我们可能会认为 Sales_data 类应该支持关系运算符，但事实证明并非如此，其中的缘由比较微妙，值得读者深思。

一开始我们可能会认为应该像 compareIsbn 那样定义 <，该函数通过比较 ISBN 来实现对两个对象的比较。然而，尽管 compareIsbn 提供的顺序关系符合要求1，但是函数得到的结果显然与我们定义的 == 不一致，因此他不满足要求2.

对于 Sales_data 的 == 运算符来说，如果两笔交易的 revenue 和 units_sold 成员不同，那么即使他们的 ISBN 相同也无济于事，他们任然是不相等的。如果我们定义的 < 运算符仅仅比较 ISBN 成员，那么将发生这样的情况：两个 ISBN 相同但 revenue 和 units_sold 不同的对象经比较是不相等的，但是其中的任何一个都不比另一个小。然后实际情况是，如果我们有两个对象并且哪个都不必另一个小，则从道理上来讲这两个对象应该是相等的。

基于上述分析我们也许会认为，只要让 operator< 依次比较每个数据元素就能解决问题了，比方说让 operator< 先比较 isbn，相等的话继续比较 units_sold，还相等再继续比较 revenue。

然而，这样的排序没有任何必要。根据将来使用 Sales_data 类的实际需要，我们可能会希望先比较 units_sold，也可能希望先比较 revenue。有的时候，我们希望 units_sold 少的对象“小于” units_sold 多的对象；另一些时候，则可能希望 revenue 少的对象“小于” revenue 多的对象。

因此对于 Sales_data 类来说，不存在一种逻辑可靠的 < 定义，这个类不定义 < 运算符也许更好。

> 如果存在唯一一种逻辑可靠的 < 定义，则应该考虑为这个类定义 < 运算符。如果类同时还包含==，则当且仅当 < 的定义和 == 产生的结果一致时才定义 < 运算符。

## 14.4 赋值运算符

之前已经介绍过拷贝赋值和移动赋值运算符，它们可以把类的一个对象赋值给该类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。

举个例子，在拷贝赋值和移动赋值运算符之外，标准库 vector 类还定义了第三种赋值运算符，该运算符接受花括号内的元素列表作为参数。我们能以如下的形式使用该运算符：

```C++
vector<string> v;
v = {"a", "an", "the"}；
```

同样，也可以把这个运算符添加到 StrVec 类中：

```C++
class StrVec {
public:
  StrVec &operator=(std::initializer_list<std::string>);
  // 其他成员一致
}
```

为了与内置类型的赋值运算符保持一致（也与我们已经定义的拷贝赋值和移动赋值运算一致），这个新的赋值运算符将返回其左侧运算对象的引用：

```C++
StrVec &StrVec::operator=(initializer_list<string> i1) {
  auto newdata = alloc_n_copy(i1.begin(), i1.end());
  free();
  elements = newdata.first;
  first_free = cap = newdata.second;
  return *this;
}
```

和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间，再创建一片新空间。不同之处是，这个运算符无须检查对象向自身的赋值，这是因为它的形参 initializer_list<string> 确保 i1 与 this 所指的不是同一个对象。

> Note! 我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。

#### 复合赋值运算符

复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要返回其左侧对象的引用。例如，下面是 Sales_data 类中复合赋值运算符的定义：

```C++
// 作为成员的二元运算符：左侧运算对象绑定到隐式的this指针
// 假定两个对象表示的是同一本书
Salee_data& Salee_data::operator+=(const Salee_data &rhs) {
  units_sold += rhs.units_sold;
  revenue += rhs.revenue;
  return *this;
}
```

> Note! 赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。

## 14.5 下标运算符

表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符 operator[ ]。

> Note! 下标运算符必须是成员函数。

为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。进一步，我们最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。

> Note! 如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。

举个例子，我们按照如下形式定义 StrVec 的下标运算符：

```C++
class StrVec {
public:
  std::string& operator[](std::size_t n)
  	{ return elements[n]; }
  const std::string& operator[](std::size_t n) const
  	{ return elements[n]; }
private:
  std::string *elements;
}
```

上面这两个下标运算符的用法类似于 vector 或者数组中的下标。因为下标运算符返回的是元素的引用，所以当 StrVec 是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值：

```C++
// 假设 svec 是一个 StrVec 对象
const StrVec cvec = svec; // 把 svec 的元素拷贝到 cvec 中
// 如果 svec 中含有元素，对第一个元素运行string 的 empty函数
if(svec.size() && svec[0].empty()) {
  svec[0] = "zero"; // 正确：下标运算符返回string的引用
  cvec[0] = "Zip"; //错误：对cvec取下标返回的是常量引用
}
```

## 14.6 递增和递减运算符

在迭代器类中通常会实现递增运算符（++）和递减运算符（--），这两种运算符使得类可以在元素的序列中前后移动。C++语言并不要求递增和递减运算符必须是类的成员，但是因为他们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。

对于内置类型来说，递增和递减运算符既有前置版本也有后置版本。同样，我们也应该为类定义两个版本的递增和递减运算符。接下来我们首先介绍前置版本，然后实现后置版本。

> Note! 定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。

#### 定义前置递增/递减运算符

为了说明递增和递减运算符，我们不妨在 StrBlobPtr 类中定义他们：

```C++
class StrBlobPtr {
public:
  // 递增和递减运算符
  StrBlobPtr& operator++();
  StrBlobPtr& operator--();
}
```

> Note! 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。

递增和递减运算符的工作机理非常相似：他们首先调用 check 函数检验 StrBlobPtr 是否有效，如果是，接着检查给定的索引值是否有效。如果 check 函数没有抛出异常，则运算符返回对象的引用。

在递增运算符的例子中，我们把 curr 的当前值传递给 check 函数。如果这个值小于 vector 的大小，则 check 正常返回：否则，如果 curr 已经到达了vector 的末尾，check 将抛出异常：

```C++
// 前置版本：返回递增/递减对象的引用
StrBlobPtr& StrBlobPtr::operator++() {
  check(curr, "increment past end of StrBlobPtr");
  ++curr;
  return *this;
}
StrBlobPtr& StrBlobPtr::operator--() {
  --curr;
  check(curr, "decrement past begin of StrBlobPtr");
  return *this;
}
```

递减运算符先递减 curr，然后调用 check 函数。此时，如果 curr （一个无符号数）已经是0了，那么我们传递给 check 的值将是一个表示无效下标的非常大的正数值。

#### 区分前置和后置运算符

要相同时定义前置和后置运算符，必须首先解决一个问题，即普通的重载形式无法区分这两种情况。前置和后置版本使用的是同一个符号，意味着其重载版本所用的名字将是相同的，并且运算对象的数量和类型也相同。

为了解决这个问题，后置版本接受一个额外的（不被使用的）int 类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中不会这么做。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。

接下来我们为 StrBlobPtr 添加后置运算符：

```C++
class StrBlobPtr {
public:
  StrBlobPtr operator++(int); // 后置运算符
  StrBlobPtr operator--(int);
}
```

> Note! 为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。

对于后置版本来说，在递增对象之前需要首先记录对象的状态：

```C++
// 后置版本：递增/递减对象的值但是返回原值
StrBlobPtr StrBlobPtr::operator++(int) {
  StrBlobPtr ret = *this; // 记录当前的值
  ++*this; // 向前移动一个元素，前置++需要检查递增的有效性
  return ret; // 返回之前记录的状态
} 
StrBlobPtr StrBlobPtr::operator--(int) {
  StrBlobPtr ret = *this; // 记录当前的值
  --*this; // 向后移动一个元素，前置--需要检查递增的有效性
  return ret; // 返回之前记录的状态
} 
```

由上可知，我们的后置运算符调用各自的前置版本来完成实际的工作。例如后置递增运算符执行 

​	++*this

该表达式调用前置递增运算符，前置递增运算符首先检查递增操作是否安全，根据检查的结果抛出一个异常或者执行递增 curr 的操作。假定通过了检查，则后置函数返回事先存好的 ret 的副本。因此最终的效果是，对象本身向前移动了一个元素，而返回的结果仍然反映对象在未递增之前原始的值。

> Note! 因为我们不会用到 int 形参，所以无须为其命名。

#### 显式地调用后置运算符

可以显示地调用一个重载的运算符，其效果与在表达式中以运算符号的形式使用它完全一样。如果我们想通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值：

```C++
StrBlobPtr p(a1); // p指向a1中的 vector
p.operator++(0); // 调用后置版本的operator++
p.operator++(); // 调用前置版本的operator++
```

尽管传入的值通常会被运算符函数忽略，但却必不可少，因为编译期只有通过它才能知道应该使用后置版本。

## 14.7 成员访问运算符

在迭代器类及智能指针类中常常用到解引用运算符（*）和箭头运算符（->）。我们以如下形式向 StrBlobPtr 类添加这两种运算符：

```C++
class StrBlobPtr {
public:
  std::string& operator*() const {
    auto p = check(curr, "dereference past end");
    return (*p)[curr];
  }
  std::string* operator->() const {
    return & this->operator*();
  }
}
```

解引用运算符首先检查 curr 是否仍在作用范围内，如果是，则返回 cur  所指元素的一个引用。箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址。

> Note! 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。

值得注意的是，我们将这两个运算符定义成了 const 成员，这是因为与递增和递减运算符不一样，获取一个元素并不会改变 StrBlobPtr 对象的状态。同时，它们的返回值分别是非常量 string 的引用或指针，因为一个 StrBlobPtr 只能绑定到非常量的 StrBlobPtr 对象。

这两个运算符的用法与指针或者 vector 迭代器的对应操作完全一致：

```C++
StrBlob a1 = {"hi", "bye", "now"};
StrBlobPtr p(a1);
*p = "okay";  // 给a1的首元素赋值
cout << p->size() << endl; // 打印4，这是a1首元素的大小
cou << (*p).size() << endl;
```

#### 对箭头运算符返回值的限定

和大多数其他运算符一样（尽管这么做不太好），我们能令 operator* 完成任何我们指定的操作。换句话说，我们可以让 operator* 返回一个固定值42，或者打印对象的内容，或者其他。箭头运算符则不是这样，他永远不能丢掉成员访问这个最基本的含义。当我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，**而箭头获取成员这一事实则永远不变**。

对于形如 point->mem 的表达式来说，point 必须是指向类对象的指针或者是一个重载了 operator-> 的类的对象。根据 point 类型的不同， point->mem 分别等价于

```C++
(*point).mem; // point 是一个内置的指针类型
point.operator()->mem; // point 是类的一个对象
```

除此之外，代码都将发生错误。point->mem 的执行过程如下所示：

1. 如果 point 是指针，则我们应用内置的箭头运算符，表达式等价于(*point).mem。首先解引用指针，然后从所得的对象中获取指定的成员。如果 point 所指的类型没有名为 mem 的成员，程序会发生错误。
2. 如果 point 是定义了 operator-> 的类的一个对象，则我们使用 point.operator->()的结果来获取 mem。其中，如果该结果是一个指针，则执行第一步；如果该结果本身含有重载的 operator->()，则重复调用当前步骤。最终，当这一过程结束时程序或者返回了所需的内容，或者返回一些表示程序错误的信息。

> Note! 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。

## 14.8 函数调用运算符

如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态。所以与普通函数相比他们更加灵活。

举个简单的例子，下面这个名为 absInt 的 struct 含有一个调用运算符，该运算符负责返回其参数的绝对值：

```C++
struct absInt {
  int operator()(int val) const {
    return val < 0 ? -val : val;
  }
};
```

这个类只定义了一种操作：函数调用运算符，他负责接受一个 int 类型的实参，然后返回该实参的绝对值。

我们使用调用运算符的方式是令一个 absInt 对象作用于一个实参列表，这一过程看起来非常像调用函数的过程：

```C++
int i = -42;
absInt absObj(); // 含有函数调用运算符的对象
int ui = absObj(i); // 将i传递给 absObj.operator()
```

即使 absObj 只是一个对象而非函数，我们也能“调用”该对象。调用对象实际上是在运行重载的调用运算符。在此例中，该运算符接受一个 int 值并返回其绝对值。

> Note! 函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。

如果类定义了调用运算符，则该类的对象称作**函数对象**。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。

#### 含有状态的函数对象类

和其他类一样，函数对象类除了 operator() 之外也可以包含其他成员。函数对象类通常含有一些数据成员，这些成员被用于定制调用运算符中的操作。

举个例子，我们将定义一个打印 string 实参内容的类。默认情况下，我们的类会将内容写入到 cout 中，每个 string 之间以空格隔开。同时也允许类的用户提供其他可写入的流及其他分隔符。我们将该类定义如下：

```C++
class PrintString {
public:
  PrintString(ostream &o = cout, char c = ' '): os(o), sep(c) {}
  void operator()(const string &s) const {os << s << sep;}
private:
  ostream &os; // 用于写入的目的流
  char sep; // 用于将不同输出隔开的字符
};
```

我们的类有一个构造函数，它接受一个输出流的引用以及一个用于分割的字符，这俩个形参的默认实参分别是 cout 和空格。之后的函数调用运算符使用这些成员协助其打印给定的string。

当定义 PrintString 的对象时，对于分隔符及输出流即可以使用默认值也可以提供我们自己得值：

```C++
PrintString printer;
printer(s);
PrintString errors(cerr, '\n');
errors(s); // 在 cerr 中打印s，后面跟一个换行符
```

函数对象常常作为泛型算法的实参。例如，可以使用标准库 for_each 算法和我们自己的 PrintString 类来打印容器中的内容：

```C++
for_each(vs.begin(), vs.end(), PrintString(cerr, '\n'));
```

For_each 的第三个实参是类型 PrintString 的一个临时对象，其中我们用 cerr 和换行符初始化了该对象。当程序调用 for_each 时，将会把 vs 中的每个元素依次打印到 cerr 中，元素之间以换行符分割。

### 14.8.1 lambda 是函数对象

在前一节中，我们使用一个 PrintString 对象作为调用 for_each 的实参，这一用法类似于我们在10.3.2节中编写的使用 lambda 表达式的程序。当我们编写了一个 lambda 后，编译器将该表达式翻译成一个未命名类的未命名对象。在 lambda 表达式产生的类中含有一个重载的函数调用运算符，例如，对于我们传递给 stable_sort 作为其最后一个实参的 lambda 表达式来说：

```C++
stable_sort(words.begin(), words.end(),[](const string &a, const string &b) {return a.size() < b.size();});
```

其行为类似于下面这个类的一个未命名对象

```C++
class ShorterString {
public:
  bool operator()(const string &a, const string &b) const {
    return a.size() < b.size();
  }
};
```

产生的类只有一个函数调用运算符成员，他负责接受两个 string 并比较它们的长度，它的形参列表和函数体与 lambda 表达式完全一样。如我们在 10.3.3节所见，默认情况下 lambda 不能改变它捕获的变量。因此在默认情况下，由 lambda 产生的类当中的函数调用运算符是一个 const 成员函数。如果 lambda 被声明为可变的，则调用运算符就不是 const 的了。

用这个类替代 lambda 表达式后，我们可以重写并重新调用 stable_sort：

```C++
stable_sort(words.begin(), words.end(), ShorterString());
```

第三个实参是新构建的 ShorterString 对象，当 stable_sort 内部的代码每次比较两个 string 时就会“调用”这一对象，此时该对象将调用运算符的函数体，判断第一个 string 的大小小于第二个时返回 true。

#### 表示 lambda 及相应捕获行为的类

如我们所知，当一个 lambda 表达式通过引用捕获变量时，将由程序负责确保 lambda 执行时引用所引的对象确实存在。因此，编译器可以直接使用该引用而无须在 lambda 产生的类中将其存储为数据成员。

相反，通过值捕获的变量被拷贝到 lambda 中。因此，这种 lambda 产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。举个例子，在10.3.2节中有一个 lambda，它的作用是找到第一个长度不小于给定值的 string 对象：

```C++
auto wc = find_if(words.begin(), words.end(), [sz](const string &a){return a.size() >= sz;});
```

该 lambda 表达式产生的类将形如：

```C++
class SizeComp {
public:
  SizeComp(size_t n): sz(n) {}
  bool operator()(const string &a) const {
    return a.size() > sz;
  }
private:
  size_t sz;
};
```

和我们的 ShorterString 类不同，上面这个类含有一个数据成员以及一个用于初始化该成员的构造函数。这个合成的类不含有默认构造函数，因此要想使用这个类必须提供一个实参：

```C++
auto wc = find_if(words.begin(), words.end(), SizeComp(sz));
```

lambda 表达式产生的类不含有默认构造函数、赋值运算符及默认析构函数：他是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。

## 14.8.2 标准库定义的函数对象

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus 类定义了一个函数调用运算符用于对一对运算对象执行 + 的操作；modulus 类定义了一个调用运算符执行二元的 % 操作；equal_to 类执行 ==，等等。

这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，plus<string>令 string 加法运算符作用于 string 对象；plus<int> 的运算对象是 int；plus<Sales_data>对 Sales_data 对象执行加法运算，以此类推：

```C++
plus<int> intAdd; // 可执行 int 加法的函数对
negate<int> intNegate; // 可对 int 值取反的函数对象
int sum = intAdd(10, 20);
sum = intNegate(intAdd(10, 20));
```

![](https://cdn.pkubailu.cn/img/14.2.png)

#### 在算法中使用标准库函数对象

表示运算符的函数对象类常用来替换算法中的默认运算符。如我们所知，在默认情况下排序算法使用 operator< 将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个 greater 类型的对象。该类将产生一个调用运算符并负责执行待排序类型的大于运算。例如，如果 svec 是一个 vector<string>，

```C++
// 传入一个临时的函数对象用于执行两个 string 对象的>比较运算
sort(svec.begin(), svec.end(), greater<string>());
```

则上面的语句将按照降序对 svec 进行排序。第三个实参是 greater<string> 类型的一个未命名的对象，因此当 sort 比较元素时，不再是使用默认的 < 运算符，而是调用给定的 greater 函数对象。该对象负责在 string 元素之间执行 > 比较运算。

需要特别注意的是，标准库规定其函数对象对于指针同样适用。我们之前曾经介绍过比较两个无关指针将产生未定义的行为，然而我们可能会希望通过比较指针的内存地址来 sort 指针的 vector。直接这么做将产生未定义的行为，因此我们可以使用一个标准库函数对象来实现该目的：

```C++
vector<string *> nameTable; // 指针的vector
// 错误：nameTable 中的指针彼此之间没有关系，所以<将产生未定义的行为
sort(nameTable.begin(), nameTable.end(),
    [](string *a, string *b) {
      return a < b;
    });
// 正确：标准库规定指针的less是定义良好的
sort(nameTable.begin(), nameTable.end(), less<string*>());
```

关联容器使用 less<key_type>对元素排序，因此我们可以定义一个指针的 set 或者在 map 中使用指针做为关键值而无须直接声明 less。

### 14.8.3 可调用对象与 function

C++语言中有几种可调用的对象：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。

和其他对象一样，可调用的对象也有类型。例如，每个 lambda 有它自己唯一的（未命名）类类型；函数及函数指针的类型则由其返回值类型和实参类型决定，等等。

然而，两个不同类型的可调用对象却可能共享同一种**调用形式**。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如：

```C++
int(int, int)
// 是一个函数类型，它接受两个int、返回一个int。
```

#### 不同类型可能具有相同的调用形式

对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把他们看成具有相同的类型。例如，考虑下列不同类型的可调用对象：

```C++
// 普通函数
int add(int i, int j) {return i + j; }
// lambda,其产生一个未命名的函数对象类
auto mod = [](int i, int j) {return i % j;};
// 函数对象类
struct divide {
  int operator()(int denominator,int divisor) {
    return denominator / divisor;
  }
};
```

上面这些可调用对象分别对其参数执行了不同的算术运算，尽管他们的类型各不相同，但是共享同一种调用形式：

```C++
int(int, int)
```

我们可能希望使用这些可调用对象构建一个简单的桌面计算器。为了实现这一目的，需要定义一个**函数表**用于存储指向这些可调用对象的“指针”。当程序需要执行某个特定的操作时，从表中查找该调用的函数。

在C++ 语言中，函数表很容易通过 map 来实现。对于此例来说，我们使用一个表示运算符符号的 string 对象作为关键字：使用实现运算符的函数作为值。当我们需要求给定运算符的值时，先通过运算符索引 map，然后调用找到的那个元素。

假定我们的所有函数都相互独立，并且只处理关于 int 的二元运算，则 map 可以定义成如下的形式：

```C++
// 构建从运算符到函数指针的映射关系，其中函数接受两个 int、返回一个int
map<string, int(*)(int, int)> binops;
// 我们可以按照下面的形式将add的指针添加到binops中：
binops.insert({"+", add}); // {"+", add}是一个pair
// 但是我们不能将mod或者divide存入binops:
binops.inser({"%", mod}); // 错误：mod不是一个函数指针
```

问题在于 mod 是个 lambda 表达式，而每个 lambda 有它自己的类类型，该类类型与存储在 binops 中的值的类型不匹配。

#### 标准库 function 类型

我们可以使用一个名为 function 的新的标准库类型解决上述问题，function 定义在 functional 头文件中。

![](https://cdn.pkubailu.cn/img/14.3.png)

function 是一个模板，和我们使用过的其他模板一样，当创建一个具体的 function 类型时我们必须提供额外的信息。在此例中，所谓额外的信息是指该 function 类型能够表示的对象的调用形式。参考其他模板，我们在一对尖括号内指定类型：

```C++
function<int(int, int)>
```

在这里我们声明了一个 function 类型，它可以表示接受两个 int、返回一个 int 的可调用对象。因此，我们可以用这个新声明的类型表示任意一种桌面计算器用到的类型：

```C++
function<int(int,int)> f1 = add; //函数指针
function<int(int,int)> f2 = divide(); //函数对象类的对象
function<int(int,int)> f3 = [](int i, int j) {return i * j;}; //lambda
cout << f1(4,2) << endl;
cout << f2(4,2) << endl;
cout << f3(4,2) << endl;
```

使用这个 function 类型我们可以重新定义 map:

```C++
// 列举了可调用对象与二元运算符对应关系的表格
// 所有可调用对象都必须接受两个int、返回一个int
// 其中的元素可以是函数指针、函数对象或者lambda
map<string, function<int(int,int)>> binops;
```

我们能把所有可调用对象，包括函数指针、lambda 或者函数对象在内，都添加到这个 map

```C++
map<string, function<int(int,int)>> binops = {
  {"+", add},
  {"-", std::minus<int>()},
  {"/", divide()},
  {"*", [](int i, int j) {return i * j;}},
  {"%", mod}
};
```

我们的 map 中包含了5个元素，尽管其中的可调用对象的类型各不相同，我们仍然能够把所有这些类型都存储在同一个 function<int(int,int)>类型中。

一如往常，当我们索引 map 时将得到关联值的一个引用。如果我们索引 binops，将得到 functon 对象的引用。function 类型重载了调用运算符，该运算符接受它自己的实参然后将其传递给存好的可调用对象：

```C++
binops["+"](10,5); // 调用add(10,5)
binops["-"](10,5); // 使用minus<int>对象的调用运算符
```

我们依次调用了 binops 中存储的每个操作。在第一个调用中，我们获得的元素存放着一个指向 add 函数的指针，因此调用 binops\["+"](10,5) 实际上是使用该指针调用 add，并传入10和5.在接下来的调用中，binops["-"]返回一个存放着 std::minus<int> 类型对象的 function，我们将执行该对象的调用运算符。

#### 重载的函数与 function

我们不能（直接）将重载函数的名字存入 function 类型的对象中：

```C++
int add(int i, int j) {return i + j;}
Sales_data add(const Sales_data&, const Sales_data&);
map<string, function<int(int,int)>> binops;
binops.insert({"+", add}); // 错误：哪个add？
```

解决上述二义性问题的一条途径是存储函数指针而非函数的名字：

```C++
int (*fp)(int,int) = add; // 指针所指的add是接受两个int的版本
binops.insert({"+", fp} ); // 正确：fp指向一个正确的add版本
```

同样，我们也能使用 lambda 来消除二义性：

```C++
// 正确：使用lambda来指定我们希望使用的 add 版本
binops.insert({"+", [](int a, int b) {return add(a, b);}});
```

lambda 内部的函数调用传入了两个 int，因此该调用只能匹配接受两个 int 的 add 版本，而这也正是执行 lambda 时真正调用的函数。

## 14.9 重载、类型转换与运算符

在7.5.4中我们看到由一个实参调用的非显示构造函数定义了一种隐式的类型转换，这种构造函数将实参类型的对象转换成类类型。我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算符共同定义了**类类型转换**，这样的转换有时也被称作**用户定义的**类型转换。

### 14.9.1 类型转换运算符

类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：

```C++
operator type() const;
```

其中 type 表示某种类型。类型转换运算符可以面向任意类型（除了 void之外）进行定义，只要该类型能作为函数的返回类型。因此，我们不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或者引用类型。

类型转换运算符既没有显示的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成 const 成员。

> Note! 一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是 const。

#### 定义含有类型转换运算符的类

举个例子，我们定义一个比较简单的类，令其表示0到255之间的一个整数：

```C++
class SmallInt {
public:
  SmallInt(int i = 0): val(i)
  {
    if (i < 0 || i > 255)
      throw std::out_of_range("bad SmallInt value");
  }
  operator int() const {return val;}
private:
  std::size_t val;
};
```

我们的 SmallInt 类既定义了向类类型的转换，也定义了从类类型向其他类型的转换。其中，构造函数将算术类型的值转换成 SmallInt 对象，而类型转换运算符将 SmallInt 对象转换成 int：

```C++
SmallInt si;
si = 4; // 首先将4隐式地转换成 SmallInt，然后调用 SmallInt::operator=
si + 3; // 首先将si隐式地转换成 int，然后执行整数的加法
```

尽管编译器一次只能执行一个用户定义的类型转换，但是隐式地用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。因此，我们可以将任何算术类型传递给 SmallInt 的构造函数。类似的，我们也能使用类型转换运算符将一个 SmallInt 对象转换成 int，然后再将所得的 int 转换成任何其他算术类型：

```C++
// 内置类型转换将 double 实参转换成 int
SmallInt si = 3.14;; // 调用SmallInt(int)构造函数
// SmallInt 的类型转换运算符将 si 转换成 int
si + 3.14; // 内置类型转换将所得的int继续转换成double
```

因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参。同时，尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值：

```C++
class SmallInt;
operator int(SmallInt&); // 错误：不是成员函数
class SmallInt {
public:
  int operator int() const; // 错误：指定了返回类型
  operator int(int = 0) const; // 错误：参数列表不为空
 operator int*() const {return 42;}; // 错误：42不是一个指针
};
```

#### 类型转换运算符可能产生意外结果

在实践中，类很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生，用户可能会感觉比较意外，而不是感受到了帮助。然而这条经验法则存在一种例外情况：对于类来说，定义向 bool 的类型转换还是比较普遍的现象。

在C++标准的早期版本中，如果类想定义一个向 bool 的类型转换，则它常常遇到一个问题：因为 bool 是一种算术类型，所以类类型的对象转换成 bool 后就能被用在任何需要算术类型的上下文中。这样的类型转换可能引发意想不到的结果，特别是当 istream 含有向 bool 的类型转换时，下面的代码仍将编译通过：

```C++
int i = 42;
cin << i; // 如果向bool的类型转换不是显示的，则该代码在编译器看来将是合法的！
```

这段程序试图将输出运算符作用与输入流。因为 istream 本身并没有定义 <<，所以本来代码应该产生错误。然而，该代码能使用 istream 的 bool 类型转换运算符将 cin 转换成 bool，而这个 bool 值接着会被提升成 int 并用作内置的左移运算符的左侧对象。这样一来，提升后的 bool 值（1或0）最终会被左移42个位置。这一结果显然与我们的预期大相径庭。

#### 显示的类型转换运算符

为了防止这样的异常情况发生，C++新标准引入了**显示的类型转换运算符**：

```C++
class SmallInt {
public:
  // 编译器不会自动执行这一类型转换
  explicit operator int() const {return val;}
};
```

和显式地构造函数一样，编译器（通常）也不会将一个显式地类型转换运算符用于隐式类型转换：

```C++
SmallInt si = 3; // 正确：SmallInt 的构造函数不是显式的
si + 3; // 错误：此处需要隐式的类型转换，但类的运算符是显式地
static_cast<int>(si) + 3; // 正确：显式地请求类型转换
```

当类型转换运算符是显式的时，我们也能执行类型转换，不过必须通过显式地强制类型转换才可以。

该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式地类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式地类型转换将被隐式的执行：

- if、while及do语句的条件部分
- for 语句头的条件表达式
- 逻辑非运算符(!)、逻辑或运算符（||）、逻辑与运算符（&&）的运算对象
- 条件运算符（？:）的条件表达式

#### 转换为 bool 

在标准库的早期版本中，IO类型定义了向 void*的转换规则，以求避免上面提到的问题。在C++11新标准下，IO标准库通过定义一个向 bool 的显示类型转换实现同样的目的。

无论我们什么时候在条件中使用流对象，都会使用为 IO 类型定义的 operator bool。例如：

```C++
while(std::cin >> value)
```

while语句的条件执行输入运算符，它负责将数据读入到 value 并返回 cin。为了对条件求值，cin 被 istream operator bool 类型转换函数隐式地执行了转换。如果 cin 的条件状态是 good，则该函数返回为真；否则该函数返回为假。

> Note! 向 bool 的类型转换通常在条件部分，因此 operator bool 一般定义成 explicit 的。

### 14.9.2 避免有二义性的类型转换

如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话，我们编写的代码将很可能会具有二义性。

在两种情况下可能产生多重转换路径。第一种情况是两个类提供相同的类型转换：例如，当A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符时，我们就说他们提供了相同的类型转换。

第二种情况是类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算术运算符，对某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则。

> WARNING! 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。

#### 实参匹配和相同的类型转换

在下面的例子中，我们定义了两种将 B 转换成 A 的方法：一种使用B的类型转换运算符、另一种使用A的以B为参数的构造函数：

```C++
// 最好不要在两个类之间构建相同的类型转换
struct B;
struct A {
  A() = default;
  A(const B&); // 把一个B转换成A
};
struct B {
  operator A() const; // 也是把一个B转换成A
};
A f(const A&);
B b;
A a = f(b); // 二义性错误：含义是f(B::operator A())
						// 还是f(A::A(const B&)) ?
```

因为同时存在两种由B获得A的方法，所以造成编译器无法判断应该运行哪个类型转换，也就是说，对f的调用存在二义性。该调用可以使用以B为参数的A的构造函数，也可以使用B当中把B转换成A的类型转换运算符。因为这两个函数效果相当、难分伯仲，所以该调用将产生错误。

如果我们确实想执行上述的调用，就不得不显示地调用类型转换运算符或者转换构造函数：

```C++
A a1 = f(b.operator A()); // 正确：使用B的类型转换运算符
A a2 = f(A(b)); // 正确：使用A的构造函数
```

值得注意的是，我们无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性。

#### 二义性与转换目标为内置类型的多重类型转换

另外如果类定义了一组类型转换，他们的转换源（或者转换目标）类型本身可以通过其他类型转换联系在一起，则同样会产生二义性问题。最简单也是最困扰我们的例子就是类当中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符。

例如，在下面的类中包含两个转换构造函数，它们的参数是两种不同的算术类型；同时还包含两个类型转换运算符，他们的转换目标也恰好是两种不同的算术类型：

```C++
struct A {
  A(int i = 0); // 最好不要创建两个转换源都是算术类型的类型转换
  A(double);
  operator int() const; // 最好不要创建两个转换对象都是算术类型的类型转换
  operator double() const;
};
void f2(long double);
A a;
f2(a); // 二义性错误：含义是f(A::operator int())
			 // 还是f(A::operator double()) ？
long lg; 
A a2(lg); //二义性错误：含义是A::A(int)还是A::A(double) ?
```

在对f2的调用中，哪个类型转换都无法精确匹配 long double。然而这连个类型转换都可以使用，只要后面再执行一次生成 long double 的标准类型转换即可。因此，在上面的两个类型转换中哪个都不比另一个更好，调用将产生二义性。

当我们试图用 long 初始化 a2 时也遇到了同样的问题，哪个构造函数都无法精确匹配 long 类型。它们在使用构造函数前都要求先将实参进行类型转换：

- 先执行 long 到 double 的标准类型转换，再执行 A(double)
- 先执行 long 到 int 的标准类型转换，再执行 A(int)

编译器没办法区分这两种转换序列的好坏，因此该调用将产生二义性。

调用 f2 及初始化 a2 的过程之所以会产生二义性，根本原因是它们所需的标准类型转换级别一致。当我们使用用户定义的类型转换时，如果转换过程包含标准类型转换，则标准类型转换的级别将决定编译器选择最佳匹配的过程：

```C++
short s = 42;
// 把short提升成int优于把short转换成double
A a3(s); // 使用A::A(int)
```

在此例中，把 short 提升成 int 操作要优于把 short 转换成 double 的操作，因此编译器将使用 A::A(int) 构造函数构造 a3，其中实参是 s（提升后）的值。

> Note! 当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。

![](https://cdn.pkubailu.cn/img/14.9.2.png) 

#### 重载函数与转换构造函数

当我们调用重载的函数时，从多个类型转换中进行选择将变得更加复杂。如果两个或多个类型转换都提供了同一种可行匹配，则这些类型转换一样好。

举个例子，当几个重载函数的参数分属不同的类类型时，如果这些类恰好定义了同样的转换构造函数，则二义性问题将进一步提升：

```C++
struct C  {
  C(int);
};
struct D {
  D(int);
};
void manip(const C&);
void manip(const D&);
manip(10); // 二义性错误：含义是manip(C(10)) 还是manip(D(10))
```

其中C和D都包含接受 int 的构造函数，两个构造函数各自匹配 manip 的一个版本。因此调用将具有二义性：它的含义可能是把 int 转换成 C，然后调用 manip 的第一个版本；也可能是把 int 转换成D，然后调用 manip 的第二个版本。

调用者可以显示地构造正确的类型从而消除二义性：

```C++
manip(C(10)); // 正确：调用manip(const C&)
```

> WARNING! 如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的设计存在不足。

#### 重载函数与用户定义的类型转换

当调用重载函数时，如果两个（或多个）用户定义的类型转换都提供了可行匹配，则我们认为这些类型转换一样好。在这个过程中，我们不会考虑任何可能出现的标准类型转换的级别。只有当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中出现的标准类型转换。

例如当我们调用 manip 时，即使其中一个类定义了需要对实参进行标准类型转换的构造函数，这次调用仍然会具有二义性：

```C++
struct E {
  E(double);
  // 其他成员
};
void manip2(const C&);
void manip2(const E&);
//二义性错误∶两个不同的用户定义的类型转换都能用在此处
manip2(10);  //含义是 manip2(C(10)) 还是manip2(E(double(10)))
```

在此例中，C 有一个转换源为 int 的类型转换，E 有一个转换源为 double 的类型转换。对于 manip2(10) 来说，两个 manip2 函数都是可行的：

- manip2(const C&) 是可行的，因为C有一个接受 int 的转换构造函数，该构造函数与实参精确匹配。
- manip2(const E&) 是可行的，因为E有一个接受 double 的转换构造函数，而且为了使用该函数我们可以利用标准类型转换把 int 转换成所需的类型。

因为调用重载函数所请求的用户定义的类型转换不止一个且彼此不同，所以该调用具有二义性。即使其中一个调用需要额外的标准类型转换而另一个调用能精确匹配，编译器也会将该调用标示为错误。

> Note! 在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。

### 14.9.3 函数匹配与重载运算符

重载的运算符也是重载的函数。因此，通用的函数匹配规则（参见6.4节）同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载的运算符。不过当运算符函数出现在表达式中时，候选函数集的规模要比我们使用调用运算符调用函数时更大。如果 a是一种类类型，则表达式 a sym b可能是

```C++
a.operatorsym(b); // a 有一个 operatorsym成员函数
operatorsym(a, b); // operatorsym是一个普通函数
```

和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数。

当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通非成员版本和内置版本。除此之外，如果左侧运算对象是类类型，则定义在该类中的运算符的重载版本也包含在候选函数内。

当我们调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载，这是因为我们用来调用命名函数的语法形式对于成员函数和非成员函数来说是不相同的。当我们通过类类型的对象（或者该对象的指针及引用）进行函数调用时，只考虑该类的成员函数。而当我们在表达式中使用重载的运算符时，无法判断正在使用的是成员函数还是非成员函数，因此二者都应该在考虑的范围内。

> Note! 表达式中运算符的候选函数集既应该包括成员函数，也应该包括非成员函数。

举个例子，我们为 SmallInt 类定义一个加法运算符：

```C++
class SmallInt {
  friend
	SmallInt operator+(const SmallInt&, const SmallInt&);
public:
	SmallInt(int = 0); //转换源为 int 的类型转换
	operator int() const { return val;} // 转换目标为 int的类型转换private:
	std::size_t val;
};
```

可以使用这个类将两个 SmallInt 对象相加，但如果我们试图执行混合模式的算术运算，就将遇到二义性的问题：

```C++
SmallInt s1,s2;
SmallInt s3 = s1 + s2;  // 使用重载的 operator+
int i= s3 + 0;  //二义性错误
```

第一条加法语句接受两个 SmallInt 值并执行 + 运算符的重载版本。第二条加法语句具有二义性：因为我们可以把0转换成 SmallInt，然后使用 SmallInt 的 +；或者把 s3 转换成 int，然后对于两个 int 执行内置的加法运算。

> WARNING! 如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。

