## 2.3 复合类型

### 2.3.1 引用

1. 程序把引用和它的初始值绑定到一起，而不是将初始值拷贝给引用。一定初始化完成，引用将和它的初始值对象一直绑定到一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
2. 引用并非对象，相反的它只是为一个已经存在的对象所起的另外一个名字。
3. 引用的类型都要和与之绑定的对象严格匹配。（但有两种例外情况）
4. 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。

### 2.3.2 指针

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须再定义的时候赋初值。和其它内置类型一样，再块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

3. 指针的类型都要和它所指向的对象严格匹配。（但有两种例外情况）

#### 空指针

空指针不指向任何对象。

```c++
# 生成空指针的方法
int *p = nullptr;
int *p = 0;
//需要首先#include cstdlib
int *p = NULL;
```

#### void* 指针

void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址追踪到底是个什么类型的对象并不了解。

利用void* 指针能做的事比较有限：拿他和别的指针比较、作为函数的输入输出、或者赋值给另外一个void\*指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

### 2.4 const限定符

#### 2.4.1 const的引用

1. 把引用绑定到const对象上，我们称之为**对常量的引用**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci = 1024;
const int &r1 = ci;
r1 = 0;  // 错误：ri是对常量的引用，常量无法被修改。
int &r2 = ci; // 错误：试图让一个非常量引用指向一个常量对象。他们的类型不一致！
```

**引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是：在初始化常量引用的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式**

```c++
int i = 42;
const int &r1 = i; // 允许将const int&绑定到一个普通int对象上;
const int &r2 = 42; // 正确：r2是一个常量引用;
const int &r3 = r1 * 2; // 正确： r3是一个常量引用;
int &r4 = r1 * 2;  // 错误：r4是一个普通的非常量引用;
```

**对const的引用可能引用一个并非const的对象**

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 42;
int &r1 = i; // 引用r1绑定对象i
const int &r2 = i; // r2也绑定对象i,但是不允许通过r2来修改i的值;
r1 = 0; // r1并非常量,i的值修改为0;
r2 = 0; // 错误：r2是一个常量引用，不可以做修改操作;
```

### 2.4.2 指针和const

与引用一样，也可以令指针指向常量或非常量.类似于常量引用，**指向常量的指针**不能用于改变其所指对象的值。

指针的类型必须与其所指向对象的类型一致，但是有两个例外。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象。

```c++
const double pi = 3.14; //pi是一个常量，他的值不能改变; 
double *ptr = &pi; // 错误：ptr 是一个普通指针;
const double *cptr = &pi; // 正确：cptr可以指向一个双精度常量;
*cptr = 42; // 错误：cptr指向的是一个常量，不能给cptr赋值;
double dval = 3.14;
cptr = &dval; // 正确：但是不能通过cptr改变dval的值;
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量，所为指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

> 所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以不觉得不去改变所指对象的值。

### 2.4.3 顶层const 

**顶层const **:表示指针本身是个常量。

**底层const**:表示指针所指对象是一个常量。

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显，其中顶层const不受什么影响。顶层const只是标注了变量本身是const不允许改变，而底层const表示了变量所指的对象的类型，在拷贝时要求拷贝对象和被拷贝对象类型一致！

### 2.4.4 constexpr 和常量表达式

**常量表达式**是指值不会改变并且在编译过程中就能得到计算结果的表达式。

一个对象或表达式是不是常量表达式由他的数据类型和初始值共同决定。

#### 字面值类型

常量表达式的值需要再编译时就得到计算，因此对声明constexptr时用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见、容易得到，就称之为“字面值类型” 算术类型、引用和指针都属于字面值类型。

一个constexpr指针的初始值必须是nullptr或者0，或者是存储在某个固定地址中的对象。

函数体外的对象其地址固定不变，能用来初始化constexpr指针。

函数体内定义的变量一般来说并非存放在固定地址中，不能初始化constexpr指针，但是函数体内也可以定义一类有效范围超出函数本身的变量，这类变量也有固定地址。

```c++
const int *p = nullptr; //p是一个指向整型常量的指针;
constexpr int *q = nullptr; // q是一个指向证书的常量指针
```

## 2.5 处理类型

### 2.5.1 类型别名

有两种方法可用于定义类型别名：

```c++
1.传统方法typedef:
typedef double wages; // wages是double的同义词
2.别名声明:
using SI = Sales_item; // SI是Sales_item的同义词
```

### 2.5.2 auto类型说明符

auto类型说明符能让编译器通过初始值来推算变量的类型，显然auto定义的变量必须有初始值。

auto一般会忽略掉顶层const，同时底层const则会保留下来。变量b、c是案例。

设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留！变量g是案例。

例子：

```c++
	 int i = 0, &r = i;
   auto a = r;   // auto = int a是整数
   const int ci = i, &cr = ci; 
   auto b = ci; // auto = int b是整数
   auto c = cr; // auto = int c是整数
   auto d = &i; // auto = int d是i的地址值
   auto e = &ci; // auto = int e是i的地址值
   auto &g = ci; // auto = const int  g是整型常量引用 绑定到ci上
```

### 2.5.3 decltype 类型指示符

**decltype**：它的作用是选择并返回操作数的数据类型。

decltype处理顶层const和引用的方式与auto有些不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&, y绑定到变量x 
decltype(ci) cj z; // 错误：z是一个引用，必须初始化
```

**需要指出的是，引用从来都是作为其所指对象的同义词出现，只有用在decltype处是一个例外**

#### decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

r是个引用，所以decltype(r)的结果是引用类型，如果想让结果类型是r所指对象的类型，可以把r作为表达式的一部分，例如r+0.

如果表达式的内容是解引用操作，则decltype将得到引用类型.

```c++
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // 正确：加法的结果是int,因此b是一个（未初始化的）int
decltype(*p) c; // 错误：c是int&,必须初始化
```

如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式，decltype就会得到引用类型：

```c++
decltype((i)) d; //错误： d是int&,必须初始化
decltype(i) e; // 正确：e是一个（未初始化的）int
```

> !切记：decltype((variable))（主义是双层括号）的结果永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。

## 2.6 自定义数据结构

### 2.6.3 编写自己的头文件

#### 预处理器概述

预处理变量有两种状态：已定义和未定义。

**#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**ifndef**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到**#endif**指令为止。

> 预处理变量无视C++语言中关于作用的规则。

> 头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符

# 第3章 字符串、向量和数组

## 3.1 命名空间的using声明

有了using声明就无需专门的前缀（形如命名空间::）也能使用所需的名字了。

using声明具有如下的形式:

```c++
using namespace::name;
// 一旦声明了上述语句，就可以直接访问命名空间中的名字
```

> **!头文件不应包含using声明**

## 3.2 标准库类型 string

### 3.2.1 定义和初始化string对象

![image-20211115175652876](https://cdn.pkubailu.cn/img/3.1.png)

#### 直接初始化和拷贝初始化

如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化。

### 3.2.2 string对象上的操作

![image-20211115180215371](https://cdn.pkubailu.cn/img/3.2.png)

#### 读写string对象

```c++
int main() 
{
  string s;
  cin >> s;
  cout << s << endl;
  return0;
}
// 在执行读取操作时，string对象会自动忽略开头的空白（即空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。
// 如果输入是"    hello world!    "则输出将是"hello"
```

#### 使用getline读取一整行

如果希望在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的>>运算符。

getline从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始输入的是换行符，那么所得的结果是个空string。

#### 比较 string 对象

字典序规则！

### 3.2.3 处理string对象中的字符

![image-20211115191804174](https://cdn.pkubailu.cn/img/3.3.png)

### 3.2.3 处理string对象中的字符

#### 处理每个字符？使用基于范围的for语句

语法形式：

```c++
for (declaration : expression)
  statement
```

## 3.3 标准库类型 vector

编译器根据模板创建类或函数的过程成为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

> vector 是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>

### 3.3.1 定义和初始化vector对象

![image-20211119003835476](https://cdn.pkubailu.cn/img/3.4.png)

#### 列表初始化vector对象

在大多数情况下这些初始化方式可以相互等价的使用，不过也并非一直如此。两种例外情况如下：

1. 使用拷贝初始化时（即使用=时）只能提供一个初始值；
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。

第三种特殊的要求是，如果提供的是初始元素值的列表，则只能爸初始值都放在花括号里进行列表初始化。

#### 值初始化

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个**值初始化的**元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。

```C++
vector<int> ivec(10); //10个元素 每个都初始化为0
vector<string> svec(10) // 10个元素，每个都是空的string对象
```

对这种初始化的方式有两个特殊限制：

1. 有些类要求必须明确的提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始化的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：

```C++
vector<int> vi = 10; // 错误：必须使用直接初始化的形式指定向量大小
```

#### 列表初始值还是元素数量

![image-20211121004224917](https://cdn.pkubailu.cn/img/列表初始值还是元素数量1.png)

![image-20211121004346187](https://cdn.pkubailu.cn/img/列表初始值还是元素数量2.png)

### 3.3.2 向vector对象中添加元素

可以先创建一个空的vector对象，然后在运行时再利用vector的成员函数**push_back**向其中添加元素。

>! 范围for语句体内不应该改变其所遍历序列的大小。

### 3.3.3 其他vector操作

![image-20211121005240108](https://cdn.pkubailu.cn/img/3.5.png)

> Note: 要使用size_type，需要先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型
>
> ```C++
> vector<int>::size_type  // 正确
> vector::size_type  // 错误
> ```

两个vector对象相等当且仅当他们所含的元素个数相同，而且对应位置的元素值也相同。

关系运算符依照字典顺序进行比较:如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。

只有当元素的值可比较时，vector对象才能被比较。

## 3.4 迭代器介绍

有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

### 3.4.1 使用迭代器

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。这些类型都拥有名为**begin**和**end**的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器，end成员则负责返回指向容器”尾元素的下一位置“的迭代器，简称为尾迭代器。

#### 迭代器运算符

![3.6](https://cdn.pkubailu.cn/img/3.6.png)

#### 将迭代器从一个元素移动到另外一个元素

迭代器使用递增（++）运算符来从一个元素移动到下一个元素。

> Note:因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。

#### 迭代器类型

迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型

![迭代器类型](https://cdn.pkubailu.cn/img/迭代器类型.png)

Const_iterator和常量指针差不多，鞥读取但不能修改它所值的元素值。相反，iterator的对象可读可写。

#### begin和end运算符

```C++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 的类型是vector<int>::iterator
auto it2 = cv.begin(); // it1 的类型是vector<int>::const_iterator
```

为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend：

```C++
auto it3 = v.cbegin(); // it3 的类型是vector<int>::const_iterator
```

不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

#### 结合解引用和成员访问操作

```C++
(*it).empty() // 解引用it，然后调用结果对象的empty()成员
*it.empty()  //错误： 试图访问it的名为empty的成员，但it是个迭代器，没有empty成员
```

为了简化上述表达式，C++语言定义了**箭头运算符**(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it->mem和(*it).mem表达的意思相同。

#### 某些对vector对象的操作会使迭代器失效

>**谨记！，但凡是使用了迭代器的循环体，都不要向迭代其所属的容器添加元素。**

### 3.4.2 迭代器运算

![3.7](https://cdn.pkubailu.cn/img/3.7.png)

#### 迭代器的算术运算

对于string或vector的迭代器来说，除了判断是否相等，还能使用关系运算符(<、<=、>、>=)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。例如，假设it和mid是同一个vector对象的两个迭代器，可以用下面的代码来比较他们所指的位置谁前谁后：

```C++
if (it < mid)
	// 处理vector前半部分的元素
```

## 3.5 数组

### 3.5.1 定义和初始化内置数组

默认情况下，数组的元素被默认初始化

> Warning! 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

#### 显示初始化数组

![显示初始化数组](https://cdn.pkubailu.cn/img/显示初始化数组.png)

#### 字符数组的特殊性

![字符数组的特殊性](https://cdn.pkubailu.cn/img/字符数组的特殊性.png )

#### 不允许拷贝和赋值

![不允许拷贝和赋值](https://cdn.pkubailu.cn/img/不允许拷贝和赋值.png )

#### 理解复杂的数组声明

定义数组的指针和数组的引用:

![数组的指针和数组的引用](https://cdn.pkubailu.cn/img/数组的指针和数组的引用.png )

对于数组而言，由内向外阅读要比从右向左好多了。例如：首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。

### 3.5.2 访问数组元素

最好的办法是使用范围for语言。

### 3.5.3 指针和数组

> Note: 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

这一结论有很多隐含的意思：

1. 当使用数组作为一个auto变量的初始值时。推断得到的类型是指针而非是数组：

```C++
int ia[] = {0,1,2,3,4}; // ia 是一个含有5个证书的数组
auto ia2(ia); // ia2是一个整型指针,指向ia的第一个元素
ia2 = 42; // 错误：ia2是一个指针，不能用int值给指针赋值
```

必须指出的是，当时用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个帧数构成的数组：

```C++
// ia3 是一个含有10个整数的数组
decltype(ia) ia3 = {0,1,2,3,4};
ia3 = p; // 错误：不能用整形指针给数组赋值
ia3[4] = i; //正确：把i的值赋给ia3的一个元素
```

#### 指针也是迭代器

允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

```C++
int arr[] = {0,1,2,3,4};
int *p = arr; // p指向arr的第一个元素
++p; // p指向arr[1]
```

利用指针的循环

```C++
int *e = &arr[10];
for (int *b = arr; b != e; ++b)
  cout << *b <<endl;
```

#### 标准库函数begin和end

C++新标准引入了两个名为begin和end的函数

```C++
int ia[] = {0,1,2,3,4}; // ia是一个含有10个整数的数组
int *beg = begin(ia); //指向ia首元素的指针
int *last = end(ia); // 指向arr尾元素的下一位置的指针
```

>Note:一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。

#### 指针运算

指向数组元素的指针可以执行所有的迭代器运算。例如：解引用、递增、比较、与整数相加、两个指针相减等。

给指针加（减）一个整数，得到的新指针仍需要指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置。

```C++
//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置
int *p = arr + sz; //使用警告:不要解引用！
int *p2 = arr + 10; // 错误：arr只有5各元素，p2的值未定义
// 如果计算所得的指针超出了上述范围就将产生错误，而且这种错误编译器一半发现不了。
```

如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果当然是0；

#### 解引用和指针运算的交互

```C++
int ia[] = {0,2,4,,6,8}; //含有5个整数的数组
int last = *(ia + 4); //正确：把last初始化成8，也就是ia[4]的值
```

#### 下标和指针

对数组执行下标运算其实是对指向数组元素的指针执行下标运算：

```C++
int i = ia[2]; //ia转换成指向数组首元素的指针
							//ia[2]得到(ia + 2)所指的元素
int *p = ia; // p指向ia的首元素
i = *(p + 2) // 等价于i = ia[2]
```

只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：

```c++
int *p = &ia[2]; // p指向索引为2的元素
int j = p[1]; // p[1]等价于 *(p=1),就是ia[3]表示的那个元素
int k = p[-2]; // p[-2]是ia[0]表示的那个元素
```

虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。

> 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。

### 3.5.4 C风格字符串

#### C标准库String函数

![C风格字符串函数](https://cdn.pkubailu.cn/img/3.8.png )

传入此类函数的指针必须指向以空字符作为结束的数组:

```C++
char ca[] = {'c','+','+'};  // 不以空字符结束
cout << strlen(ca) << endl; // 严重错误：ca没有以空字符结束
```

#### 比较字符串

比较C风格的字符串和比较标准库string对象的方法大相径庭。

string对象的比较可以用关系运算符，而C风格字符串用关系运算符比较的是指针所指对象的地址。

```C++
string s1 = "A string example";
string s2 = "A different example";
if (s1 < s2) // false: s2 小于 s1
const char ca1[] = "A string example";
const char ca2[] = "A different example";
if (ca1 < ca2) // 未定义的：试图比较两个无关地址
```

### 3.5.5 与旧代码的接口

#### 混用string对象和C风格字符串

允许使用字符串字面值来初始化string对象:

```c++
string s("hello world"); // s的内容是hello world
```

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代:

- 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值。
- 在string对象的假发运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

**上述性质反过来不成立！**

不能使用string对象直接初始化指向字符的指针。为了完成改功能，string住啊们提供了一个名为c_str的成员函数:

```c++
char *str = s; //错误: 不能用string对象初始化char*
const char *str = s.c_str(); // 正确
```

#### 使用数组初始化vector对象

不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。

```c++
int int_arr[] = {0,1,2,3,4};
vector<int> ivec(begin(int_arr), end(int_arr));
```

在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化的值在数组int_arr中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。

> 应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。

## 3.6 多维数组

C++语言中的多维数组其实是数组的数组。

```C++
size_t cnt = 0;
for (auto &row : ia) {
  for (auto &col : row) {
    col = cnt;
    cnt++;
  }
}
```

> Note! 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

#### 指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

> Note! 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。

```C++
// 在下述声明中，圆括号必不可少
int *ip[4]; // 整型指针的数组
int (*ip)[4]; // 指向含有4个整数的数组
```

```C++
//输出ia中每个元素的值，每个内层数组各占一行
// p指向含有4个整数的数组
for (auto p = ia; p != ia + 3; ++p) {
  for (auto q = *p; q != *p + 4; ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

使用标准库函数begin和end也能实现同样的功能。

```C++
for (auto p = begin(ia); p != end(ia); ++p) {
  for (auto q = begin(*p); q != end(*p); ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

# 第4章 表达式

## 4.1 基础

#### 重载运算符

当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为**重载运算符**

#### 左值和右值

当一个对象被用作右值得时候，用的是对象的值（内容）；当对象被用作左值得时候，用的是对象的身份（在内存中的位置）。

使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。例如：

假定p的类型是int *，因为解引用运算符生成左值，所以decltype(\*p)的结果是int&。另一方面，因为取地址运算符生成右值，所指decltype(&p)的结果是int**,也就是说，结果是一个指向整型指针的指针。

## 4.2 算术运算符

在除法运算中，如果两个运算对象的符号相同则商为正（如果不为0的话），否则商为负。C++新标准规定商一律向0取整（即直接切除小数部分）。

C++新标准规定：(-m)/n 和 m/(-n)都等于-(m/n), m%(-n)等于m%n, (-m)%n等于-(m%n)。

## 4.6 成员访问运算符

点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr->mem等价于(*p).mem

## 4.7 条件运算符

条件运算符的优先级非常低，因此当一条长表达式中潜逃了条件运算表达式时，通常需要在它的两端加上括号。

## 4.8 位运算符

左移运算符（<<）在右侧插入值为0的二进制位。右移运算符（>>）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。

## 4.9 sizeof运算符

sizeof运算符返回一条表达式或一个类型名字所占的字节数。

```C++
// 运算符的运算对象有两种形式
sizeof (type)
sizeof expr
// 在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值。
```

![](https://cdn.pkubailu.cn/img/sizeof运算符.png)

因为sizeof不会实际求运算对象的值，所以即使p是一个无效(即未初始化)的指针也不会有什么影响。sizeof不需要真的解引用指针也能知道它所指对象的类型。

sizeof运算符的结果部分地依赖于其作用的类型：

- 对char或者类型为char的表达式执行sizeof运算，结果得1.
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
- 对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。
- 对数组执行sizeof运算的带整个数组所占空间的大小，等价于对数组中所有的元素各执行一次siezof运算并将所得结果求和，注意，sizeof运算不会把数组转换成指针来处理。
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

```C++
// sizeof(ia)/sizeof(*ia)返回ia的元素数量
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz]; //正确：sizeof返回一个常量表达式
```

## 4.11 类型转换

在下面这些情况下，编译器会自动地转换运算对象的类型：

- 在大多数表达式中，比int类型晓得整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。

### 4.11.2 其他隐式类型转换

#### 数组转换成指针

在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针

```C++
int ia[10]; 
int *ip = ia; //ia 转换成指向数组首元素的指针
```

当数组被用作decltype关键字、取地址符(&)、sizeof及typeid等运算符的参数时，不会发生转换。

#### 指针的转换

常量整数值0或者字面值nullptr能转换成任意指针类型

指向任意非常量的指针能转换成void*

指向任意对象的指针能转换成const void*

#### 转换成布尔类型

存在一种从算术类型或指针类型向布尔类型自动转换的机制。

```C++
char *cp = get_string();
if (cp)   //如果指针cp不是0，条件为真
while(*cp) // 如果*cp不是空字符，条件为真
```

#### 转换成常量

允许将指向非常量类型的指针转换成指向相应常量类型的指针，对于引用也是这样。

```C++
int i;
const int &j = i; // 非常量转换成const int 的引用
const int *p = &i; //非常量的地址转换成const的地址
int &r = j, *q = p; //错误：不允许const转换成非常量
```

#### 类类型定义的转换

```C++
string s, t = "a value";  // 字符串字面值转换成string类型
while(cin >> s) // while 的条件部分把cin转换成布尔值
```

### 4.11.3 显示转换

#### 命名的强制类型转换

```C++
// 一个命名的强制类型转换具有如下形式：
cast-name<type>(expression);
// type 是转换的目标类型
// expression 是要转换的值
// cast-name 是 static_cast、dynamic_cast、const_cast、reinterpret_cast中的一种
```

####  static_cast

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

```C++
// 进行强制类型转换以便执行浮点数除法
double slope = static_cast<double>(j) / i;
```

当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。

static_cast对于编译器无法自动执行的类型转换也非常有用。

```C++
// 使用static_cast找回存在于void*指针中的值
void* p = &d; // 正确：任何非常量对象的地址都能存入void*
double *dp = static_cast<double*>(p); //正确：将void*转换回初始的指针类型
// 我们必须确保转换后所得的类型就是指针所指的类型
```

#### const_cast

const_cast只能改变运算对象的底层const

```C++
const char *pc;
char *p = const_cast<char*>(pc); // 正确：但是通过p写值是未定义的行为
```

只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。

#### reinterpret_cast

reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。例如：

```C++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。

# 第5章 语句

### 5.3.2 switch语句

case关键字和它对应的值一起被成为**case标签**。case标签必须是整型常量表达式：

```C++
char ch = getVal();
int ival = 42;
switch(ch) {
  case 3.14: // 错误：case标签不是一个整数
  case ival: // 错误：case标签不是常量
}
```

## 5.6 try语句块和异常处理

在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。

寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch字句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。

如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数，一般情况下，执行该函数将导致程序非正常退出。

如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。

# 第6章 函数

## 6.1 函数基础

函数有几个形参，我们就必须提供相同数量的实参。

#### 函数的形参列表

```C++
void f1(){} // 隐式地定义空形参列表
void f2(void) {} // 显式的定义空形参列表
```

#### 函数返回类型

函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

### 6.1.1 局部对象

#### 自动对象

我们把只存在于块执行期间的对象称为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

#### 局部静态对象

可以将局部变量定义成static类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对他有影响。

如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。

### 6.1.2 函数声明

函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称为**函数原型**

> Note! 含有函数声明的头文件应该被包含到定义函数的原文件中。

## 6.2 参数传递

### 6.2.3 const形参和实参

和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。

调用fcn函数时，既可以传入const int也可以传入int。忽略掉形参的顶层const可能产生意想不到的结果:

```C++
void fcn(const int i) { // fcn 能够读取i，但是不能向i写值 }
void fcn(int i) {} // 错误：重复定义了fcn(int)
```

当重载函数fcn时发生错误，因为顶层const被忽略掉了，所以在上面的代码中传入两个fcn函数的参数可以完全一样，所以第二个fcn是错误的。

#### 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地现值函数所能接受的实参类型。我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

### 6.2.4 数组形参

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：

1. 不允许拷贝数组
2. 使用数组时（通常）会将其转换成指针

尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：

```C++
// 尽管形式不同，但这三个print函数式等价的
// 每个函数都有一个const int*类型的形参
void print(const int*);
void print(const int[]); // 可以看出来，函数的意图是作用于一个数组
void print(const int[10]); // 这里的维度表示我们期望数组含有多少元素，实际不一定
```

> Warning! 和其他使用数组的代码一样，以数组为形参的函数也必须确保使用数组时不会越界。

#### 使用标记指定数组长度

管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。

```C++
void print(const char *cp) {
  if(cp){  // 若cp不是一个空指针
    while(*cp){ // 只要指针所指的字符不是空字符
      cout << *cp++;
    }
  }
}
```

#### 使用标准库规范

管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库的启发。

```C++
void print (const int *beg, const int *end) {
  while(beg != end) {
    cout << *beg++;
  }
}
```

#### 显示传递一个表示数组大小的形参

第三种管理数组实参的方法是专门定义一个表示数组大小的形参。

```C++
// const int ia[] 等价于const int *ia
// size 表示数组的大小
void print(const int ia[],size_t size) {
  for (size_t i = 0; i < size; ++i) {
    cout << ia[i];
  }
}
```

#### 数组形参和const

三个print函数都把数组形参定义成了指向const的指针。当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。

#### 数组引用形参

形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上。

```C++
// 正确： 形参是数组的引用，维度是类型的一部分
void print(int (&arr)[10]) {
  for (auto elem : arr) 
    cout << elem;
}
```

> **&arr 两端的括号必不可少**
>
> **f(int &arr[10])  // 错误： 将arr声明成了引用的数组**
>
> **f(int (&arr)[10])  //正确： arr是具有10个整数的整型数组的引用**

但是，这一用法也无形中限制了print函数的可用性，我们只能将函数作用于大小为10的数组。

#### 传递多维数组

```C++
void print(int (*matrix)[10], int rowSize) {}
// 上述语句将 matrix 声明成指向含有10个整数的数组的指针
```

> Note!
>
> **\*matrix 两端的括号必不可少：**
>
> **int *matrix[10]; // 10个指针构成的数组**
>
> **int (*matrix)[10]; // 指向含有10个整数的数组的指针**

```C++
void print(int matrix[][10], int rowSize) {}
```

matrix 的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。

### 6.2.5 main: 处理命令行选项

```C++
int main(int argc, char *argv[]) {}
```

第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。

当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

```C++
// 当命令行输入
prog -d -o ofile data0
// argv 应该包含如下的C风格字符串：
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

**当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入。**

#### 6.2.6 含有可变形参的函数

#### initializer_list 形参

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。

![](https://cdn.pkubailu.cn/img/6.1.png)

和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型：

```C++
initializer_list<string> ls; // initializer_list 的元素类型是string
initializer_list<int> li; // initializer_list的元素类型是int
```

和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法修改其中的值。

```C++
void error_msg(initializer_list<string> ls) {
  for (auto beg = ls.begin(); beg != ls.end(); ++beg)
    cout << *beg << endl;
}
// 想向initializer_list形参中传递一个值序列，则必须把序列放在一对花括号内
// expected和actual是string对象
if (expected != actual)
  error_msg({"functionX", expected, actual});
else
  error_msg({"functionX", "okay"})
```

#### 省略符形参

**省略符形参应该仅仅用于C和C++通用的类型。特别注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝**

省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：

```C++
void foo(parm_list,...);
void foo(...);
```

第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参无需类型检查。

### 6.3.2 有返回值函数

#### 不要返回局部对象的引用或指针

函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域：

```C++
const string &manip() {
  string ret;
  if (!ret.empty())
    return ret;  // 错误：返回局部对象的引用！
  else 
    return "Empty"; // 错误： "Empty"是一个局部临时变量
}
```

第一条return 语句来说，显然它返回的是局部对象的引用。

第二条return 语句中，字符串字面值转换成一个局部临时string对象，该对象和ret一样都是局部的。

