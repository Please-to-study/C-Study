# 第2章 变量和基本类型

## 2.1 基本内置类型

C++定义了一套包括**算术类型和空类型**在内的基本数据类型。

算术类型： 字符、整型数、布尔值、浮点数。

空类型不对应具体的值。

### 2.1.1 算术类型

算术类型分为两类：整型（包括字符和布尔类型在内）和浮点型。

![](https://cdn.pkubailu.cn/img/2.1.png)

### 2.1.2 类型转换

**切勿混用带符号类型和无符号类型**

> Note! 如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号类型数。

### 2.1.3 字面值常量

一个形如42的值被称作**字面值常量**，这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。

#### 整型和浮点型字面值

整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数。十进制字面值的类型是int、long和long long中尺寸最小的那个。

默认的，浮点型字面值是一个double。

#### 字符和字符串字面值

由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。

字符串字面值的类型实际上是由常量字符构成的数组。

## 2.2 变量

#### 列表初始化

```C++
// 初始化方式
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：

```C++
long double ld = 3.1415926;
int a{ld}, b = {ld}; // 错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld; // 正确：转换执行，且却是丢失了部分值
```

#### 默认初始化

如果是内置类型的变量未被显示初始化，他的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0.定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

类的对象如果没有显示的初始化，则其值由类决定。

### 2.2.2 变量的声明和定义的关系

变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。

如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示的初始化变量：

```C++
extern int i; // 声明i而非定义i
int j; // 声明并定义j
```

任何包含了显示初始化的声明即成为定义。

```C++
extern double pi = 3.1416; // 定义
```

在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。

## 2.3 复合类型

### 2.3.1 引用

1. 程序把引用和它的初始值绑定到一起，而不是将初始值拷贝给引用。一定初始化完成，引用将和它的初始值对象一直绑定到一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。
2. 引用并非对象，相反的它只是为一个已经存在的对象所起的另外一个名字。
3. 引用的类型都要和与之绑定的对象严格匹配。（但有两种例外情况）
4. 引用只能绑定到对象上，而不能与字面值或某个表达式的计算结果绑定到一起。

### 2.3.2 指针

1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
2. 指针无须在定义的时候赋初值。和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

3. 指针的类型都要和它所指向的对象严格匹配。（但有两种例外情况）

#### 空指针

空指针不指向任何对象。

```c++
# 生成空指针的方法
int *p = nullptr;
int *p = 0;
//需要首先#include cstdlib
int *p = NULL;
```

#### void* 指针

void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址追踪到底是个什么类型的对象并不了解。

利用void* 指针能做的事比较有限：拿他和别的指针比较、作为函数的输入输出、或者赋值给另外一个void\*指针。不能直接操作void*指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

### 2.3.3 理解复合类型的声明

#### 指向指针的指针

通过*的个数可以区分指针的级别。也就是说，\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针，以此类推：

```C++
int ival = 1024;
int *pi = &ival; // pi指向一个int型的数
int **ppi = &pi; // ppi指向一个int型的指针
```

解引用int型指针会得到一个int型的数，同样，解引用指向指针的指针会得到一个指针。此时为了访问最原始的那个对象，需要对指针的指针做两次解引用。

#### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```C++
int i = 42;
int *p = 0; // p是一个int型指针
int *&r = p; // r是对指针p的引用

r = &i; // 给r赋值&i就是让p指向i
*r = 0; // 解引用r得到i,也就是p指向的对象，将i的值改为0
```

### 2.4 const限定符

**如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字**

#### 2.4.1 const的引用

1. 把引用绑定到const对象上，我们称之为**对常量的引用**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci = 1024;
const int &r1 = ci;
r1 = 0;  // 错误：ri是对常量的引用，常量无法被修改。
int &r2 = ci; // 错误：试图让一个非常量引用指向一个常量对象。他们的类型不一致！
```

**引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况是：在初始化常量引用的时候允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式**

```c++
int i = 42;
const int &r1 = i; // 允许将const int&绑定到一个普通int对象上;
const int &r2 = 42; // 正确：r2是一个常量引用;
const int &r3 = r1 * 2; // 正确： r3是一个常量引用;
int &r4 = r1 * 2;  // 错误：r4是一个普通的非常量引用;
```

**对const的引用可能引用一个并非const的对象**

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未做限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int i = 42;
int &r1 = i; // 引用r1绑定对象i
const int &r2 = i; // r2也绑定对象i,但是不允许通过r2来修改i的值;
r1 = 0; // r1并非常量,i的值修改为0;
r2 = 0; // 错误：r2是一个常量引用，不可以做修改操作;
```

### 2.4.2 指针和const

与引用一样，也可以令指针指向常量或非常量.类似于常量引用，**指向常量的指针**不能用于改变其所指对象的值。

指针的类型必须与其所指向对象的类型一致，但是有两个例外。第一种例外的情况是允许令一个指向常量的指针指向一个非常量对象。

```c++
const double pi = 3.14; //pi是一个常量，他的值不能改变; 
double *ptr = &pi; // 错误：ptr 是一个普通指针;
const double *cptr = &pi; // 正确：cptr可以指向一个双精度常量;
*cptr = 42; // 错误：cptr指向的是一个常量，不能给cptr赋值;
double dval = 3.14;
cptr = &dval; // 正确：但是不能通过cptr改变dval的值;
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量，所为指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

> 所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以不觉得不去改变所指对象的值。

### 2.4.3 顶层const 

**顶层const **:表示指针本身是个常量。

**底层const**:表示指针所指对象是一个常量。

当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显，其中顶层const不受什么影响。顶层const只是标注了变量本身是const不允许改变，而底层const表示了变量所指的对象的类型，在拷贝时要求拷贝对象和被拷贝对象类型一致！

### 2.4.4 constexpr 和常量表达式

**常量表达式**是指值不会改变并且在编译过程中就能得到计算结果的表达式。

一个对象或表达式是不是常量表达式由他的数据类型和初始值共同决定。

#### 字面值类型

常量表达式的值需要在编译时就得到计算，因此对声明constexptr时用到的类型必须有所限制，因为这些类型一般比较简单，值也显而易见、容易得到，就称之为“字面值类型” 算术类型、引用和指针都属于字面值类型。

一个constexpr指针的初始值必须是nullptr或者0，或者是存储在某个固定地址中的对象。

函数体外的对象其地址固定不变，能用来初始化constexpr指针。

函数体内定义的变量一般来说并非存放在固定地址中，不能初始化constexpr指针，但是函数体内也可以定义一类有效范围超出函数本身的变量，这类变量也有固定地址。

```c++
const int *p = nullptr; //p是一个指向整型常量的指针;
constexpr int *q = nullptr; // q是一个指向整型的常量指针
```

## 2.5 处理类型

### 2.5.1 类型别名

有两种方法可用于定义类型别名：

```c++
1.传统方法typedef:
typedef double wages; // wages是double的同义词
2.别名声明:
using SI = Sales_item; // SI是Sales_item的同义词
```

#### 指针、常量和类型别名

如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。

```C++
typedef char *pstring; // pstring 是类型 char* 的别名
const pstring cstr = 0; // cstr 是指向char的常量指针
const pstring *ps; // ps 是一个指针，它的对象是指向char的常量指针
```

遇到一条使用了类型别名的声明语句时，人们往往会错误的尝试把类型别名替换成它本来的样子，以理解该语句的含义：

```C++
const char *cstr = 0; // 是对 const pstring cstr 的错误理解
```

**这种理解是错误的！**声明语句中用到pstring时，其基本数据类型是指针。可是用char\*重写了声明语句后，数据类型就变成了char，*成为了声明符的一部分。这样改写的结果是，const char成了基本数据类型。前后两种声明含义截然不同，前者声明了一个指向char的常量指针，改写后的形式则声明了一个指向const char的指针。

### 2.5.2 auto类型说明符

auto类型说明符能让编译器通过初始值来推算变量的类型，显然auto定义的变量必须有初始值。

auto一般会忽略掉顶层const，同时底层const则会保留下来。变量b、c是案例。

设置一个类型为auto的引用时，初始值中的顶层const属性仍然保留！变量g是案例。

例子：

```c++
	 int i = 0, &r = i;
   auto a = r;   // auto = int a是整数
   const int ci = i, &cr = ci; 
   auto b = ci; // auto = int b是整数
   auto c = cr; // auto = int c是整数
   auto d = &i; // auto = int d是i的地址值
   auto e = &ci; // auto = int e是i的地址值
   auto &g = ci; // auto = const int  g是整型常量引用 绑定到ci上
```

### 2.5.3 decltype 类型指示符

**decltype**：它的作用是选择并返回操作数的数据类型。

decltype处理顶层const和引用的方式与auto有些不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&, y绑定到变量x 
decltype(cj) z; // 错误：z是一个引用，必须初始化
```

**需要指出的是，引用从来都是作为其所指对象的同义词出现，只有用在decltype处是一个例外**

#### decltype和引用

如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

r是个引用，所以decltype(r)的结果是引用类型，如果想让结果类型是r所指对象的类型，可以把r作为表达式的一部分，例如r+0.

如果表达式的内容是解引用操作，则decltype将得到引用类型.

```c++
int i = 42, *p = &i, &r = i;
decltype(r + 0) b; // 正确：加法的结果是int,因此b是一个（未初始化的）int
decltype(*p) c; // 错误：c是int&,必须初始化
```

如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式，decltype就会得到引用类型：

```c++
decltype((i)) d; //错误： d是int&,必须初始化
decltype(i) e; // 正确：e是一个（未初始化的）int
```

> !切记：decltype((variable))（注意是双层括号）的结果永远是引用，而decltype(variable)的结果只有当variable本身就是一个引用时才是引用。

## 2.6 自定义数据结构

### 2.6.3 编写自己的头文件

#### 预处理器概述

预处理变量有两种状态：已定义和未定义。

**#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**ifndef**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直到遇到**#endif**指令为止。

> 预处理变量无视C++语言中关于作用域的规则。

> 头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符

# 第3章 字符串、向量和数组

## 3.1 命名空间的using声明

有了using声明就无需专门的前缀（形如命名空间::）也能使用所需的名字了。

using声明具有如下的形式:

```c++
using namespace::name;
// 一旦声明了上述语句，就可以直接访问命名空间中的名字
```

> **!头文件不应包含using声明**

## 3.2 标准库类型 string

### 3.2.1 定义和初始化string对象

![image-20211115175652876](https://cdn.pkubailu.cn/img/3.1.png)

#### 直接初始化和拷贝初始化

如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化。

### 3.2.2 string对象上的操作

![image-20211115180215371](https://cdn.pkubailu.cn/img/3.2.png)

#### 读写string对象

```c++
int main() 
{
  string s;
  cin >> s;
  cout << s << endl;
  return 0;
}
// 在执行读取操作时，string对象会自动忽略开头的空白（即空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。
// 如果输入是"    hello world!    "则输出将是"hello"
```

#### 使用getline读取一整行

如果希望在最终得到的字符串中保留输入时的空白符，这时应该用getline函数代替原来的>>运算符。

getline从给定的输入流中读取内容，直到遇到换行符为止（注意换行符也被读取进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，如果一开始输入的是换行符，那么所得的结果是个空string。

#### 比较 string 对象

字典序规则！

### 3.2.3 处理string对象中的字符

![image-20211115191804174](https://cdn.pkubailu.cn/img/3.3.png)

### 3.2.3 处理string对象中的字符

#### 处理每个字符？使用基于范围的for语句

语法形式：

```c++
for (declaration : expression)
  statement
```

## 3.3 标准库类型 vector

编译器根据模板创建类或函数的过程成为**实例化**，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

> vector 是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>

### 3.3.1 定义和初始化vector对象

![image-20211119003835476](https://cdn.pkubailu.cn/img/3.4.png)

#### 列表初始化vector对象

在大多数情况下这些初始化方式可以相互等价的使用，不过也并非一直如此。两种例外情况如下：

1. 使用拷贝初始化时（即使用=时）只能提供一个初始值；
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化。

第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化。

#### 值初始化

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个**值初始化的**元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。

```C++
vector<int> ivec(10); //10个元素 每个都初始化为0
vector<string> svec(10) // 10个元素，每个都是空的string对象
```

对这种初始化的方式有两个特殊限制：

1. 有些类要求必须明确的提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始化的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。
2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：

```C++
vector<int> vi = 10; // 错误：必须使用直接初始化的形式指定向量大小
```

#### 列表初始值还是元素数量

![image-20211121004224917](https://cdn.pkubailu.cn/img/列表初始值还是元素数量1.png)

![image-20211121004346187](https://cdn.pkubailu.cn/img/列表初始值还是元素数量2.png)

### 3.3.2 向vector对象中添加元素

可以先创建一个空的vector对象，然后在运行时再利用vector的成员函数**push_back**向其中添加元素。

>! 范围for语句体内不应该改变其所遍历序列的大小。

### 3.3.3 其他vector操作

![image-20211121005240108](https://cdn.pkubailu.cn/img/3.5.png)

> Note: 要使用size_type，需要先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型
>
> ```C++
> vector<int>::size_type  // 正确
> vector::size_type  // 错误
> ```

两个vector对象相等当且仅当他们所含的元素个数相同，而且对应位置的元素值也相同。

关系运算符依照字典顺序进行比较:如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。

只有当元素的值可比较时，vector对象才能被比较。

## 3.4 迭代器介绍

有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。

### 3.4.1 使用迭代器

和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。这些类型都拥有名为**begin**和**end**的成员，其中begin成员负责返回指向第一个元素（或第一个字符）的迭代器，end成员则负责返回指向容器”尾元素的下一位置“的迭代器，简称为尾迭代器。

#### 迭代器运算符

![3.6](https://cdn.pkubailu.cn/img/3.6.png)

#### 将迭代器从一个元素移动到另外一个元素

迭代器使用递增（++）运算符来从一个元素移动到下一个元素。

> Note:因为end返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。

#### 迭代器类型

迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型

![迭代器类型](https://cdn.pkubailu.cn/img/迭代器类型.png)

Const_iterator和常量指针差不多，能读取但不能修改它所指的元素值。相反，iterator的对象可读可写。

#### begin和end运算符

```C++
vector<int> v;
const vector<int> cv;
auto it1 = v.begin(); // it1 的类型是vector<int>::iterator
auto it2 = cv.begin(); // it2 的类型是vector<int>::const_iterator
```

为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend：

```C++
auto it3 = v.cbegin(); // it3 的类型是vector<int>::const_iterator
```

不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。

#### 结合解引用和成员访问操作

```C++
(*it).empty() // 解引用it，然后调用结果对象的empty()成员
*it.empty()  //错误： 试图访问it的名为empty的成员，但it是个迭代器，没有empty成员
```

为了简化上述表达式，C++语言定义了**箭头运算符**(->)。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说it->mem和(*it).mem表达的意思相同。

#### 某些对vector对象的操作会使迭代器失效

>**谨记！，但凡是使用了迭代器的循环体，都不要向迭代其所属的容器添加元素。**

### 3.4.2 迭代器运算

![3.7](https://cdn.pkubailu.cn/img/3.7.png)

#### 迭代器的算术运算

对于string或vector的迭代器来说，除了判断是否相等，还能使用关系运算符(<、<=、>、>=)对其进行比较。参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置）。例如，假设it和mid是同一个vector对象的两个迭代器，可以用下面的代码来比较他们所指的位置谁前谁后：

```C++
if (it < mid)
	// 处理vector前半部分的元素
```

## 3.5 数组

### 3.5.1 定义和初始化内置数组

默认情况下，数组的元素被默认初始化

> Warning! 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。另外和vector一样，数组的元素应为对象，因此不存在引用的数组。

#### 显示初始化数组

![显示初始化数组](https://cdn.pkubailu.cn/img/显示初始化数组.png)

#### 字符数组的特殊性

![字符数组的特殊性](https://cdn.pkubailu.cn/img/字符数组的特殊性.png )

#### 不允许拷贝和赋值

![不允许拷贝和赋值](https://cdn.pkubailu.cn/img/不允许拷贝和赋值.png )

#### 理解复杂的数组声明

定义数组的指针和数组的引用:

![数组的指针和数组的引用](https://cdn.pkubailu.cn/img/数组的指针和数组的引用.png )

对于数组而言，由内向外阅读要比从右向左好多了。例如：首先是圆括号括起来的部分，*Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。

### 3.5.2 访问数组元素

最好的办法是使用范围for语言。

使用数组下标的时候，通常将其定义为**size_t**类型。

数组除了大小固定这一特点外，其他用法与vector基本类似。

### 3.5.3 指针和数组

> Note: 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

这一结论有很多隐含的意思：

1. 当使用数组作为一个auto变量的初始值时。推断得到的类型是指针而非是数组：

```C++
int ia[] = {0,1,2,3,4}; // ia 是一个含有5个整数的数组
auto ia2(ia); // ia2是一个整型指针,指向ia的第一个元素
ia2 = 42; // 错误：ia2是一个指针，不能用int值给指针赋值
```

必须指出的是，当使用decltype关键字时上述转换不会发生，decltype(ia)返回的类型是由10个整数构成的数组：

```C++
// ia3 是一个含有5个整数的数组
decltype(ia) ia3 = {0,1,2,3,4};
ia3 = p; // 错误：不能用整形指针给数组赋值
ia3[4] = i; //正确：把i的值赋给ia3的一个元素
```

#### 指针也是迭代器

允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

```C++
int arr[] = {0,1,2,3,4};
int *p = arr; // p指向arr的第一个元素
++p; // p指向arr[1]
```

利用指针的循环

```C++
int *e = &arr[10];
for (int *b = arr; b != e; ++b)
  cout << *b <<endl;
```

#### 标准库函数begin和end

C++新标准引入了两个名为begin和end的函数

```C++
int ia[] = {0,1,2,3,4}; // ia是一个含有5个整数的数组
int *beg = begin(ia); //指向ia首元素的指针
int *last = end(ia); // 指向arr尾元素的下一位置的指针
```

>Note:一个指针如果指向了某种内置类型数组的尾元素的”下一位置“，则其具备与vector的end函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。

#### 指针运算

指向数组元素的指针可以执行所有的迭代器运算。例如：解引用、递增、比较、与整数相加、两个指针相减等。

给指针加（减）一个整数，得到的新指针仍需要指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置。

```C++
//正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置
int *p = arr + sz; //使用警告:不要解引用！
int *p2 = arr + 10; // 错误：arr只有5各元素，p2的值未定义
// 如果计算所得的指针超出了上述范围就将产生错误，而且这种错误编译器一般发现不了。
```

如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果当然是0；

#### 解引用和指针运算的交互

```C++
int ia[] = {0,2,4,,6,8}; //含有5个整数的数组
int last = *(ia + 4); //正确：把last初始化成8，也就是ia[4]的值
```

#### 下标和指针

对数组执行下标运算其实是对指向数组元素的指针执行下标运算：

```C++
int i = ia[2]; //ia转换成指向数组首元素的指针
							//ia[2]得到(ia + 2)所指的元素
int *p = ia; // p指向ia的首元素
i = *(p + 2) // 等价于i = ia[2]
```

只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：

```c++
int *p = &ia[2]; // p指向索引为2的元素
int j = p[1]; // p[1]等价于 *(p=1),就是ia[3]表示的那个元素
int k = p[-2]; // p[-2]是ia[0]表示的那个元素
```

虽然标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。

> 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。

### 3.5.4 C风格字符串

#### C标准库String函数

![C风格字符串函数](https://cdn.pkubailu.cn/img/3.8.png )

传入此类函数的指针必须指向以空字符作为结束的数组:

```C++
char ca[] = {'c','+','+'};  // 不以空字符结束
cout << strlen(ca) << endl; // 严重错误：ca没有以空字符结束
```

#### 比较字符串

比较C风格的字符串和比较标准库string对象的方法大相径庭。

string对象的比较可以用关系运算符，而C风格字符串用关系运算符比较的是指针所指对象的地址。

```C++
string s1 = "A string example";
string s2 = "A different example";
if (s1 < s2) // false: s2 小于 s1
const char ca1[] = "A string example";
const char ca2[] = "A different example";
if (ca1 < ca2) // 未定义的：试图比较两个无关地址
```

### 3.5.5 与旧代码的接口

#### 混用string对象和C风格字符串

允许使用字符串字面值来初始化string对象:

```c++
string s("hello world"); // s的内容是hello world
```

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代:

- 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值。
- 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）;在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

**上述性质反过来不成立！**

不能使用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数:

```c++
char *str = s; //错误: 不能用string对象初始化char*
const char *str = s.c_str(); // 正确
```

#### 使用数组初始化vector对象

不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用vector对象初始化数组。相反的，允许使用数组来初始化vector对象。

```c++
int int_arr[] = {0,1,2,3,4};
vector<int> ivec(begin(int_arr), end(int_arr));
```

在上述代码中，用于创建ivec的两个指针实际上指明了用来初始化的值在数组int_arr中的位置，其中第二个指针应指向待拷贝区域尾元素的下一位置。

> 应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。

## 3.6 多维数组

C++语言中的多维数组其实是数组的数组。

```C++
size_t cnt = 0;
for (auto &row : ia) {
  for (auto &col : row) {
    col = cnt;
    cnt++;
  }
}
```

> Note! 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

#### 指针和多维数组

当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。

> Note! 定义指向多维数组的指针时，千万别忘了这个多维数组实际上是数组的数组。

```C++
// 在下述声明中，圆括号必不可少
int *ip[4]; // 整型指针的数组
int (*ip)[4]; // 指向含有4个整数的数组
```

```C++
//输出ia中每个元素的值，每个内层数组各占一行
// p指向含有4个整数的数组
for (auto p = ia; p != ia + 3; ++p) {
  for (auto q = *p; q != *p + 4; ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

使用标准库函数begin和end也能实现同样的功能。

```C++
for (auto p = begin(ia); p != end(ia); ++p) {
  for (auto q = begin(*p); q != end(*p); ++q) {
    cout << *q << '';
  }
  cout << endl;
}
```

# 第4章 表达式

## 4.1 基础

#### 重载运算符

当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层含义，所以称之为**重载运算符**

#### 左值和右值

当一个对象被用作右值得时候，用的是对象的值（内容）；当对象被用作左值得时候，用的是对象的身份（在内存中的位置）。

使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。例如：

假定p的类型是int *，因为解引用运算符生成左值，所以decltype(\*p)的结果是int&。另一方面，因为取地址运算符生成右值，所以decltype(&p)的结果是int**,也就是说，结果是一个指向整型指针的指针。

## 4.2 算术运算符

在除法运算中，如果两个运算对象的符号相同则商为正（如果不为0的话），否则商为负。C++新标准规定商一律向0取整（即直接切除小数部分）。

C++新标准规定：(-m)/n 和 m/(-n)都等于-(m/n), m%(-n)等于m%n, (-m)%n等于-(m%n)。

## 4.6 成员访问运算符

点运算符获取类对象的一个成员；箭头运算符与点运算符有关，表达式ptr->mem等价于(*p).mem

## 4.7 条件运算符

条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算表达式时，通常需要在它的两端加上括号。

## 4.8 位运算符

左移运算符（<<）在右侧插入值为0的二进制位。右移运算符（>>）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位。

## 4.9 sizeof运算符

sizeof运算符返回一条表达式或一个类型名字所占的字节数。

```C++
// 运算符的运算对象有两种形式
sizeof (type)
sizeof expr
// 在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值。
```

![](https://cdn.pkubailu.cn/img/sizeof运算符.png)

因为sizeof不会实际求运算对象的值，所以即使p是一个无效(即未初始化)的指针也不会有什么影响。sizeof不需要真的解引用指针也能知道它所指对象的类型。

sizeof运算符的结果部分地依赖于其作用的类型：

- 对char或者类型为char的表达式执行sizeof运算，结果得1.
- 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
- 对指针执行sizeof运算得到指针本身所占空间的大小。
- 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。
- 对数组执行sizeof运算的带整个数组所占空间的大小，等价于对数组中所有的元素各执行一次siezof运算并将所得结果求和，注意，sizeof运算不会把数组转换成指针来处理。
- 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

```C++
// sizeof(ia)/sizeof(*ia)返回ia的元素数量
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz]; //正确：sizeof返回一个常量表达式
```

## 4.11 类型转换

在下面这些情况下，编译器会自动地转换运算对象的类型：

- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。

### 4.11.1 算数转换

1. 首先执行整型提升。如果结果的类型匹配，无需进行进一步的转换。如果两个运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。
2. 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。假设两个类型分别是unsigned int 和 int，则int类型的运算对象转换成unsigned int 类型。需要注意的是，如果int型的值恰好为负值，则采用取模的方式转换。
3. 剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

### 4.11.2 其他隐式类型转换

#### 数组转换成指针

在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针

```C++
int ia[10]; 
int *ip = ia; //ia 转换成指向数组首元素的指针
```

当数组被用作decltype关键字、取地址符(&)、sizeof及typeid等运算符的参数时，不会发生转换。

#### 指针的转换

常量整数值0或者字面值nullptr能转换成任意指针类型

指向任意非常量的指针能转换成void*

指向任意对象的指针能转换成const void*

#### 转换成布尔类型

存在一种从算术类型或指针类型向布尔类型自动转换的机制。

```C++
char *cp = get_string();
if (cp)   //如果指针cp不是0，条件为真
while(*cp) // 如果*cp不是空字符，条件为真
```

#### 转换成常量

允许将指向非常量类型的指针转换成指向相应常量类型的指针，对于引用也是这样。

```C++
int i;
const int &j = i; // 非常量转换成const int 的引用
const int *p = &i; //非常量的地址转换成const的地址
int &r = j, *q = p; //错误：不允许const转换成非常量
```

#### 类类型定义的转换

```C++
string s, t = "a value";  // 字符串字面值转换成string类型
while(cin >> s) // while 的条件部分把cin转换成布尔值
```

### 4.11.3 显示转换

#### 命名的强制类型转换

```C++
// 一个命名的强制类型转换具有如下形式：
cast-name<type>(expression);
// type 是转换的目标类型
// expression 是要转换的值
// cast-name 是 static_cast、dynamic_cast、const_cast、reinterpret_cast中的一种
```

####  static_cast

任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。

```C++
// 进行强制类型转换以便执行浮点数除法
double slope = static_cast<double>(j) / i;
```

当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。

static_cast对于编译器无法自动执行的类型转换也非常有用。

```C++
// 使用static_cast找回存在于void*指针中的值
void* p = &d; // 正确：任何非常量对象的地址都能存入void*
double *dp = static_cast<double*>(p); //正确：将void*转换回初始的指针类型
// 我们必须确保转换后所得的类型就是指针所指的类型
```

#### const_cast

const_cast只能改变运算对象的底层const

```C++
const char *pc;
char *p = const_cast<char*>(pc); // 正确：但是通过p写值是未定义的行为
```

只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。

#### reinterpret_cast

reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。例如：

```C++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

我们必须牢记pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误。

# 第5章 语句

### 5.3.2 switch语句

case关键字和它对应的值一起被成为**case标签**。case标签必须是整型常量表达式：

```C++
char ch = getVal();
int ival = 42;
switch(ch) {
  case 3.14: // 错误：case标签不是一个整数
  case ival: // 错误：case标签不是常量
}
```

## 5.6 try语句块和异常处理

在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。

寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch字句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。

如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数，一般情况下，执行该函数将导致程序非正常退出。

如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。

# 第6章 函数

## 6.1 函数基础

函数有几个形参，我们就必须提供相同数量的实参。

#### 函数的形参列表

```C++
void f1(){} // 隐式地定义空形参列表
void f2(void) {} // 显式的定义空形参列表
```

#### 函数返回类型

函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

### 6.1.1 局部对象

#### 自动对象

我们把只存在于块执行期间的对象称为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

#### 局部静态对象

可以将局部变量定义成static类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对他有影响。

如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。

### 6.1.2 函数声明

函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称为**函数原型**

> Note! 含有函数声明的头文件应该被包含到定义函数的原文件中。

## 6.2 参数传递

### 6.2.3 const形参和实参

和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。换句话说，形参的顶层const被忽略掉了。

调用fcn函数时，既可以传入const int也可以传入int。忽略掉形参的顶层const可能产生意想不到的结果:

```C++
void fcn(const int i) { // fcn 能够读取i，但是不能向i写值 }
void fcn(int i) {} // 错误：重复定义了fcn(int)
```

当重载函数fcn时发生错误，因为顶层const被忽略掉了，所以在上面的代码中传入两个fcn函数的参数可以完全一样，所以第二个fcn是错误的。

#### 尽量使用常量引用

把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地现值函数所能接受的实参类型。我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

### 6.2.4 数组形参

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：

1. 不允许拷贝数组
2. 使用数组时（通常）会将其转换成指针

尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：

```C++
// 尽管形式不同，但这三个print函数式等价的
// 每个函数都有一个const int*类型的形参
void print(const int*);
void print(const int[]); // 可以看出来，函数的意图是作用于一个数组
void print(const int[10]); // 这里的维度表示我们期望数组含有多少元素，实际不一定
```

> Warning! 和其他使用数组的代码一样，以数组为形参的函数也必须确保使用数组时不会越界。

#### 使用标记指定数组长度

管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。

```C++
void print(const char *cp) {
  if(cp){  // 若cp不是一个空指针
    while(*cp){ // 只要指针所指的字符不是空字符
      cout << *cp++;
    }
  }
}
```

#### 使用标准库规范

管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库的启发。

```C++
void print (const int *beg, const int *end) {
  while(beg != end) {
    cout << *beg++;
  }
}
```

#### 显示传递一个表示数组大小的形参

第三种管理数组实参的方法是专门定义一个表示数组大小的形参。

```C++
// const int ia[] 等价于const int *ia
// size 表示数组的大小
void print(const int ia[],size_t size) {
  for (size_t i = 0; i < size; ++i) {
    cout << ia[i];
  }
}
```

#### 数组形参和const

三个print函数都把数组形参定义成了指向const的指针。当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。

#### 数组引用形参

形参也可以是数组的引用，此时，引用形参绑定到对应的实参上，也就是绑定到数组上。

```C++
// 正确： 形参是数组的引用，维度是类型的一部分
void print(int (&arr)[10]) {
  for (auto elem : arr) 
    cout << elem;
}
```

> **&arr 两端的括号必不可少**
>
> **f(int &arr[10])  // 错误： 将arr声明成了引用的数组**
>
> **f(int (&arr)[10])  //正确： arr是具有10个整数的整型数组的引用**

但是，这一用法也无形中限制了print函数的可用性，我们只能将函数作用于大小为10的数组。

#### 传递多维数组

```C++
void print(int (*matrix)[10], int rowSize) {}
// 上述语句将 matrix 声明成指向含有10个整数的数组的指针
```

> Note!
>
> **\*matrix 两端的括号必不可少：**
>
> **int *matrix[10]; // 10个指针构成的数组**
>
> **int (*matrix)[10]; // 指向含有10个整数的数组的指针**

```C++
void print(int matrix[][10], int rowSize) {}
```

matrix 的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。

### 6.2.5 main: 处理命令行选项

```C++
int main(int argc, char *argv[]) {}
```

第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。

当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

```C++
// 当命令行输入
prog -d -o ofile data0
// argv 应该包含如下的C风格字符串：
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

**当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户的输入。**

#### 6.2.6 含有可变形参的函数

#### initializer_list 形参

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。

![](https://cdn.pkubailu.cn/img/6.1.png)

和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型：

```C++
initializer_list<string> ls; // initializer_list 的元素类型是string
initializer_list<int> li; // initializer_list的元素类型是int
```

和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法修改其中的值。

```C++
void error_msg(initializer_list<string> ls) {
  for (auto beg = ls.begin(); beg != ls.end(); ++beg)
    cout << *beg << endl;
}
// 想向initializer_list形参中传递一个值序列，则必须把序列放在一对花括号内
// expected和actual是string对象
if (expected != actual)
  error_msg({"functionX", expected, actual});
else
  error_msg({"functionX", "okay"})
```

#### 省略符形参

**省略符形参应该仅仅用于C和C++通用的类型。特别注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝**

省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：

```C++
void foo(parm_list,...);
void foo(...);
```

第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参无需类型检查。

### 6.3.2 有返回值函数

#### 不要返回局部对象的引用或指针

函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域：

```C++
const string &manip() {
  string ret;
  if (!ret.empty())
    return ret;  // 错误：返回局部对象的引用！
  else 
    return "Empty"; // 错误： "Empty"是一个局部临时变量
}
```

第一条return 语句来说，显然它返回的是局部对象的引用。

第二条return 语句中，字符串字面值转换成一个局部临时string对象，该对象和ret一样都是局部的。

### 6.3.3 返回数组指针

#### 声明一个返回数组指针的函数

```C++
int arr[10]; //arr 是一个含有10个整数的数组
int *p1[10]; // p1是一个含有10个指针的数组
int (*p1)[10]; // p2 是一个指针，它指向含有10个整数的数组
```

和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：

```c++
Type (*function(parameter_list))[dimension]
// (*function(parameter_list))两端的括号必须存在。
```

具体的例子：

```C++
int (*func(int i))[10];
```

可以按照以下的顺序来逐层理解该声明的含义：

- func(int i) 表示调用func函数时需要一个int类型的实参。
- (*func(int i)) 意味着我们可以对函数调用的结果执行解引用操作
- (*func(int i))[10] 表示解引用func的调用将得到一个大小为10的数组
- int (*func(int i))[10] 表示数组中的元素是int类型

#### 使用尾置返回类型

简化上述func声明的方法，还可以使用**尾置返回类型**。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效。尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto:

```C++
// func 接受一个int 类型的实参，返回一个指针，该指针指向含有10个整数的数组
auto func(int i) -> int(*)[10];
```

因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。 

#### 使用 decltype

如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。

```C++
int odd[] = {1,3,5,7,9};
int event[] = {0,2,4,6,8};
// 返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i){
  return (i % 2) ? &odd : &even; //返回一个指向数组的指针
}
```

因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回值真还必须在函数声明时加一个*符号。

## 6.4 函数重载

如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为**重载函数**。

#### 定义重载函数

对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。

#### 判断两个形参的类型是否相异

有时候两个形参列表看起来不一样，但实际上是相同的：

```C++
// 声明的是同一个函数
Record lookup(const Account &acct);
Record lookup(const Account &);  // 省略了形参的名字
```

#### 重载和const形参

顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：

```C++
Record lookup(Phone);
Record lookup(const Phone); 

Record lookup(Phone*);
Record lookup(Phone* const);
```

另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：

```C++
// 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同
// 定义了4个独立的重载函数
Record lookup(Account &); // 函数作用于Account的引用
Record lookup(Account &); // 新函数，作用于常量引用

Record lookup(Account *); // 新函数，作用于指向Account的指针
Record lookup(const Account *); // 新函数，作用于指向常量的指针
```

#### const_cast 和 重载

const_cast 在重载函数的情景中最有用。举个例子：

```C++
// 比较两个string对象的长度，返回较短的那个引用
const string &shorterString(const string &s1, const string &s2){
  return s1.size() <= s2.size() ? s1 : s2;
}
```

这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string 的引用。因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点：

```C++
string &shorterString(string &s1, string &s2){
  auto &r = shorterString(const_cast<const string&>(s1),const_cast<const string&>(s2));
  return const_cast<string&>r;
}
```

在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string&，这显然是安全的。

#### 调用重载的函数

调用重载函数时有三种可能的结果：

- 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
- 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。
- 有多余一个函数可以匹配，但是没一个都不是最明显的最佳选择。此时也将发生错误，成为二义性调用。

### 6.4.1 重载与作用域

重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。

> Note! 在C++语言中，名字查找发生在类型检查之前。

## 6.5 特殊用途语言特性

### 6.5.1 默认实参

我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，他后面的所有形参都必须有默认值。

```C++
typedef string::size_type sz; 
string screen(sz ht = 24, sz wid = 80, char background = ' ');
```

函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参，例如：要想覆盖background的默认值，必须为ht何wid提供实参：

```C++
window = screen(,,'?'); // 错误：只能省略尾部的实参
window = screen('?'); // 调用screen('?',80,' ')
```

当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。

#### 默认实参声明

一个函数通常只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值得形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

```C++
string screen(sz,sz,char = '');
string screen(sz,sz,char = '*'); // 错误：重复声明
// 但是可以按照如下形式添加默认实参：
string screen(sz = 24, sz = 80, char); //正确：添加默认实参
```

#### 默认实参初始值

局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：

```C++
// wd、def、ht的声明必须出现在函数之外
sz wd = 80;
char def = ' ';
sz ht();
string screen(sz = ht(), sz = wd, char = def);
string window = screen(); //调用 screen(ht(),80,' ')
```

用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：

```C++
void f2(){
  def = '*'; // 改变默认实参的值
  sz wd = 100; // 隐藏了外层定义的wd，但是没有改变默认值
  window = screen(); // 调用了screen(ht(),80,'*');
}
```

### 6.5.2 内联函数和 constexpr 函数

#### 内联函数可避免函数调用的开销

将函数指定为内联函数，通常就是将它在每个调用点上“内联地”展开。

假设我们把shorterString函数定义成内联函数，则如下调用

```C++
cout << shorterString(s1,s2) << endl;
```

将在编译过程中展开成类似下面的形式

```C++
cout << (s1.size() < s2.size() ? s1 : s2) << endl;
```

从而消除了shorterString函数的运行时开销。

在shorterString函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了:

```C++
inline const string &
shorterString(const string &s1, const string &s2){
  return s1.size() < s2.size() ? s1 : s2; 
}
```

一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。

#### constexpr 函数

constexpr函数是指能用于常量表达式的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句：

```C++
constexpr int new_sz() {return 42;}
constexpr int foo = new_sz(); // 正确： foo是一个常量表达式
```

执行该初始化任务时，编译器把对constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐士地指定为内联函数。

我们允许constexpr函数的返回值并非一个常量：

```C++
// 如果arg是常量表达式，则scale(arg)也是常量表达式
constexpr size_t scale(size_t cnt) {return new_sze() * cnt; }
// 当scale的实参实参是常量表达式时，它的返回值也是常量表达式：反之则不然：
int arr[scale(2)]; // 正确： scale(2)是常量表达式
int i = 2; // i 不是常量表达式
int a2[scale(i)] // 错误：scale(i)不是常量表达式
```

> Note! constexpr 函数不一定返回常量表达式

#### 把内联函数和constexpr 函数放在头文件内

对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。

### 6.5.3 调试帮助

#### assert 预处理宏

assert是一种预处理宏。所谓预处理宏其实是一个预处理变量，他的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：

```C++
assert(expr);
```

首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。

和预处理变量一样，宏名字在程序内必须唯一。含有cassert头文件的程序不能再定义名为assert的变量、函数或者其他实体。在实际编译过程中，即使我们没有包含cassert头文件，也最好不要为了其他目的使用assert。很多头文件都包含了cassert，这就意味着即使你没有直接包含cassert，它也很有可能通过其他途径包含在你的程序中。

```C++
// assert宏常用于检查“不能发生”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时，程序可以包含一条如下所示的语句：
assert(word.size() > threshold)；
```

#### NDEBUG预处理变量

assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。

我们可以使用一个#define 语句定义NDEBUG，从而关闭调试状态。

除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码：如果定义了NDEBUG，这些代码将被忽略。

## 6.6 函数匹配

#### 确定候选函数和可行函数

1. 选定本次调用对应的重载函数集。
2. 考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数。
3. 从候选函数中选择与本次调用最匹配的函数。

#### 寻找最佳匹配（如果有的话）

基本思想是：实参类型与形参类型越接近，他们匹配的越好。

> Note! 调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。

### 6.6.1 实参类型转换

为了确定最佳匹配，编译器将实参类型到形参类型的转换划分为几个等级。

1. 精确匹配，包括以下情况：
   - 实参类型和形参类型相同。
   - 实参从数组类型或函数类型转换成对应的指针类型。
   - 向实参添加顶层const或者从实参中删除顶层const。
2. 通过const转换实现的匹配。
3. 通过类型提升实现的匹配。
4. 通过算术类型转换或指针转换实现的匹配。
5. 通过类类型转换实现的匹配。

#### 函数匹配和const实参

```C++
Record lookup(Account&);
Record lookup(const Account&);
const Account a;
Account b;

lookup(a); // 调用lookup(const Account&)
lookup(b); // 调用lookup(Account&)
```

在第一个调用中，我们传入的是const 对象a。因为不能把普通引用绑定到const对象上，所以此例中唯一可行的函数是以常量引用作为形参的那个函数。

在第二个调用中，两个函数都是可行的，因为我们既可以使用b初始化常量引用也可以用它初始化非常量引用。然而，用非常量对象初始化常量引用需要类型转换。

指针也同样如此！

## 6.7 函数指针

函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参共同决定，与函数名无关。

```C++
// 比较两个string对象的长度
bool lengthCompare(const string &,const string &);
```

该函数的类型是bool（const string&, const string&）。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：

```C++
// pf 指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型
bool (*pf) (const string &,const string &); // 未初始化
```

从我们声明的名字开始观察，pf前面有个*，因此pf是指针；右侧是形参列表，表示pf指向的是函数；在观察左侧，发现函数的返回类型是布尔值。因此，pf就是一个指向函数的指针，其中该函数的参数是两个const string的引用，返回值是bool类型。

> Note! *pf 两端的括号必不可少。如果不写这对括号，则pf是一个返回值为bool指针的函数。

#### 使用函数指针

当我们把函数名作为一个值使用时，该函数自动的转换成指针。例如，按照如下形式我们可以将lengthCompare的地址赋给pf：

```C++
pf = lengthCompare; // pf 指向名为lengthCompare的函数
pf = &lengthCompare; // 等价的赋值语句：取地址符是可选的
```

此外，我们还能直接使用指向函数的指针调用该函数，无需提前解引用指针：

```C++
bool b1 = pf("hello","goodbye"); // 调用lengthCompare函数
bool b2 = (*pf)("hello","goodbye"); // 一个等价的调用
bool b3 = lengthCompare("hello","goodbye"); // 另一个等价的调用
```

在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个函数。

```C++
string::size_type sumLength(const string&, const string&);
bool cstringCompare(const char*, const char*);
pf = 0; // 正确：pf不指向任何函数
pf = sumlength; // 错误：返回类型不匹配
pf = cstringCompare; // 错误：形参类型不匹配
pf = lengthCompare; // 正确：函数和指针的类型精确匹配
```

#### 重载函数的指针

当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。如果定义了指向重载函数的指针

```C++
void ff(int*);
void ff(unsigned int);

void (*pf1)(unsigned int) = ff; // pf1 指向 ff(unsigned)
```

编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配

```C++
void (*pf2)(int) = ff; // 错误：没有任何一个ff与该形参列表匹配
double (*pf3)(int*) = ff; // 错误： 返回类型不匹配
```

#### 函数指针形参

和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用：

```C++
// 第三个形参是函数类型，它会自动地转换成指向函数的指针
void useBigger(const string &s1, const string &s2, bool pf(const string &, const string &));
// 等价的声明：显示的将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2, bool (*pf)(const string &, const string &)); 
// 我们可以直接把函数作为实参使用，此时它会自动转换成指针：
useBigger(s1,s2,lengthCompare);
```

正如useBigger的声明语句所示，直接使用函数指针类型显得冗余而繁琐。类型别名和decltype能让我们简化使用了函数指针的代码：

```C++
没有看懂！！！ P222页
```

#### 返回指向函数的指针

和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而， 我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要向声明一个返回函数指针的函数，最简单的办法是使用类型别名：

```C++
using F = int(int*, int); // F是函数类型，不是指针
using PF = int(*)(int*, int); // PF是指针类型
```

必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针，我们必须显示的将返回类型指定为指针：

```C++
PF f1(int); // 正确： PF 是指向函数的指针，f1返回指向函数的指针
F f1(int); // 错误：F是函数类型，f1不能返回一个函数
F *f1(int); // 正确：显示的指定返回类型是指向函数的指针
```

当然，我们也能用下面的形式直接声明f1:

```C++
int (*f1(int))(int*, int);
// 按照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表，所以f1是一个函数：f1前面有*，所以f1返回一个指针，进一步观察发现，指针的类型本身也含有形参列表，因此指针指向函数，该函数的返回类型是int
```

我们还可以使用尾置返回类型的方式

```C++
auto f1(int) -> int (*)(int*, int);
```

#### 将auto和decltype用于函数指针类型

如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。

```C++
string::size_type sumLength(const string&, const string&);
string::size_type largeLength(const string&, const string&);
// 根据其形参的取值，getFcn函数返回指向 sumLength 或者 largeLength的指针
decltype(sumLength) *getFcn(const string &);
```

声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们需要显示的加上*以表明我们需要返回指针。

# 第7章 类

## 7.1 定义抽象数据类型

### 7.1.2 定义改进的 Sales_data 类

定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，例如add、read和print等，它们的定义和声明都在类的外部。

```C++
// 改进的Sales_data类如下所示
struct Sales_data {
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
// Sales_data的非成员接口函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```

> 定义在类内部的函数是隐式的inline函数

#### 定义成员函数

尽管所有成员都必须在类的内部声明，但是成员函数可以定义在类内也可以定义在类外。对于Sales_data类来说，isbn函数定义在了类内，而combine和avg_price定义在了类外。

```C++
std::string isbn() const { return bookNo; }
```

isbn函数是如何获得bookNo成员所依赖的对象的呢？

#### 引入this

```C++
// 调用isbn函数
total.isbn()
```

当我们调用成员函数时，实际上是在替某个对象调用它。如果isbn指向Sales_data的成员(例如bookNo)，则它隐式地指向调用该函数的对象的成员。

成员函数通过一个名为**this**的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this。

```C++
total.isbn()
// 编译器负责把total的地址传递给isbn的隐士形参this，可以认为编译器将该调用重写成了如下的形式
Sales_data::isbn(&total)
```

任何对类成员的直接访问都被看作this的隐式调用，也就是说，当isbn使用bookNo时，它隐式的使用this指向的成员，就像我们书写了this->bookNo一样。

对于我们来说，this形参是隐式定义的。实际上，任何自定义名为this的参数或变量的行为都是非法的。我们可以在成员函数体内部使用this，因此尽管没有必要，但我们还是能把isbn定义成如下的形式：

```C++
std::string isbn() const { return this->bookNo; }
```

因为this的目的总是指向“这个”对象，所以this是一个常量指针，我们不允许改变this中保存的地址。

#### 引入const 成员函数

isbn函数的另一个关键之处是紧随参数列表之后的const关键字，这里，const的作用是修改隐式this指针的类型。

默认情况下，this的类型是指向类类型非常量版本的常量指针。例如在Sales_data成员函数中，this的类型是Sales_data *const。尽管this是隐士地，但它仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把this绑定到一个常量对象上。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数。

如果isbn是一个普通函数而且this是一个普通的指针参数，则我们应该把this声明成const Sales_data *const。毕竟，在isbn的函数体内不会改变this所指的对象，所以把this设置为指向常量的指针有助于提高函数的灵活性。

所以，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称为**常量成员函数**。

因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。

#### 类作用域和成员函数

编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体内可以随意使用类中的其他成员而无须在意这些成员出现的次序。

#### 在类的外部定义成员函数

如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员名字必须包含它所属的类名。

#### 定义一个返回this对象的函数

```C++
Sales_data& Sales_data::combine(const Sales_data &rhs){
  units_sold += rhs.units_sold; // 把rhs成员加到this对象的成员上
  revenue += rhs.revenue;
  return *this; // 返回调用该函数的对象
  // return语句解引用this指针以获得执行该函数的对象，换句话说，上面的这个调用返回total的引用
}
```

### 7.1.3 定义类相关的非成员函数

类的作者常常需要定义一些辅助函数，比如add、read、和print等。尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身。

我们定义非成员函数的方式与定义其它函数一样，通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。

### 7.1.4 构造函数

每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

构造函数的名字和类名相同。和其他函数不一样的是，**构造函数没有返回类型**；类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。

不同于其他成员函数，**构造函数不能被声明成const的**。当我们创建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。

#### 合成的默认构造函数

类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数**。默认构造函数无须任何实参。

如果我们的类没有显式的定义构造函数，那么编译器就会为我们隐式的定义一个默认构造函数。

编译器创建的构造函数又被称为**合成的默认构造函数**。其初始化类的数据成员的规则如下：

- 如果存在类内的初始值，用它来初始化成员。
- 否则，默认初始化该成员。

因为Sales_data为units_sold和revenue提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员；同时，它把bookNo默认初始化成一个空字符串。

#### 某些类不能依赖于合成的默认构造函数

合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：

1. 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。
2. 对于某些类来说，合成的默认构造函数可能执行错误的操作。回忆我们之前介绍过的，如果定义在块中的内置类型或复合类型的对象被默认初始化，则他们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。
3. 有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。

#### 定义Sales_data的构造函数

```C++
struct Sales_data {
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) {}
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  Sales_data(std::istream &);
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
```

#### =default的含义

```C++
Sales_data() = default;
```

因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。我们希望这个函数的作用完全等同于之前使用的合成默认构造函数。

#### 构造函数初始值列表

```C++
Sales_data(const std::string &s): bookNo(s) {}
Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
```

花括号定义了（空的）函数体。

冒号和花括号之间的部分称为**构造函数初始值列表**，它负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。

只有一个string类型参数的构造函数使用这个string对象初始化bookNo，对于units_sold和revenue则没有显示的初始化。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。在此例中，这样的成员使用类内初始值初始化。等价于

```C++
Sales_data(const std::string &s): bookNo(s), units_sold(0), revenue(0) {}
```

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显示的初始化每个内置类型的成员。

#### 在类的外部定义构造函数

```C++
Sales_data::Sales_data(std::istream &is) {
  read(is, *this); // 从is中读取一条交易记录然后存入this对象中
}
```

没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。

### 7.1.5 拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。

如果我们不主动定义这些操作，则编译器将替我们合成他们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。

#### 某些类不能依赖于合成的版本

对于某些类来说，合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。管理动态内存的类通常不能依赖与上述操作的合成版本。

## 7.2 访问控制与封装

目前为止，我们的类还没有封装。在C++语言中，我们使用**访问说明符**加强类的封装性：

- 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。
- 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装（即隐藏了）类的实现细节。

````C++
// 再一次定义Sales_data类，其新形式如下所示：
class Sales_data {
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s) {}
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  Sales_data(std::istream &);
  std::string isbn() const { return bookNo; }
  Sales_data& combine(const Sales_data&);
private:
  double avg_price() const;
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};
````

一个类包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。

#### 使用class或struct关键字

使用class和struct定义类的唯一区别是，struct和class的默认访问权限不太一样。

类可以在他的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。

> 使用class和struct定义类唯一的区别就是默认的访问权限。

### 7.2.1 友元

既然Sales_data的数据成员是private的，我们的read、print和add函数也就无法正常编译了，这是因为尽管这几个函数是累的接口的一部分，但他们不是类的成员。

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的**友元**。如果类想把一个函数成为它的友元，只需要增加一条friend关键字开始的函数声明语句即可：

```C++
class Sales_data{
  friend Sales_data add(const Sales_data&， const Sales_data&);
  friend std::istream &read(std::istream&, Sales_data&);
  ...
}
```

友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。

#### 友元的声明

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。

为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中。

> 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。

最好为友元函数提供一个独立的函数声明，这样即使更换了一个有强制要求的编译器，也不必改编代码。

## 7.3 类的其他特性

### 7.3.1 类成员再探

#### 定义一个类型成员

除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种：

```C++
class Screen {
public:
  typedef std::string::size_type pos;
private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
}
```

Screen 的用户不应该知道 Screen 使用了一个string对象来存放它的数据，因此通过把pos定义成public成员可以隐藏Screen实现细节。

**用来定义类型的成员必须先定义后使用，这一点与普通成员所有区别**。因此，类型成员通常出现在类开始的地方。

#### Screen类的成员函数

```C++
class Screen {
public:
  typedef std::string::size_type pos;
  Screen() = default;
  Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht*wd, c) {}
  char get() const { return contents[cursor]; } // 读取光标处的字符 隐士内联函数
  inline char get(pos ht, pos wd) const; // 显式内联
  Screen &move(pos r, pos c); // 能在之后被设为内联
private:
  pos cursor = 0;
  pos height = 0, width = 0;
  std::string contents;
}
```

第二个构造函数（接收三个参数）为cursor成员隐式地使用了类内初始值。如果类中不存在cursor的初始值，我们就需要像其他成员一样显示的初始化cursor了。

#### 令成员作为内联函数

定义在类内部的成员函数是自动inline的。因此，Screen的构造函数和返回光标所指字符的get函数默认是inline函数。

我们可以在类的内部把inline作为声明的一部分显式的声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：

```C++
inline
Screen &Screen::move (pos r, pos c) {
  pos row = r * width;
  cursor = row + c;
  return *this;
}
```

#### 重载成员函数

和非成员函数一样，成员函数也可以被重载，只要在函数之间的参数的数量或类型上有所区别就行。

#### 可变数据成员

有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。

一个**可变数据成员**永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。举个例子：

```C++
class Screen {
public:
  void some_member() const;
private:
	mutable size_t access_ctr; // 即使在一个const对象内也能被修改  
};
void Screen::some_member() const {
  ++access_ctr; 
}
```

尽管some_member是一个const成员函数，它仍然能够改变access_ctr的值。该成员是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值。

#### 类数据成员的初始值

定义好Screen类之后，我们将继续定义一个窗口类并用它表示显示器上的一组Screen。

```C++
class Window_mgr {
private:
  // 这个Window_mgr追踪的Screen
  // 默认情况下，一个Window_mgr包含一个标准尺寸的空白Screen
  std::vector<Screen> screens{Screen(24,80,'')};
}
```

当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。在此例中，我们使用一个单独的元素值对vector成员执行了列表初始化。

如我们之前所知的，类内初始值必须使用=的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。

> 当我们提供一个类内初始值时，必须以符号=或者花括号表示。

### 7.3.2 返回*this的成员函数

接下来我们继续添加一些函数，他们负责设置光标所在位置的字符或者其他任一给定位置的字符：

```C++
class Screen {
public:
  Screen &set(char);
  Screen &set(pos, pos, char);
}
inline Scrren &Scrren::set(char c) {
  contents[cursor] = c; // 设置当前光标所在位置的新值
  return *this; // 将this对象作为左值返回
}
inline Scrren &Scrren::set(pos r, pos c, char c) {
  contents[r*width + col] = c; // 设置当前光标所在位置的新值
  return *this; // 将this对象作为左值返回
}
```

set成员的返回值是调用set的对象的引用。返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。

如果我们令move和set返回Screen而非Screen&，则下述语句的行为将大不相同。

```C++
// 如果move返回Screen而非Screen&
Screen temp = myScreen.move(4,0); // 对返回值进行拷贝
temp.set('#'); // 不会改变myScreen的contents
```

假如我们定义的返回类型不是引用，则move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变myScreen的值。

#### 从const成员函数返回*this

从逻辑上来说，显示一个Screen并不需要改变它的内容，因此我们令display为一个const成员，此时，this将是一个指向const的指针而*this是const对象。由此推断，display的返回类型应该是const Sales_data&。然而，如果真的令display返回一个const的引用，则我们将不能把display嵌入到一组动作序列中去：

```C++
Screen myScreen;
// 如果display 返回常量引用，则调用set将引发错误
myScreen.display(cout).set('#');
```

即使myScreen是个非常量对象，对set的调用也无法通过编译。问题在于display的const版本返回的是常量引用，而我们显然无权set一个常量对象。

> 一个const成员函数如果以引用的形式返回*this，那么他的返回类型将是常量引用。

#### 基于const的重载

通过区分成员函数是否是const的，我们可以对其进行重载。

因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。

```C++
class Screen {
public:
  // 根据对象是否是const 重载了display函数
  Screen &display(std::ostream &os) 
  { do_display(os); return *this; }
  const Screen &display(std::ostream &os) const 
  { do_display(os); return *this; }
private:
  // 该函数负责显示Screen的内容
  void do_display(std::ostream &os) const 
  { os << contents; }
};
```

当do_display完成后，display函数各自返回解引用this所得的对象。在非常量版本中，this指向一个非常量对象，因此display返回一个普通的（非常量）引用；而const成员则返回一个常量引用。

当我们在某个对象上调用display时，该对象是否是const决定了应该调用display的哪个版本。

### 7.3.3 类类型

每个类定义了唯一的类型。对于两个类来说，即使他们的成员完全一样，这两个类也是两个不同的类型。

我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字class或struct后面：

```C++
Sales_data item1;
class Sales_data item1;
// 两条声明完全等价
```

#### 类的声明

就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它。

这种声明被称为**前向声明**，他向程序中引入了类的名字（Screen）并且指明Screen是一种类类型，对于类型Screen来说，在它声明之后定义之前是一个**不完全类型**。

不完全类型只能在非常有限的情境下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。

### 7.3.4 友元再探

类可以把普通的非成员函数定义成友元。类还可以把其他的类定义成友元，也可以把其他类的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。

#### 类之间的友元关系

我们的Window_mgr类的某些成员可能需要访问它管理的Screen类的内部数据。例如：Window_mgr类中的函数clear需要访问Screen的私有成员；要想令这种访问合法，Screen需要把Window_mgr指定成它的友元：

```C++
class Screen {
  // Window_mgr 的成员可以访问Screen类的私有部分
  friend class Window_mgr;
}
```

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非共有成员在内的所有成员。

```C++
class Window_mgr {
public:
  using ScreenIndex = std::vector<Screen>::size_type;
  void clear(ScreenIndex);
private:
  std::vector<Screen> screens{Screen(24, 80 ,'')};
}
void Window_mgr::clear(ScreenIndex) {
  Screen &s = screens[ScreenIndex];
  s.contents = string(s.ht * s.wd, '');
}
```

如果clear不是Screen的友元，上面的代码将无法通过编译，因为此时clear将不能访问Screen的成员。

必须要注意的一点是，友元关系不存在传递性。也就是说，如果Window_mgr有它自己的友元，则这些友元不能理所当然地具有访问Screen的特权。

#### 令成员函数作为友元

除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：

```C++
class Screen {
  // Windoew_mgr::clear 必须在Screen类之前被声明
  friend void Windoew_mgr::clear(ScreenIndex);
  ....
}
```

要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：

- 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。
- 接下来定义Screen，包括对于clear的友元声明。
- 最后定义clear，此时它才可以使用Screen的成员。

#### 函数重载和友元

尽管重载函数的名字相同，但它们仍然是不同的函数，因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

#### 友元声明和作用域

类和非成员函数的声明不是必须在他们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定改名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。

甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：

```C++
struct X {
  friend void f() {/* 友元函数可以定义在类的内部 */}
  X() { f(); } // 错误：f还没有被声明
  void g();
  void h();
};
void X::g() {return f();} // 错误：f还没有被声明
void f(); // 声明那个定义在X中的函数
void X::h() { return f(); } // 正确：现在f的声明在作用域中了
```

关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。

## 7.4 类的作用域

每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。

#### 作用域和定义在类外部的成员

一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了。

另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。

```C++
// 例如
class Window_mgr {
public:
  // 向窗口添加一个Screen,返回它的编号
  ScreenIndex addScreen(const Screen&);
};
// 首先处理返回类型，之后我们才进入Window_mgr的作用域
Window_mgr::ScreenIndex
Window_mgr::addScreen(const Screen& s) {
  screens.push_back(s);
  return screens.size() - 1;
}
```

因为返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的。

### 7.4.1 名字查找与类的作用域

在目前为止，我们编写的程序中，**名字查找**（寻找与所用名字最匹配的声明的过程）的过程比较直截了当：

- 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。
- 如果没找到，继续查找外层作用域。
- 如果最终没有找到匹配的声明，则程序报错。

对于定义在类内部的成员函数来说，解析其中的名字的方式与上述的查找规则有所区别。类的定义分两步处理：

- 首先，编译成员的声明。
- 直到类全部可见后才编译函数体。

> 编译器处理完类中的全部声明后才会处理成员函数的定义。

#### 用于类成员声明的名字查找

这种两阶段的处理方式只适用于成员函数体中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。

```C++
typedef double Money;
string bal;
class Account {
public:
  Money balance() { return bal; }
private:
  Money bal;
  // .....
};
```

当编译器看到balance函数的声明语句时，他将在Account类的范围内寻找对Money的声明。编译器只考虑Account中在使用Money前出现的声明，因为没找到匹配的成员，所以编译器会接着到Account的外层作用域中查找。另一方面，balance函数体在整个类可见后才被处理，因此，该函数的return语句返回名为bal的成员，而非外层作用域的string对象。

#### 类型名要特殊处理

一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字：

```C++
typedef double Money;
class Account {
public:
  Money balance() { return bal; } // 使用外层作用域中的名字
private:
  typedef double Money; // 错误：不能重新定义Money
  Money bal;
  // .....
};
```

需要特别注意的是，即使Account中定义的Money类型与外层作用域一致，上述代码仍然是错误的。

> 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

#### 成员定义中的普通块作用域的名字查找

成员函数中使用的名字按照如下方式解析：

- 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。
- 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。
- 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。

一般来说不建议使用其他成员的名字作为某个成员函数的参数。

```C++
// 通常情况下不建议为参数和成员使用同样的名字
int height;
class Screen {
public:
  typedef std::string::size_type pos;
  void dummy_fcn(pos height) {
    cursor = width * height; // 哪个height?
  }
private:
  pos cursor = 0;
  pos height = 0, width = 0;
};
```

当编译器处理dummy_fcn中的乘法表达式时，他首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此dummy_fcn函数体内用到的名字height指的是参数声明。

在上述代码中，height参数隐藏了同名的成员。如果想绕开上面的查找规则应该将代码变为：

```C++
void Screen::dummy_fcn(pos height) {
  cursor = width * this->height; // 成员height
  cursor = width * Screen::height; // 成员height
}
```

> 尽管类的成员被隐藏了，但我们任然可通过加上类的名字或显示的使用this指针来强制访问成员。

#### 类作用域之后，在外围的作用域中查找

如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。

如果，我们需要的是外层作用域中的名字，可以显示的通过作用域运算符来进行请求：

```C++
void Screen::dummy_fcn(pos height) {
  cursor = width * ::height // 哪个height?是那个全局的
}
```

#### 在文件中名字的出现处对其进行解析

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。

```C++
int height;
class Screen {
public:
  typedef std::string::size_type pos;
  void setHeight(pos);
  pos height = 0; // 隐藏了外层作用域中的height
};
Screen::pos verify(Screen::pos);
void Screen::setHeight(pos var) {
  // var: 参数
  // height: 类的成员
  // verify: 全局函数
  height = verify(var);
}
```

注意：全局函数verify的声明在Screen类的定义之前是不可见的。然后，名字查找的第三步包括了成员函数出现之前的全局作用域。

## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

如果没有在构造函数的初始值列表中显示的初始化成员，则该成员将在构造函数体之前执行默认初始化。

```C++
Sales_data::Sales_data(const string &s, unsigned cnt, double price) {
  bookNo = s;
  units_sold = cnt;
  revenue = cnt * price;
}
```

原来的版本（构造函数初始化版本）初始化了它的数据成员，而这个版本是对数据成员执行了赋值操作。

#### 构造函数的初始值有时必不可少

有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

```C++
class ConstRef {
public:
  ConstRef(int ii);
private:
  int i;
  const int ci;
  int &ri;
};
```

和其他常量对象或者引用一样，成员ci和ri都必须初始化。

```C++
ConstRef::constRef(int ii){
  i = ii; // 正确
  ci = ii; // 错误： 不能给const赋值
  ri = i; // 错误：ri没被初始化
}
```

随着构造函数体一开始执行，初始化就完成了。我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此构造函数的正确形式应该是：

```C++
// 正确：显示的初始化引用和const成员
ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) {}
```

> Note! 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初始值。

#### 成员初始化的顺序

构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。

成员的初始化顺序与他们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。

> 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。

#### 默认实参和构造函数

```C++
class Sales_data {
public:
  Sales_data(std::string s = ""): bookNo(s) {}
  // ...
}
```

在上面这段程序中，当没有给定实参，或者给定了一个string实参时，两个版本的类创建了相同的对象。因为我们不提供实参也能调用上述的构造函数，所以该构造函数实际上为我们的类提供了默认构造函数。

> 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

### 7.5.2 委托构造函数

C++新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的**委托构造函数**。一个委托构造函数使用它所属类的其它构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其它构造函数。

在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。

```C++
class Sales_data {
public:
  // 非委托构造函数
  Sales_data(std::string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), revenue(cnt*price) {}
  // 其余构造函数全部委托给另一个构造函数
  Sales_data(): Sales_data("", 0, 0) {}
  Sales_data(std::string s): Sales_data(s, 0, 0) {}
  Sales_data(std::istream &is): Sales_data() { read(is, *this); }
}
```

除了第一个，其他三个构造函数全部委托第一个构造函数完成初始化。

当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，执行完后控制权才会交还给委托者的函数体。

### 7.5.3 默认构造函数的作用

当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生：

- 当我们在块作用域内不使用任何初始值定义一个非静态变量或者数组时。
- 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
- 当类类型的成员没有在构造函数初始值列表中显示的初始化时。

值初始化在以下情况下发生：

- 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。
- 当我们不使用初始值定义一个局部静态变量时。
- 当我们通过书写形如T()的表达式显示的请求值初始化时，其中T()是类型名（vector的一个构造函数只接受一个实参用于说明vector大小，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。

类必须包含一个默认构造函数以便在上述情况下使用。

> 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。

### 7.5.4 隐式的类类型转换

我们也能为类定义隐式转换规则。如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐士转换机制，有时我们把这种构造函数称作**转换构造函数**。

> 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。

在Sales_data类中，接受string的构造函数和接受istream的构造函数分别定义了从这两种类型向Sales_data隐式转换的规则。也就是说，在需要使用Sales_data的地方，我们可以使用string或者istream作为替代：

```C++
string null_book = "9-999-9999-9";
// 构造一个临时的Sales_data对象
// 该兑现的units_sold和revenue等于0,bookNo等于null_book
item.combine(null_book);
```

这里我们用一个string实参调用了Sales_data的combine成员。该调用是合法的，编译器用给定的string自动创建了一个Sales_data对象。新生成的这个（临时）Sales_data对象被传递给combine。因为combine的参数是一个常量引用，所以我们可以给该参数传递一个临时变量。

#### 只允许一步类类型转换

编译器只会自动的执行一步类类型转换。

```C++
// 因为下面的代码隐式的使用了两种转换规则，所以他是错误的
item.combine("9-99-999");
```

#### 抑制构造函数定义的隐式转换

在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为**explicit**加以阻止：

```C++
class Sales_data {
public:
  Sales_data() = default;
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
  explicit Sales_data(const std::string &s): bookNo(s) {}
  explicit Sales_data(std::istream&);
};
```

此时，没有任何构造函数能用于隐式地创建Sales_data对象，之前的两种用法都无法通过编译。

```C++
item.combine(null_book); // 错误：string构造函数是explicit的
item.combine(cin); // 错误：istream构造函数是explicit的
```

关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复：

```C++
explicit Sales_data::Sales_data(istream &is) {
  read(is, *this);
}
```

#### explicit 构造函数只能用于直接初始化

发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=）此时，我们只能使用直接初始化而不能使用explicit构造函数：

```C++
Sales_data item1(null_book); // 正确：直接初始化
// 错误：不能将explicit构造函数用于拷贝形式的初始化过程
Sales_data item2 = null_book;
```

> 当我们使用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。

#### 为转换显示地使用构造函数

尽管编译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显示的强制进行转换：

```C++
// 正确： 实参是一个显示构造的Sales_data对象
item.combine(Sales_data(null_book));
// 正确： static_cast可以使用explicit的构造函数
item.combine(static_cast<Sales_data>(cin));
```

#### 标准库中含有显示构造函数的类

我们用过的一些标准库中的类含有单参数的构造函数：

- 接受一个单参数的const char*的string构造函数不是explicit的。
- 接受一个容量参数的vector构造函数是explicit的。

### 7.5.5 聚合类

**聚合类**使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：

- 所有成员都是public的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类，也没有virtual函数。

```C++
// 这是一个聚合类
struct Data {
  int ival;
  string s;
};
```

我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员：

```c++
// val1.ival = 0; val1.s = string("Anna")
Data val1 = {0, "Anna"};
```

初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。

与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。

值得注意的是，显示的初始化类的对象的成员存在三个明显的缺点：

- 要求类的所有成员都是public的
- 将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错。
- 添加或删除一个成员之后，所有的初始化语句都需要更新。

### 7.5.6 字面值常量类

constexpr 函数的参数和返回值必须是字面值类型。和其他类不同，字面值类型的类可能含有constexpr函数成员。

数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合以下要求，则它也是一个字面值常量类：

- 数据成员都必须是字面值类型。
- 类必须至少含有一个constexpr构造函数
- 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。
- 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

#### constexpr 构造函数

尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。

constexpr构造函数可以声明成=default的形式。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句）。综合这两点可知，constexpr构造函数体一般来说应该是空的。

```C++
class Debug {
public:
  constexpr Debug(bool b = true): hw(b), io(b), other(b) {}
  constexpr Debug(bool h, bool i, bool o): hw(h), io(i), other(o) {}
  constexpr bool any() { return hw || io || other; }
  void set_io(bool b) { io = b; }
  void set_hw(bool b) { hw = b; }
  void set_other(bool b) { other = b; }
 
private:
  bool hw;
  bool io;
  bool other;
};
```

constexpr 构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。

constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型。

## 7.6 类的静态成员

有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。

#### 声明静态成员

我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态成员的类型可以是常量、引用、指针、类类型等。

```C++
class Account {
public:
  void calculate() { amount += amount * interestRate; }
  static double rate() { return interestRate; }
  static void rate(double);
private:
  std::string owner;
  double amount;
  static double interestRate;
  static double initRate();
};
```

类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。

类似的，静态成员函数也不与任何对象绑定在一起，他们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。这一限制既适用于this的显示使用，也对调用非静态成员的隐式使用有效。

#### 使用类的静态成员

我们使用作用域运算符直接访问静态成员：

```C++
double r;
r = Account::rate(); 
```

虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员：

```C++
Account ac1;
Account *ac2 = &ac1;
r = ac1.rate();
r = ac2->rate();
```

成员函数不用通过作用域运算符就能直接使用静态成员：

```C++
class Account {
public:
  void calculate() { amount += amount * interestRate; }
private:
  static double interestRate;
}
```

#### 定义静态成员

和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句：

> 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。static关键字则只出现在类内部的声明语句中。

因为静态数据成员不属于类的任何一个对象，所以他们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。

类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。

我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字：

```C++
double Account::interestRate = initRate();
```

这条语句定义了名为interestRate的对象，该对象是类Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就都位于类的作用域之内了。因此，我们可以访问类Account中的所有成员。

#### 静态成员的类内初始化

通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以他们能用在所有适合于常量表达式的地方。

```C++
class Account {
public:
  static double rate() { return interestRate; }
  static void rate(double);
private:
  static constexpr int period = 30;
  double daily_tbl[period];
};
```

如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须有一条定义语句。

例如：如果period的唯一用途就是定义daily_tbl的维度，则不需要在Account外面专门定义period。此时，如果我们忽略了这条定义，那么对程序非常微小的改动也可能造成编译错误，因为程序找不到该成员的定义语句。举个例子，当需要把Account::period传递给一个接受const int&的函数时，必须定义period。

如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了：

```C++
constexpr int Account::period; // 初始值在类的定义内提供
```

> 即使一个常量静态数据成员在类的内部被初始化了，通常情况下也应该在类的外部定义一下该成员。

####  静态成员能用于某些场景，而普通成员不能

某些非静态数据成员可能非法的场合，静态成员却可以正常使用。

静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是他所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用：

```C++
class Bar {
public:
  // ...
private:
  static Bar mem1; // 正确： 静态成员可以是不完全类型
  Bar *mem2; // 正确： 指针成员可以是不完全类型
  Bar mem3;  // 错误：数据成员必须是完全类型
}
```

静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参：

```C++
class Screen {
public:
  // bkground 表示一个在类中稍后定义的静态成员
  Screen& clear(char = bkground);
private:
  static const char bkground;
};
```

非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。

# 第8章 IO库

## 8.1 IO类

标准库还定义了其他一些IO类型：iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。

![](https://cdn.pkubailu.cn/img/8.1.png)

为了支持使用宽字符的语言，标准库定义了一组类型和对象来操纵wchar_t类型的数据。宽字符版本的类型和函数的名字以一个w开始。

#### IO类型间的关系

标准库使我们能忽略这些不同类型的流之间的差异，这是通过**继承机制**实现的。利用模板，我们可以使用具有继承关系的类，而不必了解继承机制如何工作的细节。

简单地说，继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类（继承类）对象当作其基类（所继承的类）对象来使用。

### 8.1.1 IO对象无拷贝或赋值

 不能拷贝或对IO对象赋值：

```C++
ofstream out1, out2;
out1 = out2; // 错误：不能对流对象赋值
ofstream print(ofstream); // 错误：不能初始化ofstream参数
out2 = print(out2); // 错误： 不能拷贝流对象
```

由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。

### 8.1.2 条件状态

下表列出了IO类所定义的一些函数和标志，可以帮助我们访问和操纵流的**条件状态**。

![](https://cdn.pkubailu.cn/img/8.2-1.png)

![](https://cdn.pkubailu.cn/img/8.2-2.png)

一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：

```C++
while(cin >> word)
  // ok:读操作成功.....
```

while循环检查>>表达式返回的流的状态。

#### 查询流的状态

IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用。IO库定义了4个iostate类型的constexpr值，表示特定的位模式。这些值用来表示特定类型的IO条件，可以与位运算符一起使用来一次性检验或设置多个标志位。

badbit表示系统级错误，如不可恢复的读写错误。一旦badbit被置位，流就无法再使用了。在发生可恢复错误后，failbit被置位。如果到达文件结束位置，eofbit和fail都会被置位

goodbit的值为0，表示流未发生错误。如果badbit、failbit、eofbit任一个被置位，则检测流状态的条件会失败。

使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当做条件使用的代码就等价于!fail()。

#### 管理条件状态

流对象的rdstate成员返回一个iostate值，对应流当前状态。setstate操作将给定条件置位，表示发生了对应错误。clear成员是一个重载的成员：它有一个不接收参数的版本，而另一个版本接受一个iostate类型的参数。

clear不接收参数的版本清除（复位）所有错误标志位。执行clear()后，调用good会返回true。

```C++
// 记住cin的当前状态
auto old_state = cin.rdstate(); // 记住cin当前状态
cin.clear(); // 使cin有效
process_input(cin); // 使用cin
cin.setstate(old_state); // 将cin置为原有状态
```

带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。

```C++
cin.clear(cin.rdstate & ~cin.failbit & ~cin.badbit);
```

### 8.1.3 管理输出缓冲

每个输出流都管理一个缓冲区，用来保存程序读写的数据。

```C++
os << "please enter a value";
```

文本串可能立即打印出来，但也有可能被操作系统保存在缓冲区中，随后再打印。

导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：

- 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。
- 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
- 我们可以使用操作符如endl来显示刷新缓冲区。
- 在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。
- 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区刷新。

#### 刷新输出缓冲区

```C++
cout << "hi!" << endl; // 输出hi和一个换行，然后刷新缓冲区
cout << "hi!" << flush; // 输出hi，然后刷新缓冲区，不附加任何额外字符
cout << "hi!" << ends; // 输出hi和一个空字符，然后刷新缓冲区
```

#### unitbuf 操纵符

如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：

```C++
cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区
cout << nounitbuf; // 回到正常的缓冲方式
```

> Warning! 如果程序异常终止，输出缓冲区不会被刷新。它所输出的数据很可能停留在输出缓冲区中等待打印。

#### 关联输入和输出流

当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起。

```c++
cin >> ival;
// 导致cout的缓冲区被刷新
```

tie有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即x.tie(&o)将x流关联到输出流o。

我们既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream：

```C++
cin.tie(&cout); // 标准库将cin和cout关联在一起
ostream *old_tie = cin.tie(nullptr); // cin不再与其他流关联
cin.tie(&cerr); // 读取cin会刷新cerr而不是cout
cin.tie(old_tie); // 重建cin和cout间的正常关联
```

为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了tie。为了彻底揭开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。

## 8.2 文件输入输出

头文件fstream定义了三个类型来支持文件IO: ifstream从一个给定文件读取数据，ofstream向一个给定文件写入数据，以及fstream可以读写给定文件。

这些类型提供的操作与我们之前已经使用过的对象cin和cout的操作一样。

除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。我们可以对fstream、ifstream和ofstream对象调用这些操作，但不能对其他IO类型调用这些操作。

![](https://cdn.pkubailu.cn/img/8.3.png)

### 8.2.1 使用文件流对象

当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。每个文件流类都定义了一个名为open的成员函数，它完成一些系统相关的操作，来定位给定的文件，并视情况打开为读或写模式。

创建文件流对象时，我们可以提供文件名（可选的）。如果提供了一个文件名，则open会自动调用：

```C++
ifsream in(ifile); // 构建一个ifstream并打开给定文件
ofstream out; // 输出文件流未关联到任何文件
```

这段代码定义了一个输入流in，它被初始化为从文件读取数据，文件名由string类型的参数ifile指定。第二条语句定义了一个输出流out，未与任何文件关联。文件名既可以是库类型string对象，也可以是C风格字符数组。

#### 用fstream代替iostream&

我们已经提到过。在要求使用基类型对象的地方，我们可以用继承类型的对象来替代。这意味着，接受一个iostream类型引用（或指针）参数的函数，可以用一个对应的fstream（或sstream）类型来调用。

例如：我们假定输入和输出文件的名字是通过传递给main函数的参数来指定的：

![](https://cdn.pkubailu.cn/img/8.2.1.png)

#### 成员函数open和close

如果我们定义了一个空文件流对象，可以随后调用open来将它与文件关联起来：

```C++
ifstream in(ifile); // 构筑一个ifstream并打开给定文件
ofstream out; // 输出文件流未与任何文件相关联
out.open(ifile + ".copy"); // 打开指定文件
```

如果调用open失败，failbit会被置位。因为调用open可能失败，进行open是否成功的检测通常是一个好习惯：

```C++
if (out) // 检查open是否成功
  // open成功执行的操作
```

一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的文件流调用open会失败，并会导致failbit被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一但文件成功关闭，我们可以打开新的文件：

```C++
in.close(); // 关闭文件
in.open(ifile + "2"); // 打开另一个文件
```

如果open成功，则open会设置流的状态，使得good()为true。

#### 自动构造和析构

考虑这样一个程序，它的main函数接受一个要处理的文件列表。这种程序可能会有如下的循环：

```C++
// 对每个传递给程序的文件执行循环操作
for(auto p = argv + 1; p != argv + argc; ++p) {
  ifstream input(*p); // 创建输出流并打开文件
  if (input) { // 如果文件打开成功，处理此文件
    process(input);
  } else 
    cerr << "couldn't open: " + string(*p);
} // 每个循环步 input都会离开作用域，因此会被销毁
```

当一个fstream对象离开其作用域时，与之关联的文件会自动关闭。在下一步循环中，input会再次被创建。

> 当一个fstream对象被销毁时，close会自动被调用。

### 8.2.2 文件模式

每个流都有一个关联的**文件模式**，用来指出如何使用文件。

![](https://cdn.pkubailu.cn/img/8.4.png)

无论用哪种方式打开文件，我们都可以指定文件模式，调用open打开文件时可以，用一个文件名初始化流来隐式打开文件时也可以。指定文件模式有如下限制：

- 只可以对ofstream或fstream对象设定out模式。
- 只可以对ifstream或fstream对象设定in模式。
- 只有当out也被设定时才可设定trunc模式。
- 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显示指定out模式，文件也总是以输出方式被打开。
- 默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保留以out模式打开的文件的内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作。
- ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。

每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与ifstream关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；与fstream关联的文件默认以in和out模式打开。

#### 以out模式打开文件会丢弃已有数据

默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定app模式：

```C++
// 在这几条语句中，file1都被截断
ofstream out("file1") // 隐含以输出模式打开文件并截断文件
ofstream out("file1", ofstream::out) // 隐含的截断文件
ofstream out("file1", ofstream::out | ofstream::trunc) 
// 为了保留文件内容，我们必须显示指定app模式
ofstream app("file2", ofstream::app) // 隐含为输出模式
ofstream app("file2", ofstream::out | ofstream::app) 
```

> 保留被ofstream打开的文件中已有数据的唯一方法是显示指定app或in模式

#### 每次调用open时都会确定文件模式

对于一个给定流，每当打开文件时，都可以改变其文件模式。

```C++
ofstream out; // 未指定文件打开模式
out.open("file1"); // 模式隐含设置为输出和截断
out.close(); // 关闭out,以便我们将其用于其他文件
out.open("file2", ofstream::app); // 模式为输出和追加
out.close();
```

第一个open调用未显示指定输出模式，文件隐式地以out模式打开。通常情况下，out模式意味着同时使用trunc模式。因此，当前目录下名为file1的文件的内容将被清空。当打开名为file2的文件时，我们制定了append模式。文件中已有的数据都得以保留，所有写操作都在文件末尾进行。

> 在每次打开文件时，都要设置文件模式，可能是显示设置，也可能是隐式的设置。当程序未指定模式时，就使用默认值。

## 8.3 string 流

istringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream即可从string读数据也可向string写数据。与fstream类型类似，头文件sstream中定义的类型都继承自我们已经使用过的iostream头文件中定义的类型。除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。

![](https://cdn.pkubailu.cn/img/8.5.png)

可以对stringstream对象调用这些操作，但不能对其他IO类型调用这些操作。

### 8.3.1 使用istringstream

当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。

![](https://cdn.pkubailu.cn/img/8.3.1.png)

### 8.3.2 使用ostringstream

当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。例如，对比上一节的例子，我们可能想逐个验证电话号码并改变其格式。如果所有号码都是有效的，我们希望输出一个新的文件，包含改变格式后的号码。对于无效的号码，我们不会将它们输出到新文件中，而是打印一条包含人名和无效号码的错误信息。

![](https://cdn.pkubailu.cn/img/8.3.2.png)

# 第9章 顺序容器

一个容器就是一些特定类型对象的集合。**顺序容器**为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。

## 9.1 顺序容器概述

所有顺序容器都提供了快速顺序访问元素的能力。

![](https://cdn.pkubailu.cn/img/9.1.png)

除了固定大小的array外，其他容器都提供高校、灵活的内存管理。我们可以添加和删除元素，扩张和收缩容器的大小。容器保存元素的策略对容器操作的效率有着固有的，有时是重大的影响。在某些情况下，存储策略还会影响特定容器是否支持特定操作。

> 新标准库的容器比旧版本快得多。现代C++程序应该使用标准库容器，而不是更原始的数据结构。

## 9.2 容器库概览

容器均定义为模板类。例如对vector，我们必须提供额外信息来生成特定的容器类型。对大多数，但不是所有容器，我们还需要额外提供元素类型信息。

```C++
list<Sales_data> // 保存 Sales_data对象的list
deque<double> // 保存double的deque
```

#### 对容器可以保存的元素类型的限制

顺序容器几乎可以保存任意类型的元素。特别是，我们可以定义一个容器，其元素的类型是另一个容器。

> 较旧的的编译器可能需要在两个尖括号之间键入空格。

虽然我们可以在容器中保存几乎任何类型，但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。

例如，顺序容器构造函数的一个版本接收容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数。

```C++
// 假定noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10, init); // 正确：提供了元素初始化器
vector<noDefault> v2(10); // 错误： 必须提供一个元素初始化器
```

![](https://cdn.pkubailu.cn/img/9.2.png)

### 9.2.1 迭代器

forward_list 迭代器不支持递减运算符。

算术运算只能引用于string、vector、deque、array的迭代器。我们不能将它们用于其他任何容器类型的迭代器。

一个**迭代器范围**由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。这两个迭代器通常被称为begin和end，他们标记了容器中元素的一个范围。

迭代器范围中的元素包含begin所表示的元素以及从begin开始直至end（但不包含end）之间的所有元素。

这种元素范围被称为**左闭合区间**。

迭代器begin和end必须指向相同的容器。end可以与begin指向相同的位置，但不能指向begin之前的位置。

>如果满足如下条件，两个迭代器begin和end构成一个迭代器范围：
>
>- 他们指向同一个容器中的元素，或者是容器最后一个元素之后的位置。
>- 我们可以通过反复递增begin来到达end。换句话说，end不在begin之前。

#### 使用左闭合范围蕴含的编程假定

标准库使用左闭合范围是因为这种范围有三种方便的性质。

- 如果begin与end相等，则范围为空。
- 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。
- 我们可以对begin递增若干次，使得begin==end

### 9.2.2 容器类型成员

通过类型别名，我们可以在不了解容器中元素类型的情况下使用它。

为了使用这些类型，我们必须显示使用其类名：

```c++
// iter是通过list<string>定义的一个迭代器类型
list<string>::iterator iter;
// count是通过vector<int>定义的一个difference_type类型
vector<int>::difference_type count;
```

#### 9.2.3 begin 和 end 成员

begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围。

实际上有两个名为begin的成员。一个是const成员，返回容器的const_iterator类型。另一个是非常量成员，返回容器的iterator类型。

用c开头的版本是C++新标准库引入的，用以支持auto与begin和end函数结合使用。

```C++
// 显示指定类型
list<string>::iterator it5 = a.begin();
list<string>::const_iterator it6 = a.cbegin();
// 是iterator还是const_iterator依赖于a的类型
auto it7 = a.begin(); // 仅当a时const时，it7是const_iterator
auto it8 = a.cbegin(); // it8是const_iterator
```

当auto与begin和end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代毫不相干。但c开头的版本还是可以获得const_iterator的，而不管容器的类型是什么。

#### 9.2.4 容器定义和初始化

每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。

![](https://cdn.pkubailu.cn/img/9.3.png)

#### 将一个容器初始化为另一个容器的拷贝

将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者拷贝由一个迭代器对指定的元素范围。

为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器得元素类型即可。

```C++
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
list<string> list2(authors); // 正确：类型匹配
deque<string> authList(authors); // 错误：容器类型匹配
vector<string> words(articles); // 错误：容器元素类型不匹配
// 正确： 可以将const char*元素转换为string
forward_list<string> words(articles.begin(), articles.end());
```

> 当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。

当两个迭代器表示一个范围时，我们可以使用这种构造函数来拷贝一个容器中的子序列。

#### 列表初始化

在新标准中，我们可以对一个容器进行列表初始化

```C++
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
```

当这样做时，我们就显示的指定了容器中每个元素的值。对于除array之外的容器类型，初始化列表还隐含的指定了容器的大小：容器将包含与初始值一样多的元素。

#### 与顺序容器大小相关的构造函数

除了与关联容器相同的构造函数外，顺序容器（array除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器：

```C++
vector<int> ivec(10, -1); // 10个int元素，每个都初始化为-1
list<string> svec(10, "hi!"); // 10个string，每个都初始化为"hi!"
forward_list<int> ivec(10); // 10个int元素，每个都初始化为0
deque<string> svec(10); // 10个元素，每个都初始化为空string
```

如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显示的元素初始值。

> 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。

#### 标准库 array具有固定大小

与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小：

```C++
array<int, 42> // 类型为：保存42个int的数组
array<string, 10> // 类型为：保存10个string的数组
```

为了使用array类型，我们必须同时指定元素类型和大小：

```C++
array<int, 10>::size_type i; // 数组类型包括元素类型和大小
array<int>::size_type j; // 错误：array<int>不是一个类型
```

与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化，就像一个内置数组一样。如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行：

```C++
array<int, 10> ia1; // 10个默认初始化的int
array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9}; // 列表初始化
array<int, 10> ia3 = {42}; // ia3[0]为42，剩余元素为0
```

值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制：

```C++
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs; // 错误：内置数组不支持拷贝或赋值
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9}; 
array<int, 10> copy = digits; // 正确：只要数组类型匹配即合法
```

与其他容器一样，array也要求初始值的类型必须与要创建的容器类型相同。此外，array还要求元素类型和大小也都一样，因为大小是array类型的一部分。

### 9.2.5 赋值和swap

赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。

如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同。

与内置数组不同，标准库array类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。

由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持assign，也不允许用花括号包围的值列表进行赋值。

![](https://cdn.pkubailu.cn/img/9.4.png)

#### 使用assign（仅顺序容器）

赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝到左边运算对象中。顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。

```C++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; // 错误：容器类型不匹配
// 正确： 可以将const char*转换为string
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

这段代码中对assign的调用将names中的元素替换为迭代器所指定的范围中的元素的拷贝。

> 由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器。

#### 使用swap

swap操作交换两个相同类型容器得内容。

```C++
vector<string> svec1(10); // 10个元素的vector
vector<string> svec2(24); // 24个元素的vector
swap(svec1, svec2);
```

调用swap后，svec1将包含24个string元素，svec2将包含10个string。除array外，交换两个容器内容的操作保证会很快—元素本身并未交换，swap只是交换了两个容器的内部数据结构。

> 除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。

元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svec1[3]的string，那么在swap之后它指向svec2[3]的元素。与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。

与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。

因此，对于array，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。

### 9.2.6 容器大小操作

每个容器类型都有三个与大小相关的操作。成员函数size返回容器中元素的数目；empty当size为0时返回布尔值true，否则返回false；max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。forward_list支持max_size和empty，但不支持size。

### 9.2.7 关系运算符

每个容器类型都支持（==和!=）；除了无序关联容器外的所有容器都支持关系运算符(>,>=,<,<=)。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。

比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似。

#### 容器的关系运算符使用元素的关系运算符完成比较

> 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。

容器的相等运算符实际上是使用元素的==运算符实现比较的，而其他关系运算符是使用元素的<运算符。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相应的关系运算。

## 9.3 顺序容器操作

### 9.3.1 向顺序容器添加元素

除array外，所有标准库容器都提供灵活的内存管理。在运行时可以动态的添加或删除元素来改变容器大小。

![](https://cdn.pkubailu.cn/img/9.5.png)

#### 使用push_back

除了array和forward_list之外，每个顺序容器（包括string）都支持push_back。

> Note! 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值得一个拷贝，而不是对象本身。

#### 使用push_front

list、forward_list和deque容器支持名为push_front的操作。

deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首尾进行插入和删除元素的操作都只花费常数时间。与vector一样，在deque首位之外的位置插入元素会很耗时。

#### 在容器中的特定位置添加元素

vector、deque、list、string支持insert成员。

虽然某些容器不支持push_front操作，但它们对于insert操作并无类似的限制（插入开始位置）。因此我们可以将元素插入到容器的开始位置。

#### 插入范围内元素

```C++
// 运行时错误： 迭代器表示要拷贝的范围，不能指向与目的位置相同的容器
slist.insert(slist.begin(), slist.begin(), slist.end());
```

在新标准下，接受元素个数或范围的insert版本返回指向第一个新加入元素的迭代器。如果范围为空，不插入任何元素，insert操作会将第一个参数返回。

#### 使用insert的返回值

通过使用insert的返回值，可以在容器中一个特定位置反复插入元素：

```C++
list<string> lst;
auto iter = lst.begin();
while (cin >> word) 
  iter = lst.insert(iter, word); // 等价于调用push_front
```

#### 使用emplace操作

当调用push或insert成员函数时，我们将元素类型的对象传递给他们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。

```C++
// 在C的末尾构造一个Sales_data对象
// 使用三个参数的Sales_data构造函数
c.emplace("978-059232323", 25, 15.99);
// 错误： 没有接受三个参数的push_back版本
c.push_back("978-059232323", 25, 15.99);
// 正确： 创建一个临时的Sales_data对象传递给push_back
c.push_back(Sales_data("978-059232323", 25, 15.99));
```

其中对emplace_back的调用和第二个push_back调用都会创建新的Sales_data对象。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。

> emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。

### 9.3.2 访问元素

![](https://cdn.pkubailu.cn/img/9.6.png)

包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数。

```C++
// 在解引用一个迭代器或调用front或back之前检查是否有元素
if(!c.empty()) {
  auto va1 = *c.begin(), va2 = c.front();
  auto last = c.end();
  auto va3 = *(--last);
  auto va4 = c.back();
}
```

> 对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误。

#### 访问成员函数返回的是引用

在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用。

```C++
if (!c.empty()) {
  c.front = 42; // 将42赋值给第一个元素
  auto &v = c.back(); // 获得指向最后一个元素的值
  v = 1024; // 改变了c中元素的值
  auto v2 = c.back(); // v2 不是一个引用，它是c.back()的一个拷贝
  v2 = 0; // 未改变c中的元素
}
```

与往常一样，如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。

#### 下标操作和安全的随机访问

如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常：

```C++
vector<string> svec; // 空vector
cout << svec[0]; // 运行时错误：svec中没有元素
cout << svec.at(0); //抛出一个out_of_range异常
```

### 9.3.3 删除元素

![](https://cdn.pkubailu.cn/img/9.7.png)

> 删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它们是存在的。

与元素访问成员函数类似，不能对一个空容器执行弹出操作。

```C++
// 删除两个迭代器表示的范围内的元素
// 返回指向最后一个被删元素之后位置的迭代器
elem1 = slist.erase(elem1, elem2); // 调用后，elem1 == elem2
```

迭代器elem1指向我们要删除的第一个元素，elem2指向我们要删除的最后一个元素之后的位置。

### 9.3.4 特殊的forward_list操作

![](https://cdn.pkubailu.cn/img/9.8.png)

### 9.3.5 改变容器大小

我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部：

```C++
list<int> ilist(10, 42); // 10个int：每个的值都是42
ilist.resize(15); // 将5个只为0的元素添加到ilist的末尾
ilist.resize(25, -1); // 将10个值为-1的元素添加到ilist的末尾
ilist.resize(5); // 从ilist末尾删除20个元素
```

![](https://cdn.pkubailu.cn/img/9.9.png)

### 9.3.6 容器操作可能使迭代器失效

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不再表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题。

在向容器添加元素后：

- 如果容器是vector和string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。
- 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
- 对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。

当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，当我们删除一个元素后：

- 对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。
- 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。
- 对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。
- 注意：当我们删除元素时，尾后迭代器总是会失效。

> 由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确的重新定位迭代器。

#### 编写改变容器的循环程序

添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步都更新迭代器、引用和指针。

#### 不要保存end返回的迭代器

当我们添加/删除vector或string的元素后，或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器，一直当做容器末尾使用。

```C++
// 灾难：次循环的行为是未定义的
auto begin = v.begin(), end = v.end();
while(begin != end) {
  // 做一些处理
  // 插入新值，对begin重新赋值，否则的话它就会失效
  ++begin;
  begin = v.insert(begin, 42); // 插入新值
  ++begin; // 向前移动begin跳过我们刚刚加入的元素
}
```

此代码的行为是未定义的。在很多标准库实现上，此代码会导致无限循环。问题在于我们将end操作返回的迭代器保存在一个名为end的局部变量中。在循环体中，我们向容器中添加了一个元素，这个操作使保存在end中的迭代器失效了。

## 9.4 vector对象是如何增长的

当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。

#### 管理容量的成员函数

![](https://cdn.pkubailu.cn/img/9.10.png)

> reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。

只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）

如果需求大小小于或者等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。

调用reserve永远也不会减少容器占用的内存空间。类似的，resize成员函数只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。

在新标准库中，我们可以调用shrink_to_fit来要求deque、vector、string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。

#### capacity和size

理解capacity和size的区别非常重要。容器的size是指他已经保存的元素的数量：而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。

实际上，只要没有操作需求超出vector的容量，vector就不能重新分配内存空间。

> Note! 每个vector实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当迫不得已时才可以分配新的内存空间。

## 9.5 额外的string操作

### 9.5.1 构造string的其他方法

![](https://cdn.pkubailu.cn/img/9.11.png)

这些构造函数接受一个string或一个const char*参数，还接受（可选的）指定拷贝多少个字符的参数。当我们传递给他们的是一个string时，还可以给定一个下标来指出从哪里开始拷贝。

![](https://cdn.pkubailu.cn/img/9.11-1.png)

通常当我们从一个const char*创建string时，指针指向的数据必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。如果我们未传递计数值且数组也未必以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。

#### substr操作

![](https://cdn.pkubailu.cn/img/9.12.png)

### 9.5.2 改变string的其他方法

除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。下标指出了开始删除的位置，或是insert到给定值之前的位置：

```C++
s.insert(s.size(), 5, '!'); // 在s末尾插入5个感叹号
s.erase(s.size() - 5, 5); // 从s删除最后5个字符
```

标准库string类型还提供了接受C风格字符数组的insert和assign版本。例如，我们可以将以空字符结尾的字符数组insert到或assign给一个string：

```C++
const char *cp = "Stately, plump Buck";
s.assign(cp, 7); // s == "Stately"
s.insert(s.size(), cp + 7); // s == "Stately, plump Buck"
```

我们也可以指定将来自其他string或子字符串的字符插入到当前string中或赋予当前string：

```C++
string s = "Some string", s2 = "Some other string";
s.insert(0, s2); // 在s中位置0之前插入s2的拷贝
// 在s[0]之前插入s2中s2[0]开始的s2.size()个字符
s.insert(0, s2, 0, s2.size());
```

#### append 和 replace 函数

![](https://cdn.pkubailu.cn/img/9.13-0.png)

![](https://cdn.pkubailu.cn/img/9.13-1.png)

![](https://cdn.pkubailu.cn/img/9.13-2.png)

#### 改变string的多种重载函数

assign和append函数无需指定要替换string中哪个部分：assign总是替换string中的所有内容，append总是将新字符追加到string末尾。

### 9.5.3 string搜索操作

这些搜索成员函数及其参数。每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义为一个const string::size_type类型，并初始化为值-1。

![](https://cdn.pkubailu.cn/img/9.14-0.png)

![](https://cdn.pkubailu.cn/img/9.14-1.png)

![](https://cdn.pkubailu.cn/img/9.14-2.png)

#### 9.5.4 compare函数

![](https://cdn.pkubailu.cn/img/9.15.png)

### 9.5.5 数值转换

![](https://cdn.pkubailu.cn/img/9.16.png)

## 9.6 容器适配器

除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue、priorty_queue。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。

![](https://cdn.pkubailu.cn/img/9.17.png)

#### 定义一个适配器

每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。

```C++
stack<int> stk(deq); // 从deq拷贝元素到stk
```

默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。

```C++
// 在vector上实现的空栈
stack<string, vector<string>> str_stk;
// str_stk2 在
stack<string, vector<string>> str_stk2(svec);
```

对于一个给定的适配器，可以使用哪些容器是有限制的。所有的适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array之上。类似的，我们也不能用forward_list来构造适配器，因为所有的适配器都要求容器具有添加、删除以及访问尾元素的能力。

#### 栈适配器

![](https://cdn.pkubailu.cn/img/9.18.png)

每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作。我们只可以使用适配器操作，而不能使用底层容器类型的操作。

#### 队列适配器

![](https://cdn.pkubailu.cn/img/9.19-1.png)

![](https://cdn.pkubailu.cn/img/9.19-2.png)

# 第10章 泛型算法

> 关键概念：泛型算法永远不会执行容器的操作，他们只会运行于迭代器之上，执行迭代器的操作。算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。

## 10.2 初识泛型算法

虽然大多数算法遍历输入范围的方式相似，但它们使用范围中元素的方式不同。理解算法的最基本的方法就是了解他们是否读取元素、改变元素或是重排元素。

### 10.2.1 只读算法

```C++
// 对vec中的元素求和，和的初值是0
int sum = accumulate(vec.cbegin(), vec.cend());
```

accumulate将第三个参数作为求和的起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。

> Note! accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。

```C++
// 由于string定义了+运算符，所以我们可以通过调用accumulate来将vector中所有string元素连接起来
string sum = accumulate(v.cbegin(), v.cend(), string(""));
// 错误：const char* 上没有定义+运算符
string sum = accumulate(v.cbegin(), v.cend(), "");
```

#### 操作两个序列的算法

```C++
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```

由于equal利用迭代器完成操作，因此我们可以通过调用equal来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用==来比较两个元素类型即可。例如，在此例中，roster1可以是vector<string>,而roster2是list<const char*>。

但是，equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。

> 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。

### 10.2.2 写容器元素的算法

一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此他们自身不可能改变容器的大小。

#### 算法不检查写操作

一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数fill_n接受一个迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。

```C++
vector<int> vec; // 空vector
fill_n(vec.begin(), vec.size(), 0);
// 灾难: 修改vec中的10个（不存在）元素
// 这个调用是一场灾难。我们指定了要写入10个元素，但vec中并没有元素——他是空的，这条语句的结果是未定义的。
fill_n(vec.begin(), 10, 0);
```

#### 介绍back_inserter

一种保证算法有足够元素空间来容纳输出数据的方法是使用**插入迭代器**。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器所指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。

back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。

```C++
vector<int> vec; // 空向量
fill_n(back_inserter(vec), 10, 0);
```

在每步迭代中，fill_n向给定序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。

#### 拷贝算法

拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy的目的序列至少要包含与输入序列一样多的元素。

```C++
// 我们可以用copy实现内置数组的拷贝
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];
//ret 指向拷贝到a2的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2);
```

copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。

多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果。

例如，replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：

```C++
// 将所有值为0的元素改为42
replace(ilst.begin(), ilst.end(), 0, 42);
// 如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置
replace_copy(ilst.begin(), ilst.end(), back_inserter(ivec), 0, 42);
// 此调用后，ilst并未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素在ivec中都变为42
```

### 10.2.3 重排容器元素的算法

某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的<运算符来实现排序的。

#### 消除重复单词

为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分。由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作。

```C++
void elimDups(vector<int> &word) {
  // 按字典排序words，以便查找重复单词
  sort(word.begin(), word.end());
  // unique重排输入范围，使得每个单词只出现一次
  // 排列在范围的前部，返回指向不重复区域之后第一个位置的迭代器
  auto end_unique = unique(word.begin(), word.end());
  // 使用向量操作erase删除重复单词
  word.erase(end_unique, word.end());
}
```

#### 使用unique

![](https://cdn.pkubailu.cn/img/使用unique.png)

> 标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素

## 10.3 定制操作

很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的<或==运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。

例如，sort算法默认使用元素类型的<运算符。但可能我们希望的排序顺序与<所定义的顺序不同，或是我们的序列可能保存的是未定义<运算符的元素类型（如Sales_data）。在这两种情况下，都需要重载sort的默认行为。

### 10.3.1 向算法传递函数

为了按长度重排vector，我们将使用sort的第二个版本，此版本是重载过的，他接受第三个参数，此参数是一个谓词。

#### 谓词

谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：**一元谓词**（意味着他们只接受单一参数）和**二元谓词**（意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。

```C++
bool isShorter(const string &s1, const string &s2) {
  return s1.size() < s2.size();
}
// 按长度由短至长排序words
sort(words.begin(), words.end(), isShorter);
```

#### 排序算法

在我们将words按大小重排的同时，还希望具有相同长度的元素按字典序排列。为了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。

```C++
elimDups(words); // 将words按字典序重排，并消除重复单词
// 按长度重新排序，长度相同的单词维持字典序
stable_sort(words.begin(), words.end(), isShorter);
```

### 10.3.2 lambda 表达式

根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。

举个例子：求大于等于一个给定长度的单词有多少。

![](https://cdn.pkubailu.cn/img/lambda表达式.png)

#### 介绍lambda

我们可以向一个算法传递任何类别的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。

到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针。还有其他两种可调用对象：重载了函数调用运算符的类，以及lambda表达式。

一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何内联函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。一个lambda表达式具有如下形式：

```C++
[capture list] (parameter list) -> return type {function body}
```

其中，capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）return type、parameter list、function body与任何普通函数一样，分别表示返回类型、参数列表、函数体。但是，与普通函数不同，lambda必须使用尾置返回来指定返回类型。

我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体

```C++
auto f = [] { return 42; };
```

此例中，我们定义了一个可调用对象f，它不接收参数，返回42。

lambda的调用方式与普通函数的调用方式相同，都是使用调用运算符。

在lambda中忽略括号和参数列表等价于制定一个空参数列表。在此例中，当调用f时，参数列表是空的。如果忽略返回类型，lambda根据函数体中的代码推断出返回类型。如果函数体内是一个return语句，则返回类型从返回的表达式的类型推断而来。否则，返回类型为void。

> 如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。

#### 向lambda传递参数

与一个普通函数调用类似，调用一个lambda时给定的实参被用来初始化lambda的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，**lambda不能有默认参数**。因此，一个lambda调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。

例子：

```C++
[](const string &s1, const string &s2) { return s1.size() < s2.size(); }
```

空捕获列表表明此lambda不使用他所在函数中的任何局部变量。

```C++
stable_sort(words.begin(), words.end(), 
           [](const string &s1, const string &s2) 
            { return s1.size() < s2.size(); });
```

当stable_sort需要比较两个元素时，他就会调用给定的这个lambda表达式。

#### 使用捕获列表

虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需的信息。

```C++
// 在本例中，我们的lambda会捕获sz，并只有单一的string参数。其函数体会将string的大小与捕获的sz的值进行比较：
[sz](const string &s)
	{ return s.size() >= sz; };
```

由于此lambda捕获sz，因此lambda的函数体可以使用sz。lambda没有捕获words,因此不能访问此变量。

> 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。

#### 调用find_if

使用此lambda，我们就可以查找第一个长度大于等于sz的元素：

```C++
// 获取一个迭代器，指向第一个满足size() >= sz 的元素
auto wc = find_if(words.begin(), words.end(), 
           [sz](const string &s) 
            { return s.size() < sz; });
```

我们可以使用find_if返回的迭代器来计算从它开始到words的末尾一共有多少个元素：

```C++
auto count = words.end() - wc;
```

#### for_each 算法

打印words中长度大于等于sz的元素。为了达到这一目的，我们可以使用for_each算法。此算法接受一个可调用对象，并对输入序列中每个元素调用此对象：

```C++
for_each(wc, words.end(), 
        [](const string &s){ cout << s << "" });
```

捕获列表为空，是因为我们只对lambda所在函数中定义的（非static）变量使用捕获列表。一个lambda可以直接使用定义在当前函数之外的名字。cout不是定义在biggies中的局部名字，而是定义在头文件iostream中。

#### 完整的 biggies

![](https://cdn.pkubailu.cn/img/完整的biggies.png)

### 10.3.3 lambda 捕获和返回

当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。

默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。

#### 值捕获

类似参数传递，变量的捕获方式也可以是值或引用。到目前为止，我们的lambda采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。

```C++
void fcn1() {
  size_t v1 = 42;
  auto f = [v1] { return v1; };
  v1 = 0;
  auto j = f(); // j是42；f保存了我们创建它时v1的拷贝
}
```

#### 引用捕获

我们定义lambda时可以采用引用方式捕获变量。

```C++
void fcn1() {
  size_t v1 = 42;
  auto f = [&v1] { return v1; };
  v1 = 0;
  auto j = f(); // j是0；f保存v1的引用，而非拷贝
}
```

v1之前的&指出v1应该以引用方式捕获。一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在lambda函数体内使用此变量时，实际上使用的是引用所绑定的对象。

引用捕获与返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。

我们也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。

> 当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。

![](https://cdn.pkubailu.cn/img/lambda建议.png)

#### 隐式捕获

除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&或=。&告诉编译器采用捕获引用方式，=则表示采用值捕获方式。

```C++
// sz 为隐式捕获，值捕获方式
wc = find_if(words.begin(), words.end(), 
           [=](const string &s) 
            { return s.size() < sz; });
```

如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：

```C++
void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os = cout, char c = ' ') {
  // os隐式捕获，引用捕获；c显式捕获，值捕获
  for_each(words.begin(), words.end(), 
           [&, c](const string &s) { os << s << c; });
  // os显式捕获，引用捕获；c隐式捕获，值捕获
  for_each(words.begin(), words.end(), 
           [=, &os](const string &s) { os << s << c; });
}
```

当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。此符号指定了默认捕获方式为引用或值。

**当混合使用隐式捕获和显式捕获时，显示捕获的变量必须使用与隐式捕获不同的方式。**

![](https://cdn.pkubailu.cn/img/10.1.png)

#### 可变lambda

默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。因此，可变lambda能省略参数列表：

```C++
void fcn3() {
  size_t v1 = 42;
  auto f = [=] () mutable { return ++v1; };
  v1 = 0;
  auto j = f(); // j是43
}
```

一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型。

```C++
void fcn4() {
  size_t v1 = 42;
  // v1是一个非const变量的引用
  auto f = [&] () { return ++v1; };
  v1 = 0;
  auto j = f(); // j是1
}
```

#### 指定lambda 返回类型

默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。与其他返回void的函数类似，被推断返回void的lambda不能返回值。

函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。

```C++
// lambda体是单一的return语句，返回一个条件表达式的结果。我们无须指定返回类型，因为可以根据条件运算符的类型推断出来
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i){ return i < 0 ? -i : i; });
// 错误：不能推断lambda的返回类型
// 编译器推断这个版本的lambda返回类型为void，但它返回了一个int值
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i){ if(i<0) return -i; else return i; });
// 当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型
transform(vi.begin(), vi.end(), vi.begin(),
         [](int i) -> int
         { if(i<0) return -i; else return i; });
```

### 10.3.4 参数绑定

对于那种只在一两个地方使用的简单操作，lambda表达式是最有用的。如果我们需要在很多地方使用相同的操作中，通常应该定义一个函数，而不是多次编写相同的lambda表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。

如果lambda的捕获列表为空，通常可以用函数来代替它。

但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。

例如，我们用在find_if调用中的lambda比较一个string和一个给定大小。我们可以很容易地编写一个完成同样工作的函数：

```C++
bool check_size(const string &s, string::size_type sz) {
  return s.size() >= sz;
}
```

但是，我们不能用这个函数作为find_if的一个参数。find_if接受一个一元谓词，因此传递给find_if的可调用对象必须接受单一参数。

#### 标准库bind函数

bind的标准库函数，它定义在头文件functional中，可以将bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。

```C++
// 调用bind的一般形式为：
auto newCallable = bind(callable, arg_list);
```

其中，newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。

arg_list中的参数可能包含形如\_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，她们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，\_2为第二个参数，依此类推。

#### 绑定check_size 的sz参数

作为一个简单的例子，我们将使用bind生成一个调用check_size的对象。

```C++
// check6 是一个可调用对象，接受一个string类型的参数
// 并用此string和值6来调用check_size
auto check6 = bind(check_size, _1, 6);
```

此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const string&。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。

使用bind，我们可以将原来基于lambda的find_if调用替换为如下形式：

```C++
// lambda 形式
auto wc = find_if(words.begin(), words.end(), 
           [sz](const string &s) 
            { return s.size() < sz; });
// bind形式
auto wc = find_if(words.begin(), words.end(), 
           bind(check_size, _1, sz));
```

#### 使用placeholders名字

名字_n都定义在一个名为placeholders中，而此命名空间又定义在命名空间std中。

为了使用这些名字，两个命名空间都要写上。与我们的其他例子类似，对bind的调用代码假定之前已经恰当地使用了using声明。

```C++
// 例如，_1对应的using声明为：
using std::placeholders::_1;
```

此声明说明我们要使用的名字_1定义在命名空间placeholders中，而此命名空间又定义在命名空间std中。

对每个占位符名字，我们都必须提供一个单独的using声明。编写这样的声明很烦人，也很容易出错。可以使用另外一种不同形式的using语句，而不是分别声明每个占位符。

```C++
using namespace namespace_name;
```

这种形式说明希望所有来自namespace_name的名字都可以在我们的程序中直接使用。

```C++
using namespace std::placeholders;
```

使得由placeholders定义的所有名字都可用。与bind函数一样，placeholders命名空间也定义在functional头文件中。

#### bind 的参数

我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。例如，假定f是一个可调用对象，它有5个参数，则下面对bind的调用

```C++
// g 是一个有两个参数的可调用对象
auto g = bind(f, a, b, _2, _c, _1);
```

生成一个新的可调用对象，它有两个参数，分别用占位符\_2和_1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参数分别被绑定到给定值a、b和c上。

传递给g的参数按位置绑定到占位符。即，第一个参数绑定到_1，第二个参数绑定到\_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。实际上，这个bind调用会将

```C++
g(_1, _2);
// 映射为
f(a, b, _2, c, _1);
// 例如，调用g(X,Y)会调用
f(a, b, Y, c, X);
```

#### 用bind重排参数顺序

我们可以用bind颠倒isShorter的含义：

```C++
// 按单词长度由短至长排序
sort(words.begin(), words.end(), isShorter);
// 按单词长度由长至短排序
sort(words.begin(), words.end(), bind(isShorter, _2, _1));
```

在第一个调用中，当sort需要比较两个元素A和B时，它会调用isShorter(A,B)。

在第二个对sort的调用中，传递给isShorter的参数被交换过来了。因此，当sort比较两个元素时，就好像调用isShorter(B,A)一样。

#### 绑定引用参数

默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。

但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。

```C++
// 错误： 不能拷贝os
for_each(words.begin(), words.end(), bind(print, os, _1, ' '));
```

原因在于bind拷贝其参数，而我们不能拷贝一个ostream。如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库**ref**函数：

```C++
for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));
```

函数ref返回一个对象，包含给定的的引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文件functional中。

## 10.4 再探迭代器

除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。

- **插入迭代器**：这些迭代器被绑定到一个容器上，可用来向容器插入元素。
- **流迭代器**：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流
- **反向迭代器**：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。
- **移动迭代器**：这些专用的迭代器不是拷贝其中的元素，而是移动它们。

### 10.4.1 插入迭代器

插入器是一种迭代器适配器，他接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。

![](https://cdn.pkubailu.cn/img/10.2.png)

插入器有三种类型，差异在于元素插入的位置：

- **back_inserter**：创建一个使用push_back的迭代器。
- **front_inserter**：创建一个使用push_front的迭代器
- **inserter**：创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。

> Note! 只有在容器支持push_front的情况下，我们才可以使用front_inserter。类似的，只有在容器支持push_back的情况下，我们才能使用back_inserter。

理解插入器的工作过程是很重要的：当调用inserter(c,iter)时，我们得到一个迭代器，接下来使用它时，会将元素插入到iter原来所指向的元素之前的位置。即，如果it是由inserter生成的迭代器。

```C++
*it = val;
// 其效果与下面代码一样
it = c.insert(it, val); // it指向新加入的元素
++it; // 递增it使它指向原来的元素
```

front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当我们使用front_inserter时，元素总是插入到容器第一个元素之前。即使我们传递给inserter的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：

```C++
list<int> lst = {1,2,3,4};
list<int> lst2, lst3; // 空list
// 拷贝完成后，lst2包含4 3 2 1 
copy(lst.cbegin(), lst.cend(), front_inserter(lst2));
// 拷贝完成后，lst3包含1 2 3 4
copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));
```

当调用front_inserter(c)时，我们得到一个插入迭代器，接下来会调用push_front。当每个元素被插入到容器c中时，它变为c的新的首元素。因此，front_inserter生成的迭代器会将插入的元素序列的顺序颠倒过来，而inserter和back_inserter则不会。

### 10.4.2 iostream 迭代器

虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器。**istream_iterator**读取输入流，**ostream_iterator**向一个输出流写数据。这些迭代器将他们对应的流当作一个特定类型的元素序列来处理。通过使用迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。

#### istream_iterator 操作

当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个istream_iterator使用>>来读取流。因此，istream_iterator要读取的类型必须定义了输入运算符。当创建一个istream_iterator时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当做尾后值使用的迭代器。

```C++
istream_iterator<int> int_it(cin); // 从cin读取int
istream_iterator<int> int_eof; // 尾后迭代器
ifstream in("afile");
istream_iterator<string> str_it(in); // 从"afile"读取字符串
```

例子：用istream_iterator从标准输入读取数据，存入一个vector

```C++
istream_iterator<int> in_iter(cin); // 从cin读取int
istream_iterator<int> eof; // 尾后迭代器
while (in_iter != eof) {
  // 后置递增运算读取流，返回迭代器的旧值
  // 解引用迭代器，获得从流读取的前一个值
  vec.push_back(*in_iter++);
}
```

此循环从cin读取int值，保存在vec中。在每个循环步中，循环体代码检查in_iter是否等于eof。eof被定义为空的istream_iterator，从而可以当做尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器相等。

我们可以将程序重写为如下形式，这体现了istream_iterator更有用的地方：

```C++
istream_iterator<int> in_iter(cin), eof; // 从cin读取int
vector<int> vec(in_iter, eof); // 从迭代器范围构造vec
```

本例中我们用一对表示元素范围的迭代器来构造vec。这两个迭代器是istream_iterator，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据为止。从流中读取的数据用来构造vec。

![](https://cdn.pkubailu.cn/img/10.3.png)

#### 使用算法操作流迭代器

由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。

```C++
// 我们可以用一对istream_iterator来调用accumulate
isstream_iterator<int> in_iter(cin), eof;
cout << accumulate(in_iter, eof, 0) << endl;
// 此调用会计算出从标准输入读取的值的和
```

#### istream_iterator 允许使用懒惰求值

当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，知道我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。

#### ostream_iterator 操作

我们可以对任何具有输出运算符（<<运算符）的类型定义ostream_iterator。当创建一个ostream_iterator时，我们可以提供（可选的）第二个参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面值常量或者一个指向以空字符结尾的字符数组的指针）。必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator。

![](https://cdn.pkubailu.cn/img/10.4.png)

我们可以用ostream_iterator来输出值得序列：

```C++
ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec)
  *out_iter++ = e; // 赋值语句实际上将元素写到cout
cout << endl;
```

此程序将vec中的每个元素写到cout，每个元素后加一个空格。每次向out_iter赋值时，写操作就会被提交。

值得注意的是，当我们向out_iter赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子：

```C++
for (auto e : vec)
  out_iter = e;
```

运算符*和++实际上对ostream_iterator对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。

可以通过调用copy来打印vec中的元素，这比编写循环更为简单：

```C++
copy(vec.begin(), vec.end(), out_iter);
cout << endl;
```

#### 使用流迭代器处理类类型

![](https://cdn.pkubailu.cn/img/使用流迭代器处理类类型.png)

### 10.4.3 反向迭代器

反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素：递减一个迭代器（--it）会移动到下一个元素。

除了forward_list之外，其他容器都支持反向迭代器。我们可以通过调用rbegin、rend、crbegin和crend成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有const和非const版本。

![](https://cdn.pkubailu.cn/img/反向迭代器.png)

虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做是我们可以用算法透明的向前或向后处理容器。例如，可以通过向sort传递一对反向迭代器来将vector整理为递减排序

```C++
sort(vec.begin(), vec.end()); // 按”正常序“排列vec
sort(vec.rbegin(), vec.rend()); // 按”逆序“排列vec
```

#### 反向迭代器需要递减运算符

不必惊讶，我们只能从既支持++也支持--的迭代器来定义反向迭代器。毕竟反向迭代器的目的是在序列中反向移动。除了forward_list之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个forward_list或一个流迭代器创建反向迭代器。

#### 反向迭代器和其他迭代器间的关系

![](https://cdn.pkubailu.cn/img/反向迭代器和其他迭代器间的关系.png)

图10.2中的对象显示了普通迭代器与反向迭代器之间的关系。例如，rcomma和rcomma.base()指向不同的元素，line.crbegin和line.cend()也是如此。这些不同保证了元素范围无论是正向处理还是反向处理都是相同的。

> Note! 反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要的结果：当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。

## 10.5 泛型算法结构

人和算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如find，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如sort，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别。

![](https://cdn.pkubailu.cn/img/10.5.png)

第二种算法分类的方式是按照是否读、写或是重排序列中的元素来分类。

### 10.5.1  5类迭代器

类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持，另外一些只有特定类别的迭代器才支持。例如，ostream_iterator只支持递增、解引用和赋值。vector、string和deque的迭代器除了这些操作外，还支持递减、关系和算术运算。

迭代器是按他们所提供的操作来分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。

C++标准指明了泛型和数值算法的每个迭代器参数的最小类别。例如，find算法在一个序列上进行一边扫描，对元素进行只读操作，因此至少需要输入迭代器。replace函数需要一对迭代器，至少是前向迭代器。对每个迭代器参数来说，其能力必须与规定的最小类别至少相当。向算法传递一个能力更差的迭代器会产生错误。

> 对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或提示。

#### 迭代器类别

**输入迭代器**：可以读取序列中的元素。一个输入迭代器必须支持

- 用于比较两个迭代器的相等和不相等运算符（==、！=）
- 用于推进迭代器的前置和后置递增运算（++）
- 用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧
- 箭头运算符（->），等价于(*it).member，即，解引用迭代器，并提取对象的成员

输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法find和accumulate要求输入迭代器；而istream_iterator是一种输入迭代器。

**输出迭代器**：可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：

- 用于推进迭代器的前置和后置递增运算（++）
- 解引用运算符（*），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）

我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，copy函数的第三个参数就是输出迭代器。ostream_iterator类型也是输出迭代器

**前向迭代器**：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多变扫描。算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。

**双向迭代器**：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（--）。算法reverse要求双向迭代器。除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。

**随机迭代器**：提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持：

- 用于比较两个迭代器相对位置的关系运算符（<、<=、>和>=）
- 迭代器和一个整数值的加减运算（+、+=、-和-=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置
- 用于两个迭代器上的减法运算符（-），得到两个迭代器的距离。
- 下标运算符（iter[n]，与*(iter[n])等价

算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。

### 10.5.2 算法形参模式

在任何其他算法分类之上，还有一组参数规范。理解这些参数规范对学习新算法很有帮助——通过理解参数的含义，你可以将注意力集中在算法所做的操作上。大多数算法具有如下4种形式之一：

```C++
alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
```

#### 接受单个目标迭代器的算法

dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定：按其需要写入数据，不管写入多少个元素都是安全的。

> Warning! 向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。

如果dest是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的元素内。更常见的情况是，dest被绑定到一个插入迭代器或是一个ostream_iterator。插入迭代器会将新元素添加到容器中，因而保证空间是足够的。ostream_iterator会将数据写入到一个输出流，同样不管写入多少个元素都没有问题。

#### 接受第二个输入序列的算法

> 接收单独beg2的算法假定从beg2开始的序列与beg和end所表示的范围至少一样大。

### 10.5.3 算法命名规范

除了参数规范，算法还遵循一套命名和重载规范。这些规范处理诸如：如何提供一个操作代替默认的<或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。

#### 一些算法使用重载形式传递一个谓词

接受谓词参数来代替<或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替<或==：

```C++
unique(beg, end); // 使用 == 运算符比较元素
unique(beg, end, comp); // 使用comp比较元素
```

两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的==运算符来检查重复元素；第二个则调用comp来确定两个元素是否相等。由于两个版本的函数在参数个数上不相等，因此具体应该调用哪个版本不会产生歧义。

#### _if版本的算法

接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的_if前缀：

```C++
find(beg, end, val); // 查找输入范围中val第一次出现的位置
find_if(beg, end, pred); // 查找第一个令pred为真的元素
```

这两个算法提供了命名上差异的版本，而非重载版本，因为这两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但是为了避免任何可能的歧义，标准库选择提供不同名字的版本而不是重载。

#### 区分拷贝元素的版本和不拷贝的版本

默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个_copy：

```C++
reverse(beg, end); // 反转输入范围中元素的顺序
reverse_copy(beg, end, dest); // 将元素按逆序拷贝到dest
```

一些算法同时提供_copy和\_if版本。这些版本接受一个目的位置迭代器和一个谓词：

```C++
// 从v1中删除奇数元素
remove_if(v1.begin(), v1.end(), [](int i){ return i%2; });
// 将奇数元素从v1拷贝到v2;v1不变
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i){ return i%2; });
```

## 10.6 特定容器算法

与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法。特别是，它们定义了独有的sort、merge、remove、reverse和unique。通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器。

链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个列表可以通过改变元素间的链接而不是真的交换他们的值来快速”交换“元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。

> 对于list和forward_list，应该优先使用成员函数版本的算法而不是通用算法。

![](https://cdn.pkubailu.cn/img/10.6-1.png)

![](https://cdn.pkubailu.cn/img/10.6-2.png)

#### splice 成员

此算法是链表数据结构所特有的。

![](https://cdn.pkubailu.cn/img/10.7.png)

#### 链表特有的操作会改变容器

多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。

例如，通用版本的merge将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的merge函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。

# 第11章 关联容器

关联容器支持高效的关键字查找和访问。两个主要的**关联容器**类型是map和set。map中的元素是一些（关键字-值）对：关键字起到索引的作用，值则表示与索引相关联的数据。set中每个元素只包含一个关键字；set支持高效的关键字查询操作—检查一个给定关键字是否在set中。例如，在某些文本处理过程中，可以用一个set来保存想要忽略的单词。字典则是一个很好的使用map的例子：可以将单词作为关键字，将单词释义作为值。

标准库提供8个关联容器。这8个荣期间的不同体现在三个维度上：

1. 或者是一个set，或者是一个map；
2. 或者要求不重复的关键字，或者允许重复关键字；
3. 按顺序保存元素，或无序保存。

允许重复关键字的容器的名字中都包含单词multi；

不保持关键字按顺序存储的容器的名字都以单词unordered开头。

无序容器使用哈希函数来组织元素。

![](https://cdn.pkubailu.cn/img/11.1.png)

## 11.1 使用关联容器

map通常被称为**关联数组**。关联数组与”正常数组“类似，不同之处在于其下标不必是整数。我们通过一个关键字而不是位置来查找值。

与之相对，set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。

#### 使用 map

![](https://cdn.pkubailu.cn/img/使用map.png)

#### 使用 set

![](https://cdn.pkubailu.cn/img/使用set-1.png)

![](https://cdn.pkubailu.cn/img/使用set-2.png)

## 11.2 关联容器概述

