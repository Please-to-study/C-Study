# 第 15 章 面向对象程序设计

面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。

继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉他们的区别。

在很多程序中都存在着一些相互关联但是有细微差别的概念。例如，书店中不同书籍的定价策略可能不同：有的书籍按原价销售，有的则打折销售。有时，我们给那些购买书籍超过一定数量的顾客打折；另一些时候，则只对前多少本销售的书籍打折，之后就调回原价，等等。面向对象的程序设计(OOP)适用于这类应用。

## 15.1 OOP: 概述

**面向对象程序设计**的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

#### 继承

通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类**，其他类则直接或间接地从基类继承而来，这些继承得到的类称为**派生类**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。

为了对之前提到的不同定价策略建模，我们首先定义一个名为 Quote 的类，并将它作为层次关系中的基类。Quote 的对象表示按原价销售的书籍。Quote 派生出另一个名为 Bulk_quote 的类，它表示可以打折销售的书籍。

这些类将包含下面的两个成员函数：

- isbn()，返回书籍的 ISBN 编号。该操作不涉及派生类的特殊性，因此只定义在 Quote 类中。
- net_price(size_t)，返回书籍的实际销售价格，前提是用户购买该书的数量达到一定标准。这个操作显然是类型相关的，Quote 和 Bulk_quote 都应该包含该函数。

在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数**。因此，我们可以将 Quote 类编写成：

```C++
class Quote {
public:
  std::string isbn() const;
  virtual double net_price(std::size_t n) const;
};
```

派生类必须通过使用**类派生列表**明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符：

```C++
class Bulk_quote : public Quote {
public:
  double net_price(std::size_t) const override;
};
```

因为 Bulk_quote 在它的派生列表中使用了 public 关键字，因此我们完全可以把 Bulk_quote 的对象当成 Quote 的对象来使用。

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtual 关键字，但是并不是非得这么做。C++新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个 override 关键字。

#### 动态绑定

通过使用**动态绑定**，我们能用同一段代码分别处理 Quote 和 Bulk_quote 的对象。例如，当要购买的书籍和购买的数量都已知时，下面的函数负责打印总的费用：

```C++
// 计算并打印销售给定数量的某种书籍所得的费用
double print_total (ostream &os, const Quote &item, size_t n)
{
  // 根据传入 item 形参的对象类型调用 Quote::net_price
  // 或者Bulk_quote::net_price
  double ret = item.net_price(n);
  os << "ISBN: " << item.isbn()
     << " # sold: " << n << " total due: " << ret << endl;
  return ret;
}
```

该函数非常简单：它返回调用 net_price() 的结果，并将该结果连同调用 isbn() 的结果一起打印出来。

关于上面的函数有两个有意思的结论：因为函数 print_total 的 item 形参是基类 Quote 的一个引用，我们既能使用基类 Quote 的对象调用该函数，也能使用派生类 Bulk_quote 的对象调用它；又因为 print_total 是使用引用类型调用 net_price 函数的，所以实际传入 print_total 的对象类型将决定到底执行 net_price 的哪个版本：

```C++
// basic 的类型是Quote bulk的类型是Bulk_quote
print_total(cout, basic, 20); // 调用 Quote 的net_price
print_total(cout, bulk, 20); // 调用 Bulk_quote 的net_price
```

第一条调用句将 Quote 对象传入 print_total，因此当 print_total 调用 net_price 时，执行的是 Quote 的版本；在第二条调用语句中，实参的类型是 Bulk_quote，因此执行的是 Bulk_quote 的版本（计算打折信息）。因为在上述过程中函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为**运行时绑定**。

> Note! 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

## 15.2 定义基类和派生类

定义基类和派生类的方式在很多方面都与我们已知的定义其他类的方式类似，但是也有一些不同之处。本节将介绍在定义有继承关系的类时可能用到的基本特性。

### 15.2.1 定义基类

我们首先完成 Quote 类的定义：

```C++
class Quote {
public:
  Quote() = default;
  Quote(const std::string &book, double sales_price): bookNo(book), price(sales_price) {}
  std::string isbn() const {return bookNo;}
  // 返回给定数量的书籍的销售总额
  // 派生类负责改写并使用不同的折扣计算方法
  virtual double net_price(std::size_t n) const
  				{return n * price;}
  virtual ~Quote() = default; // 对析构函数进行动态绑定
private:
  std::string bookNo;
protected:
  double price = 0.0; // 代表普通状态下不打折的价格
};
```

对于上面这个类来说，新增的部分是在 net_price 函数和析构函数之前增加的 virtual 关键字以及最后的 protected 访问说明符。我们将在15.7.1节详细介绍虚析构函数的知识，现在只需记住作为继承关系中根节点的类通常都会定义一个虚析构函数。

> Note! 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

#### 成员函数与继承

派生类可以继承其基类的成员，然而当遇到如 net_price 这样与类型相关的操作时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以覆盖从基类继承而来的旧定义。

在 C++语言中，基类必须将它的两种成员函数区分开来;一种是基类希望其派生类进行覆盖的函数;另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通常将其定义为虚函数。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

基类通过在其成员函数的声明语句之前加上关键字 virtual 使得该函数执行动态绑定。任何构造函数之外的非静态函数（参见7.6节）都可以是虚函数。关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。我们将在 15.3 节介绍更多关于虚函数的知识。

成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。对于 isbn 成员来说这正是我们希望看到的结果。isbn 函数的执行与派生类的细节无关，不管作用于 Quote 对象还是 Bulk_quote 对象，isbn 函数的行为都一样。在我们的继承层次关系中只有一个isbn 函数，因此也就不存在调用 isbn() 时到底执行哪个版本的疑问。

#### 访问控制与继承

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员。

我们的 Quote 类希望它的派生类定义各自的 net_price 函数，因此派生类需要访问 Quote 的 price 成员。此时我们将 price 定义成受保护的。与之相反，派生类访问 bookNo 成员的方式与其他用户是一样的，都是通过调用isbn 函数，因此 bookNo 被定义成私有的，即使是 Quote 派生出来的类也不能直接访问它。我们将在 15.5 节介绍更多关于受保护成员的知识。

### 15.2.2 定义派生类

派生类必须通过使用类派生列表明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected 或者 private。

派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明，因此，我们的 Bulk_quote 类必须包含一个 net_price 成员∶

```C++
class Bulk_quote : public Quote {  // Bulk_quote 继承自Quote public:
	Bulk_quote ()= default;
	Bulk quote(const std::string&, double, std::size_t, double);
  // 覆盖基类的函数版本以实现基于大量购买的折扣政策
  double net_price(std::size t) const override;
private:
	std:size_t min_qty = 0;	// 适用折扣政策的最低购买量
	double discount = 0.0;; // 以小数表示的折扣额
};
```

我们的 Bulk_quote 类从它的基类 Quote 那里继承了 isbn 函数和 bookNo、price 等数据成员。此外，它还定义了 net_price 的新版本，同时拥有两个新增加的数据成员 min_qty 和 discount。这两个成员分别用于说明享受折扣所需购买的最低数量以及一旦该数量达到之后具体的折扣信息。

我们将在15.5节详细介绍派生列表中用到的访问说明符。现在，**我们只需知道访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见**。

如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将公有派生类型的对象绑定到基类的引用或指针上。因为我们在派生列表中使用了 public。所以 Bulk_quote 的接口隐式地包含 isbn 函数，同时在任何需要 Quote 的引用或指针的地方我们都能使用 Bulk_quote 的对象。

大多数类都只继承自一个类，这种形式的继承被称作"单继承"，它构成了本章的主题。关于派生列表中含有多于一个基类的情况将在 18.3节中介绍。

#### 派生类中的虚函数

派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

派生类可以在它覆盖的函数前使用 virtual 关键字，但不是非得这么做。我们将在15.3节介绍其原因，C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在 const 成员函数（参见7.1.2节）的const关键字后面、或者在引用成员函数（参见13.6.3节）的引用限定符后面添加一个关键字 override。

#### 派生类对象及派生类向基类的类型转换

一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。因此，一个 Bulk_quote 对象将包含四个数据元素：它从 Quote 继承而来的 bookNo 和 price 数据成员，以及 Bulk_quote 自己定义的 min_qty 和 discount 成员。

C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为 Bulk_quote 的对象包含如图15.1所示的两部分。

![](https://cdn.pkubailu.cn/img/15.1.png)

因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。

```C++
Quote item;  // 基类对象
Bulk_quote bulk;  // 派生类对象
Quote* p = &item; // p指向Quote对象
p = &bulk;  // p指向bulk的 Quote部分
Quote &r = bulk;  // r绑定到 bulk的 Quote部分
```

这种转换通常称为**派生类到基类的**类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换（参见4.11节）。

这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。

> Note! 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。

#### 派生类构造函数

尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。

> Note! 每个类控制它自己的成员初始化过程。

派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段（参见7.5.1节）执行初始化操作的。类似于我们初始化成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个参数的 Bulk_quote 构造函数如下所示∶

```C++
Bulk_quote(const std::string& book, double p, std::size_t qty, double disc):
Quote(book, p), min_qty(qty), discount(disc) {} 
```

该函数将它的前两个参数（分别表示 ISBN 和价格）传递给 Quote 的构造函数，由 Quote 的构造函数负责初始化 Bulk_quote 的基类部分（即 bookNo 成员和 price 成员）。当（空的）Quote 构造函数体结束后，我们构建的对象的基类部分也就完成初始化了。接下来初始化由派生类直接定义的 min_qty 成员和 discount 成员。最后运行 Bulk_quote 构造函数的（空的）函数体。

除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分。

> Note! 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员.

#### 派生类使用基类的成员

派生类可以访问基类的公有成员和受保护成员

```C++
// 如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了
double Bulk_quote::net_price(size_t cnt) const
{
  if (cnt >= min_qty)
		return cnt * (1 - discount)* price;
  else
		return cnt* price;
}
```

该函数产生一个打折后的价格：如果给定的数量超过了 min_qty，则将 discount （一个小于1大于0的数）作用于 price。

我们将在 15.6节进一步讨论作用域，目前只需要了解派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员（例如min_qty 和 discount）的方式与使用基类成员（例如 price）的方式没什么不同。

>**关键概念：遵循基类的接口**
>
>必须明确一点：每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。
>
>因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。

#### 继承与静态成员

如果基类定义了一个静态成员（参见7.6节），则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。

```C++
class Base{
public:
	static void statmem();
};
class Derived : public Base {
	void f(const Derived&);
};
```

静态成员遵循通用的访问控制规则，如果基类中的成员是 private 的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它：

```C++
void Derived::f(const Derived &derived_obj)
{
	Base::statmem(); // 正确∶ Base定义了 statmem 
	Derived::statmem(); // 正确∶ Derived继承了 statmem 
	// 正确∶派生类的对象能访问基类的静态成员
	derived_obj.statmem(); // 通过 Derived对象访问
  statmem();  //通过 this 对象访问
}
```

#### 派生类的声明

派生类的声明与其他类差别不大（参见7.3.3节），声明中包含类名但是不包含它的派生列表：

```C++
class Bulk_quote ∶ public Quote; // 错误∶派生列表不能出现在这里
class Bulk_quote; // 正确∶声明派生类的正确方式
```

一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类、一个函数或一个变量等。派生列表以及与定义有关的其他细节必须与类的主体一起出现。

#### 被用作基类的类

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明：

```C++
class Quote; // 声明但未定义
// 错误∶Quote必须被定义
class Bulk_quote : public Quote { ...};
```

这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身。

一个类是基类，同时它也可以是一个派生类：

```C++
class Base {/* ...*/};
class D1 : public Base {/* ...*/};
class D2 : public D1 { /*...*/};
```

在这个继承关系中，Base 是 D1 的**直接基类**，同时是 D2 的间接基类。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。

每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又含有其基类的成员；依此类推直至继承链的顶端。因此，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

#### 防止继承的发生

有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final：

```C++
class NoDerived final {/**/); // NoDerived 不能作为基类
class Base {/**/ }; 
// Last是final的;我们不能继承 Last
class Last final : Base {/**/ };  // Last不能作为基类
class Bad : NoDerived {/* */ }; // 错误∶ NoDerived是 final的
class Bad2 : Last { /**/ }; // 错误∶Last 是 final的
```

### 15.2.3 类型转换与继承

> WARNING! 理解基类和派生类之间的类型转换是理解C++语言面向对象编程的关键所在。

通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致（参见2.3.1 节），或者对象的类型含有一个可接受的 const 类型转换规则（参见4.11.2节）。存在继承关系的类是一个重要的例外：我们可以将基类的指针或引用绑定到派生类对象上。例如，我们可以用 Quote& 指向一个 Bulk_quote 对象，也可以把一个 Bulk_quote 对象的地址赋给一个 Quote*。

可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。

> Note! 和内置指针一样，智能指针类（参见12.1节）也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。

#### 静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。

例如，当 print_total 调用 net_price 时（参见15.1节）：

```C++
double ret = item.net_price(n);
```

我们知道 item 的静态类型是 Quote&，它的动态类型则依赖于 item 绑定的实参，动态类型直到在运行时调用该函数时才会知道。如果我们传递一个 Bulk_quote 对象给 print_total，则 item 的静态类型将与它的动态类型不一致。如前所述，item 的静态类型是 Quote&，而在此例中它的动态类型则是 Bulk_quote。

如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。例如，Quote 类型的变量永远是一个 Quote 对象，我们无论如何都不能改变该变量对应的对象的类型。

> Note! 基类的指针或引用的静态类型可能与其动态类型不一致，读者一定要理解其中的原因。

#### 不存在从基类向派生类的隐式类型转换······

之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。

因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换：

```C++
Quote base;  
Bulk_quote* bulkP = &base; // 错误∶不能将基类转换成派生类
Bulk quote& bulkRef = base; // 错误∶不能将基类转换成派生类
```

如果上述赋值是合法的，则我们有可能会使用 bulkP 或 bulkRef 访问 base 中本不存在的成员。

除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：

```C++
Bulk_quote bulk;
Quote *itemP = &bulk; //正确∶动态类型是 Bulk_quote
Bulk_quote *bulkP = itemP; //错误∶不能将基类转换成派生类
```

编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以使用 dynamic_cast（参见 19.2.1 节）请求一个类型转换，该转换的安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用 static_cast（参见4.11.3节）来强制覆盖掉编译器的检查工作。

#### ······在对象之间不存在类型转换

**派生类向基类的自动类型转换只对指针或引用类型有效**，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。

请注意，当我们初始化或赋值一个类类型的对象时，实际上是在调用某个函数。当执行初始化时，我们调用构造函数（参见13.1.1 节和13.6.2节）;而当执行赋值操作时，我们调用赋值运算符（参见13.1.2节和13.6.2节）。这些成员通常都包含一个参数，该参数的类型是类类型的 const 版本的引用。

因为这些成员接受引用作为参数，所以派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象。这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员。

例如，我们的书店类使用了合成版本的拷贝和赋值操作（参见13.1.1 节和13.1.2节）。关于拷贝控制与继承的知识将在15.7.2节做更详细的介绍，现在我们只需要知道合成版本会像其他类一样逐成员地执行拷贝或赋值操作：

```C++
Bulk_quote bulk; // 派生类对象
Quote item(bulk); //使用 Quote∶∶Quote(const Quote&)构造函数
item = bulk;  //调用Quote∶∶operator=(const Quote&)
```

当构造 item 时，运行 Quote 的拷贝构造函数。该函数只能处理 bookNo 和 price 两个成员，它负责拷贝 bulk 中 Quote 部分的成员，同时忽略掉bulk中 Bulk_quote 部分的成员。类似的，对于将 bulk 赋值给 item 的操作来说，只有bulk 中 Quote 部分的成员被赋值给 item。

因为在上述过程中会忽略 Bulk_quote 部分，所以我们可以说 bulk 的 Bulk_quote 部分被切掉了。

> WARNING! 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。

> **关键概念：存在继承关系的类型之间的转换规则**
>
> 要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：
>
> - 从派生类向基类的类型转换只对指针或引用类型有效。
> - 基类向派生类不存在隐式类型转换。
> - 和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。我们将在15.5节详细介绍可访问性的问题。
>
> 尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制成员（参见第13章）。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。

## 15.3 虚函数

如前所述，在 C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定（参见 15.1 节）。因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，则无须为该函数提供定义（参见6.1.2节）。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。

#### 对虚函数的调用可能在运行时才被解析

当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。

举个例子，考虑15.1节的 print_total 函数，该函数通过其名为 item 的参数来进一步调用 net_price，其中 item 的类型是 Quote。因为 item 是引用而且 .net_price 是虚函数，所以我们到底调用 net_price 的哪个版本完全依赖于运行时绑定到 item 的实参的实际（动态）类型：

```C++
Quote base("0-201-82470-1",50);
print_total(cout, base, 10);  // 调用Quote∶∶net_price
Bulk_quote derived("0-201-82470-1", 50, 5, .19);
print_total(cout, derived, 10);  // 调用 Bulk_quote∶∶net_price
```

在第一条调用语句中，item 绑定到 Quote 类型的对象上，因此当 print_total 调用 net_price 时，运行在 Quote 中定义的版本。在第二条调用语句中，item 绑定到 Bulk_quote 类型的对象上，因此 print_total 调用 Bulk_quote 定义的 net_price。

必须要搞清楚的一点是，**动态绑定只有当我们通过指针或引用调用虚函数时才会发生**。

```C++
base = derived; //把 derived的 Quote 部分拷贝给 base
base.net_price(20); //调用 Quote∶∶net_price 
```

当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。例如，如果我们使用 base 调用 net_price，则应该运行 net_price 的哪个版本是显而易见的。我们可以改变 base 表示的对象的值（即内容），但是不会改变该对象的类型。因此，在编译时该调用就会被解析成 Quote 的 net_price。

> **关键概念：C++的多态性**
>
> OOP 的核心思想是多态性（polymorphism）。多态性这个词源自希腊语，其含义是"多种形式"。我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的"多种形式"而无须在意它们的差异。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。
>
> 当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型。
>
> 另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数（虚函数或非虚函数）调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。
>
> > Note! 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。

#### 派生类中的虚函数

当我们在派生类中覆盖了某个虚函数时，可以再一次使用 virtual 关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。

**一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致**。

同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果 D 由 B 派生得到，则基类的虚函数可以返回 B* 而派生类的对应函数可以返回 D*，只不过这样的返回类型要求从 D 到 B 的类型转换是可访问的。15.5节将介绍如何确定一个基类的可访问性，在15.8.1 节中我们将看到这种虚函数的一个实际例子。

> Note! 基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。

#### final 和 override 说明符

如我们将要在15.6节介绍的，派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。

要想调试并发现这样的错误显然非常困难。在 C++11 新标准中我们可以使用override 关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误，后者在编程实践中显得更加重要。如果我们使用 override 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错：

```C++
struct B {
	virtual void f1(int) const;
  virtual void f2();
  void f3();
};
struct D1 : B {
	void f1(int) const override; // 正确∶ f1与基类中的 f1匹配
  void f2(int) override;  //错误∶ B没有形如 f2(int) 的函数
	void f3() override;  // 错误∶ f3不是虚函数
	void f4 () override; //错误∶ B没有名为f4的函数
};
```

在 D1 中，f1 的 override 说明符是正确的，因为基类和派生类中的 f1 都是 const 成员，并且它们都接受一个 int 返回 void，所以 D1 中的 f1 正确地覆盖了它从 B 中继承而来的虚函数。

D1 中 f2 的声明与 B 中 f2 的声明不匹配，显然 B 中定义的 f2 不接受任何参数而 D1 的 f2 接受一个int。因为这两个声明不匹配，所以 D1 的 f2 不能覆盖 B 的 f2，它是一个新函数，仅仅是名字恰好与原来的函数一样而已。因为我们使用 override 所表达的意思是我们希望能覆盖基类中的虚函数而实际上并未做到，所以编译器会报错。

因为只有虚函数才能被覆盖，所以编译器会拒绝 D1 的 f3。该函数不是 B 中的虚函数，因此它不能被覆盖。类似的，f4 的声明也会发生错误，因为 B 中根本就没有名为 f4 的函数。

我们还能把某个函数指定为 final，如果我们已经把函数定义成 final 了，则之后任何尝试覆盖该函数的操作都将引发错误：

```C++
struct D2 : B {
	//从B继承f2()和 f3()，覆盖 f1(int)
	void f1(int) const final; // 不允许后续的其他类覆盖 f1(int)
};
struct D3 : D2 {
	void f2();  // 正确∶ 覆盖从间接基类 B 继承而来的 f2
	void f1(int) const; //错误∶D2 已经将 f1 声明成final
};
```

final 和 override 说明符出现在形参列表（包括任何const 或引用修饰符）以及尾置返回类型（参见6.3.3节）之后。

#### 虚函数与默认实参

和其他函数一样，虚函数也可以拥有默认实参（参见6.5.1节）。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。

换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。

> Note! 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

#### 回避虚函数的机制

在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如下面的代码：

```C++
//强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么
double undiscounted = baseP->Quote::net_price(42);
```

该代码强行调用 Quote 的 net_price 函数，而不管 baseP 实际指向的对象类型到底是什么。该调用将在编译时完成解析。

> Note! 通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。

什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。

> WARNING! 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。 

## 15.4 抽象基类

假设我们希望扩展书店程序并令其支持几种不同的折扣策略。除了购买量超过一定数量享受折扣外，我们也可能提供另外一种策略，即购买量不超过某个限额时可以享受折扣，但是一旦超过限额就要按原价支付。或者折扣策略还可能是购买量超过一定数量后购买的全部书籍都享受折扣，否则全都不打折。

上面的每个策略都要求一个购买量的值和一个折扣值。我们可以定义一个新的名为 Disc_quote 的类来支持不同的折扣策略，其中 Disc_quote 负责保存购买量的值和折扣值。其他的表示某种特定策略的类（如 Bulk_quote）将分别继承自 Disc_quote，每个派生类通过定义自己的 net_price 函数来实现各自的折扣策略。

在定义 Disc_quote 类之前，首先要确定它的 net_price 函数完成什么工作。显然我们的 Disc_quote 类与任何特定的折扣策略都无关，因此 Disc_quote 类中的 net_price 函数是没有实际含义的。

我们可以在 Disc_quote 类中不定义新的 net_price，此时，Disc_quote 将继承 Quote 中的 net_price 函数。

然而，这样的设计可能导致用户编写出一些无意义的代码。用户可能会创建一个 Dis_quote 对象并为其提供购买量和折扣值，如果将该对象传给一个像 print_total 这样的函数，则程序将调用 Quote 版本的 net_price。显然，最终计算出的销售价格并没有考虑我们在创建对象时提供的折扣值，因此上述操作毫无意义。

#### 纯虚函数

认真思考上面描述的情形我们可以发现，关键问题并不仅仅是不知道应该如何定义 net_price，而是我们根本就不希望用户创建一个 Disc_quote 对象。Disc_quote 类表示的是一本打折书籍的通用概念，而非某种具体的折扣策略。

我们可以将 net_price 定义成纯虚函数从而令程序实现我们的设计意图，这样做可以清晰明了地告诉用户当前这个 net_price 函数是没有实际意义的。和普通的虚函数不样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写 =0 就可以将一个虚函数说明为纯虚函数。其中，=0 只能出现在类内部的虚函数声明语句处：

```C++
// 用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略
class Disc_quote : public Quote {
public:
	Disc_quote() = default;
	Disc_quote(const std::string& book, double price, std::size_t qty, double disc) : Quote(book, price), quantity(qty), discount(disc) {}
	double net_price(std::size_t) const = 0;
protected:
	std::size_t quantity = 0; //折扣适用的购买量
	double discount = 0.0; // 表示折扣的小数值
};
```

和我们之前定义的 Bulk_quote 类一样，Disc_quote 也分别定义了一个默认构造函数和一个接受四个参数的构造函数。尽管我们不能直接定义这个类的对象，但是 Disc_quote 的派生类构造函数将会使用 Disc_quote 的构造函数来构建各个派生类对象的 Disc_quote 部分。其中，接受四个参数的构造函数将前两个参数传递给 Quote 的构造函数，然后直接初始化自己的成员 discount 和 quantity。默认构造函数则对这些成员进行默认初始化。

值得注意的是，**我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部**。 也就是说，我们不能在类的内部为一个 =0 的函数提供函数体。

#### 含有纯虚函数的类是抽象基类

含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。因为 Disc_quote 将 net_price 定义成了纯虚函数，所以我们不能定义 Disc_quote 的对象。我们可以定义 Disc_quote 的派生类的对象，前提是这些类覆盖了 net_price 函数：

```C++
// Disc_quote 声明了纯虚函数，而 Bulk_quote将覆盖该函数
Disc_quote discounted; // 错误∶不能定义 Disc_quote的对象
Bulk_quote bulk; // 正确∶ Bulk_quote中没有纯虚函数
```

Disc_quote 的派生类必须给出自己的 net_price 定义，否则它们仍将是抽象基类。

> Note! 我们不能创建抽象基类的对象。

#### 派生类构造函数只初始化它的直接基类

接下来可以重新实现 Bulk_quote了，这一次我们让它继承 Disc_quote 而非直接继承 Quote：

```C++
// 当同一书籍的销售量超过某个值时启用折扣
//折扣的值是一个小于1的正的小数值，以此来降低正常销售价格
class Bulk_quote : public Disc_quote {
public:
	Bulk_quote()= default;
  Bulk_quote(const std::string& book, double price, std::size_t qty, double disc):
	Disc_quote(book, price, qty, disc) { }
  // 覆盖基类中的函数版本以实现一种新的折扣策略
	double net_price(std::size_t) const override;
};
```

这个版本的 Bulk_quote 的直接基类是 Disc_quote，间接基类是 Quote。每个Bulk_quote 对象包含三个子对象：一个（空的）Bulk_quote 部分、一个Disc_quote 子对象和一个 Quote 子对象。

如前所述，每个类各自控制其对象的初始化过程。因此，即使 Bulk_quote 没有自己的数据成员，它也仍然需要像原来一样提供一个接受四个参数的构造函数。该构造函数将它的实参传递给 Disc_quote 的构造函数，随后 Disc_quote 的构造函数继续调用 Quote 的构造函数。Quote 的构造函数首先初始化 bulk 的 bookNo和 price 成员，当 Quote 的构造函数结束后，开始运行 Disc_quote 的构造函数并初始化 quantity 和 discount 成员，最后运行 Bulk_quote 的构造函数，该函数无须执行实际的初始化或其他工作。

> **关键概念：重构**
>
> 在 Quote 的继承体系中增加 Disc_quote 类是重构的一个典型示例。重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说，重构是一种很普遍的现象。
>
> 值得注意的是，即使我们改变了整个继承体系，那些使用了 Bulk_quote 或 Quote 的代码也无须进行任何改动。不过一旦类被重构（或以其他方式被改变），就意味着我们必须重新编译含有这些类的代码了。

## 15.5 访问控制与继承

每个类分别控制自己的成员初始化过程（参见15.2.2节），与之类似，每个类还分别控制着其成员对于派生类来说是否可访问。

#### 受保护的成员

如前所述，一个类使用 protected 关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。protected 说明符可以看做是 public 和 private 中和后的产物：

- 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。
- 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。此外，protected 还有另外一条重要的性质。
- 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。

为了理解最后一条规则，请考虑如下的例子：

```C++
class Base{
protected:
	int prot_mem;  // protected 成员
};
class Sneaky : public Base {
	friend void clobber(Sneaky&);// 能访问 Sneaky∶∶prot_mem 
	friend void clobber(Base&);  //不能访问Base∶∶prot_mem
	int j; // j默认是private
};
// 正确∶ clobber能访问 Sneaky 对象的 private 和protected 成员
void clobber(Sneaky &s) { s.j = s.prot_mem = 0; }
// 错误∶ clobber不能访问 Base 的 protected 成员
void clobber(Base &b) { b.prot_mem = 0; }
```

如果派生类（及其友元）能访问基类对象的受保护成员，则上面的第二个 clobber（接受一个 Base&）将是合法的。该函数不是 Base 的友元，但是它仍然能够改变一个 Base 对象的内容。如果按照这样的思路，则我们只要定义一个形如 Sneaky 的新类就能非常简单地规避掉 protected 提供的访问保护了。

要想阻止以上的用法，我们就要做出如下规定，即派生类的成员和友元只能访问派生类对象中的基类部分的受保护成；对于普通的基类对象中的成员不具有特殊的访问权限。

#### 公有、私有和受保护继承

某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。举个例子，考虑如下的继承关系：

```C++
class Base {
public:
	void pub_mem ();  // public 成员
protected:
	int prot_mem;  // protected成员
private:
	char priv_mem;  // private成员
};
struct Pub_Derv : public Base {
  // 正确∶ 派生类能访问 protected 成员
  int f() { return prot_mem; }
	// 错误∶private 成员对于派生类来说是不可访问的
  char g() { return priv_mem;}
};
struct Priv_Derv : private Base {
	// private 不影响派生类的访问权限
	int f1() const { return prot_mem; }
};
```

派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。Pub_Derv 和 Priv_Derv 都能访问受保护的成员 prot_mem，同时它们都不能访问私有成员 priv_mem。

派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：

```C++
Pub_Derv dl;  // 继承自 Base的成员是 public的
Priv_Derv d2;  // 继承自 Base的成员是 private的
d1.pub_mem();  // 正确∶ pub_mem在派生类中是 public的
d2.pub_mem();  // 错误∶ pub_mem在派生类中是 private 的
```

Pub_Derv 和 Priv_Derv 都继承了 pub_mem 函数。如果继承是公有的，则成员将遵循其原有的访问说明符，此时 d1 可以调用 pub_mem。在 Priv_Derv 中，Base 的成员是私有的，因此类的用户不能调用 pub_mem。

派生访问说明符还可以控制继承自派生类的新类的访问权限：

```C++
struct Derived_from_Public : public Pub_Derv {
	// 正确∶ Base∶∶prot_mem在 Pub_Derv 中仍然是 protected的
  int use_base() { return prot_mem; }
};
struct Derived_from_Private : public Priv_Derv {
// 错误∶ Base∶∶prot_mem 在Priv_Derv中是 private的
  int use_base() { return prot_mem; }
};
```

Pub_Derv 的派生类之所以能访问 Base 的 prot_mem 成员是因为该成员在 Pub_Derv 中仍然是受保护的。相反，Priv_Derv 的派生类无法执行类的访问，对于它们来说，Priv_Derv 继承自 Base 的所有成员都是私有的。

假设我们之前还定义了一个名为 Prot_Derv 的类，它采用受保护继承，则 Base 的所有公有成员在新定义的类中都是受保护的。Prot_Derv 的用户不能访问 pub_mem，但是 Prot_Derv 的成员和友元可以访问那些继承而来的成员。

#### 派生类向基类转换的可访问性

派生类向基类的转换（参见15.2.2节）是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定 D 继承自 B∶

- 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。
- 不论 D 以什么方式继承 B，D 的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。
- 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 继承 B 的方式是私有的，则不能使用。

> Tip! 对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。

> **关键概念：类的设计与受保护的成员**
>
> 不考虑继承的话，我们可以认为一个类有两种不同的用户：普通用户和类的实现者。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。
>
> 如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。
>
> 和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组；一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。

#### 友元与继承

就像友元关系不能传递一样（参见 7.3.4节），友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员：

```C++
class Base {
	//添加 friend 声明，其他成员与之前的版本一致
	friend class Pal; // Pal在访问 Base 的派生类时不具有特殊性
};
class Pal {
public:
	int f(Base b) { return b.prot_mem; } //正确∶Pal是Base的友元
	//错误∶ Pal不是 Sneaky 的友元
	int f2(Sneaky s) { return s.j; }
	// 对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此
	int f3(Sneaky s) { return s.prot_mem;} // 正确∶Pal是Base的友元
};
```

如前所述，每个类负责控制自己的成员的访问权限，因此尽管看起来有点儿奇怪，但 f3 确实是正确的。Pal 是 Base 的友元，所以 Pal 能够访问 Base 对象的成员，**这种可访问性包括了 Base 对象内嵌在其派生类对象中的情况**。

当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效。对于原来那个类来说，其友元的基类或者派生类不具有特殊的访问能力：

```C++
// D2 对 Base 的 protected和 private 成员不具有特殊的访问能力
class D2 : public Pal {
public:
	int mem(Base b)
  	{ return b.prot_mem;) }  // 错误∶友元关系不能继承
};
```

> Note! 不能继承友元关系；每个类负责控制各自成员的访问权限。

#### 改变个别成员的可访问性

有时我们需要改变派生类继承的某个名字的访问级别，通过使用 using 声明（参见3.1节）可以达到这一目的：

```C++
class Base { 
public:
  std::size_t size() const { return n; }
protected:
	std::size_t n;
};
class Derived : private Base {  // 注意∶private 继承
public:
	// 保持对象尺寸相关的成员的访问级别
  using Base::size;
protected:
	using Base::n;
};
```

因为 Derived 使用了私有继承，所以继承而来的成员 size 和 n（在默认情况下）是 Derived 的私有成员。然而，我们使用 using 声明语句改变了这些成员的可访问性。改变之后，Derived 的用户将可以使用 size 成员，而 Derived 的派生类将能使用 n。

**通过在类的内部使用 using 声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来**。using 声明语句中名字的访问权限由该 using 声明语句之前的访问说明符来决定。也就是说，如果一条 using 声明语句出现在类的 private 部分，则该名字只能被类的成员和友元访问；如果 using 声明语句位于 public 部分，则类的所有用户都能访问它；如果 using 声明语句位于 protected 部分，则该名字对于成员、友元和派生类是可访问的。

> Note! 派生类只能为那些它可以访问的名字提供 using 声明。

#### 默认的继承保护级别

在7.2 节中我们曾经介绍过使用 struct 和 class 关键字定义的类具有不同的默认访问说明符。类似的，默认派生运算符也由定义派生类所用的关键字来决定。默认情况下，使用 class 关键字定义的派生类是私有继承的；而使用 struct 关键字定义的派生类是公有继承的：

```C++
class Base { /*...*/};
struct D1 : Base {/ * ...*/); // 默认 public 继承
class D2 : Base { /* ...*/}; // 默认 private 继承
```

人们常常有一种错觉，认为在使用 struct 关键字和 class 关键字定义的类之间还有更深层次的差别。事实上，唯一的差别就是默认成员访问说明符及默认派生访问说明符；除此之外，再无其他不同之处。

> Note! 一个私有派生的类最好显式地将 private 声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。

## 15.6 继承中的类作用域

每个类定义自己的作用域（参见7.4节），在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套（参见2.2.4 节）在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。

派生类的作用域位于基类作用域之内这一事实可能有点儿出人意料，毕竟在我们的程序文本中派生类和基类的定义是相互分离开来的。不过也恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员。例如，当我们编写下面的代码时：

```C++
Bulk_quote bulk;
cout << bulk.isbn();
```

名字 isbn 的解析将按照下述过程所示：

- 因为我们是通过 Bulk_quote 的对象调用 isbn 的，所以首先在 Bulk_quote 中查找，这一步没有找到名字 isbn。
- 因为 Bulk_quote 是 Disc_quote 的派生类，所以接下来在 Disc_quote 中查找，仍然找不到。
- 因为 Disc_quote 是 Quote 的派生类，所以接着查找 Quote；此时找到了名字 isbn，所以我们使用的 isbn 最终被解析为 Quote 中的 isbn。

#### 在编译时进行名字查找

一个对象、引用或指针的静态类型（参见15.2.3节）决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。举个例子，我们可以给 Disc_quote 添加一个新成员，该成员返回一个存有最小（或最大）数量及折扣价格的 pair（参见11.2.3节）：

```C++
class Disc_quote : public Quote {
public:
	std::pair<size_t,double> discount_policy() const
	{ return {quantity,discount};}
  // 其他成员与之前的版本一致一
};
```

我们只能通过 Disc_quote 及其派生类的对象、引用或指针使用 discount_policy：

```C++
Bulk_quote bulk;
Bulk_quote *bulkP = &bulk; // 静态类型与动态类型一致
Quote *itemP = &bulk;  // 静态类型与动态类型不一致
bulkP->discount_policy(); // 正确：bulkP的类型是 Bulk_quote*
itemP->discount_policy(); // 错误：itemP的类型是 Quote*
```

尽管在 bulk 中确实含有一个名为 discount_policy 的成员，但是该成员对于itemP 却是不可见的。itemP的类型是 Quote 的指针，意味着对 discount_policy 的搜索将从 Quote 开始。显然 Quote 不包含名为 discount_policy 的成员，所以我们无法通过 Quote 的对象、引用或指针调用 discount_policy。

#### 名字冲突与继承

和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字（参见2.2.4 节）：

```C++
struct Base {
	Base() : mem(0) {}
protected:
	int mem;
};
struct Derived : Base {
	Derived(int i) : mem(i) {} // 用i初始化 Derived::mem
  													 // Base::mem 进行默认初始化
	int get_mem() { return mem;} // 返回 Derived::mem
protected:
	int mem; // 隐藏基类中的 mem
};
```

get_mem 中 mem 引用的解析结果是定义在 Derived 中的名字，下面的代码

```C++
Derived d(42);
cout << d.get_mem()<< endl; // 打印42
```

的输出结果将是42。

> Note! 派生类的成员将隐藏同名的基类成员

#### 通过作用域运算符来使用隐藏的成员

我们可以通过作用域运算符来使用一个被隐藏的基类成员：

```C++
struct Derived : Base {
	int get_base_mem(){ return Base::mem;}	// ... 
};
```

作用域运算符将覆盖掉原有的查找规则，并指示编译器从 Base 类的作用域开始查找 mem。如果使用最新的 Derived 版本运行上面的代码，则 d.get_mem() 的输出结果将是0。

> Note! 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。

> **关键概念：名字查找与继承**
>
> 理解函数调用的解析过程对于理解 C++ 的继承至关重要，假定我们调用 p->mem() （或者 obj.mem() ），则依次执行以下4个步骤：
>
> - 首先确定p（或 obj ）的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。
> -  在 p（或 obj ）的静态类型对应的类中查找 mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。
> - 一旦找到了 mem，就进行常规的类型检查（参见6.1节）以确认对于当前找到的 mem，本次调用是否合法。
> -  假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：
>   - 如果 mem 是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。
>   - 反之，如果 mem 不是虚函数或者我们是通过对象（而非引用或指针）进行的调用，则编译器将产生一个常规函数调用。

#### 一如往常，名字查找先于类型检查

如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数（参见6.4.1 节）。因此，定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉：

```C++
struct Base {
  int memfcn();
};
struct Derived : Base {
  int memfcn(int);  // 隐藏基类的memfcn 
};
Derived d; Base b;
b.memfcn();  //调用 Base∶∶memfcn 
d.memfcn(10);  //调用 Derived∶∶memfcn
d.memfcn();  //错误∶参数列表为空的memfcn被隐藏了
d.Base::memfcn();  // 正确∶调用 Base∶∶memfcn
```

Derived 中的 memfcn 声明隐藏了Base 中的 memfcn 声明。在上面的代码中前两条调用语句容易理解，第一个通过 Base 对象 b 进行的调用执行基类的版本;类似的，第二个通过 d 进行的调用执行 Derived 的版本;第三条调用语句有点特殊，d.memfcn() 是非法的。

为了解析这条调用语句，编译器首先在 Derived 中查找名字 memfcn；因为 Derived 确实定义了一个名为 memfcn 的成员，所以查找过程终止。一旦名字找到，编译器就不再继续查找了。Derived 中的 memfcn 版本需要一个 int 实参，而当前的调用语句无法提供任何实参，所以该调用语句是错误的。

#### 虚函数与作用域

我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了（参见15.3 节）。假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。例如：

```C++
class Base {
public:
	virtual int fcn();
};
class D1 : public Base {
public:
	//隐藏基类的 fcn，这个fcn 不是虚函数
  // D1 继承了 Base∶∶fcn() 的定义
	int fcn(int);  //形参列表与Base 中的fcn 不一致
  virtual void f2();  //是一个新的虚函数，在 Base中不存在
};
class D2 : public D1 {
public:
	int fcn(int);  // 是一个非虚函数，隐藏了D1∶∶fcn(int)
  int fcn();  // 覆盖了Base 的虚函数fcn 
  void f2();  //覆盖了D1的虚函数 f2
};
```

D1 的 fcn 函数并没有覆盖 Base 的虚函数 fcn，原因是它们的形参列表不同。实际上，D1 的 fcn 将隐藏 Base 的 fcn。此时拥有了两个名为 fcn 的函数：一个是 D1 从 Base 继承而来的虚函数 fcn；另一个是 D1 自己定义的接受一个 int 参数的非虚函数 fcn。

#### 通过基类调用隐藏的虚函数

给定上面定义的这些类后，我们来看几种使用其函数的方法：

```C++
Base bobj; D1 d1obj; D2 d2obj;
Base *bpl = &bobj, *bp2 = &dlobj, *bp3 = &d2obj;
bpl->fcn();  // 虚调用，将在运行时调用 Base∶∶fcn
bp2->fcn();  // 虚调用，将在运行时调用 Base∶∶fcn
bp3->fcn();  // 虚调用，将在运行时调用 D2∶∶fcn
D1 *d1p = &dlobj; D2 *d2p = &d2obj;
bp2->f2();  //错误∶Base 没有名为 f2的成员
d1p->f2();  // 虚调用，将在运行时调用 D1∶∶f2（）
d2p->f2();  // 虚调用，将在运行时调用 D2∶∶f2（）
```

前三条调用语句是通过基类的指针进行的，因为 fcn 是虚函数，所以编译器产生的代码将在运行时确定使用虚函数的哪个版本。判断的依据是该指针所绑定对象的真实类型。在 bp2 的例子中，实际绑定的对象是 D1 类型，而 D1 并没有覆盖那个不接受实参的 fcn，所以通过 bp2 进行的调用将在运行时解析为 Base 定义的版本。

接下来的三条调用语句是通过不同类型的指针进行的，每个指针分别指向继承体系中的一个类型。因为 Base 类中没有 f2() ，所以第一条语句是非法的，即使当前的指针碰巧指向了一个派生类对象也无济于事。

为了完整地阐明上述问题，我们不妨再观察一些对于非虚函数 fcn(int) 的调用语句：

```C++
Base *p1 = &d2obj; D1 *p2 = &d2obj; D2 *p3 = &d2obj;
pl->fcn(42);  // 错误∶ Base中没有接受一个int 的fcn
p2->fcn(42);  // 静态绑定，调用 D1∶∶fcn（int）
p3->fcn(42);  //静态绑定，调用 D2∶∶fcn（int）
```

在上面的每条调用语句中，指针都指向了 D2 类型的对象，但是由于我们调用的是非虚函数，所以不会发生动态绑定。实际调用的函数版本由指针的静态类型决定。

#### 覆盖重载的函数

和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。

有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，显然操作将极其烦琐。

一种好的解决方案是为重载的成员提供一条 using 声明语句（参见 15.5节），这样我们就无须覆盖基类中的每一个重载版本了。using 声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的 using 声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义。

类内 using 声明的一般规则同样适用于重载函数的名字（参见15.5 节）；基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的访问实际上是对 using 声明点的访问。

## 15.7 构造函数与拷贝控制

和其他类一样，位于继承体系中的类也需要控制当其对象执行一系列操作时发生什么样的行为，这些操作包括创建、拷贝、移动、赋值和销毁。如果一个类（基类或派生类）没有定义拷贝控制操作，则编译器将为它合成一个版本。当然，这个合成的版本也可以定义成被删除的函数。

### 15.7.1 虚析构函数

继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数（参见15.2.1节），这样我们就能动态分配继承体系中的对象了。

如前所述，当我们 delete 一个动态分配的对象的指针时将执行析构函数（参见13.1.3 节）。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况（参见15.2.2节）。例如，如果我们 delete 一个 Quote* 类型的指针，则该指针有可能实际指向了一个 Bulk_quote  类型的对象。如果这样的话，编译器就必须清楚它应该执行的是 Bulk_quote 的析构函数。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本：

```C++
class Quote{
public:
	// 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数
  virtual ～Quote()= default;  // 动态绑定析构函数
};
```

和其他虚函数一样，析构函数的虚属性也会被继承。因此，无论 Quote 的派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。只要基类的析构函数是虚函数，就能确保当我们 delete 基类指针时将运行正确的析构函数版本：

```C++
Quote *itemP = new Quote;  //静态类型与动态类型一致
delete itemP;  // 调用Quote的析构函数
itemP = new Bulk_quote;  //静态类型与动态类型不一致
delete itemP;  // 调用 Bulk_quote的析构函数
```

> Note! 如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类指针将产生未定义的行为。

之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作（参见 13.1.4 节）。**基类的析构函数并不遵循上述准则，它是一个重要的例外**。一个基类总是需要析构函数，而目它能将析构函数设定为虚函数。此时，该析构函数为了成为虚函数而令内容为空，我们显然无法由此推断该基类还需要赋值运算符或拷贝构造函数。

#### 虚析构函数将阻止合成移动操作

基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析构函数，即使它通过 =default 的形式使用了合成的版本，编译器也不会为这个类合成移动操作（参见13.6.2节）。

### 15.7.2 合成拷贝控制与继承

基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。例如，

- 合成的 Bulk_quote 默认构造函数运行 Disc_quote 的默认构造函数，后者又运行 Quote 的默认构造函数。
-  Quote 的默认构造函数将 bookNo 成员默认初始化为空字符串，同时使用类内初始值将 price 初始化为0。
-  Quote 的构造函数完成后，继续执行 Disc_quote 的构造函数，它使用类内初始值初始化 qty 和 discount。
- Disc_quote 的构造函数完成后，继续执行 Bulk_quote 的构造函数，但是它什么具体工作也不做。

类似的，合成的 Bulk_quote 拷贝构造函数使用（合成的）Disc_quote 拷贝构造函数，后者又使用（合成的）Quote 拷贝构造函数。其中，Quote 拷贝构造函数拷贝 bookNo 和 price 成员；Disc_quote 拷贝构造函数拷贝 qty 和 discount 成员。

值得注意的是，无论基类成员是合成的版本（如 Quote 继承体系的例子）还是自定义的版本都没有太大影响。唯一的要求是相应的成员应该可访问（参见 15.5 节）并且不是一个被删除的函数。

在我们的 Quote 继承体系中，所有类都使用合成的析构函数。其中，派生类隐式地使用而基类通过将其虚析构函数定义成 =default 而显式地使用。一如既往，合成的析构函数体是空的，其隐式的析构部分负责销毁类的成员（参见 13.1.3 节）。对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。

如前所述，Quote 因为定义了析构函数而不能拥有合成的移动操作，因此当我们移动 Quote 对象时实际使用的是合成的拷贝操作（参见13.6.2节）。如我们即将看到的那样，Quote 没有移动操作意味着它的派生类也没有。

#### 派生类中删除的拷贝控制与基类的关系

就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数（参见 13.1.6 节和13.6.2 节）。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数：

- 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问（参见15.5 节），则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。
-  如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。
-  和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=default 请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。

举个例子，对于下面的基类 B 来说：

```C++
class B {
public:
	B();
  B(const B&) = delete; 
  //其他成员，不含有移动构造函数
};
class D : public B {
  // 没有声明任何构造函数
};
D d;  // 正确∶D的合成默认构造函数使用 B 的默认构造函数
D d2(d);  //错误∶D的合成拷贝构造函数是被删除的
D d3(std∶∶move(d)); // 错误∶隐式地使用 D 的被删除的拷贝构造函数
```

基类 B 含有一个可访问的默认构造函数和一个显式删除的拷贝构造函数。因为我们定义了拷贝构造函数，所以编译器将不会为B合成一个移动构造函数（参见，13.6.2节），因此，我们既不能移动也不能拷贝 B 的对象。如果 B 的派生类希望它自己的对象能被移动和拷贝，则派生类需要自定义相应版本的构造函数。当然，在这一过程中派生类还必须考虑如何移动或拷贝其基类部分的成员。在实际编程过程中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。

#### 移动操作与继承

如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。

因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的 Quote 可以使用合成的版本，不过前提是 Quote 必须显式地定义这些成员。一旦 Quote 定义了自己的移动操作，那么它必须同时显式地定义拷贝操作（参见13.6.2节）：

```C++
class Quote {
public:
	Quote() = default;  //对成员依次进行默认初始化// 对成员依次拷贝
	Quote(const Quote&) = default; // 对成员依次拷贝
	Quote(Quote&&) = default;  // 对成员依次拷贝
	Quote& operator=(const Quote&) = default;// 拷贝赋值
	Quote& operator=(Quote&&) = default;  // 移动赋值
  virtual ～Quote() = default;  //其他成员与之前的版本一致
};
```

通过上面的定义，我们就能对 Quote 的对象逐成员地分别进行拷贝、移动、赋值和销毁操作了。而且除非 Quote 的派生类中含有排斥移动的成员，否则它将自动获得合成的移动操作。

### 15.7.3 派生类的拷贝控制成员

如我们在15.2.2节介绍过的，派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。

和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。如前所述，对象的成员是被隐式销毁的（参见 13.1.3 节）;类似的，派生类对象的基类部分也是自动销毁的。

> Note! 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员。

#### 定义派生类的拷贝或移动构造函数

当为派生类定义拷贝或移动构造函数时（参见13.1.1 节和13.6.2节），我们通常使用对应的基类构造函数初始化对象的基类部分：

```C++
class Base {/* ...*/ };
class D : public Base {
public:
	//默认情况下，基类的默认构造函数初始化对象的基类部分
	// 要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中
  // 显式地调用该构造函数
  D(const D& d): Base(d)   // 拷贝基类成员
	/* D的成员的初始值*/ {/* ...*/}
	// 移动基类成员
	D(D&& d): Base(std::move(d))
	/* D 的成员的初始值 */ {/* ...*/ }
);
```

初始值 Base(d) 将一个 D 对象传递给基类构造函数。尽管从道理上来说，Base 可以包含一个参数类型为 D 的构造函数，但是在实际编程过程中通常不会这么做。相反，Base(d) 一般会匹配 Base 的拷贝构造函数。D 类型的对象 d 将被绑定到该构造函数的 Base& 形参上。Base 的拷贝构造函数负责将 d 的基类部分拷贝给要创建的对象。假如我们没有提供基类的初始值的话：

```C++
// D的这个拷贝构造函数很可能是不正确的定义
// 基类部分被默认初始化，而非拷贝
D(const D& d) /* 成员初始值，但是没有提供基类初始值*/
{ /*...*/ }
```

在上面的例子中，Base 的默认构造函数将被用来初始化 D 对象的基类部分。假定 D 的构造函数从 d 中拷贝了派生类成员，则这个新构建的对象的配置将非常奇怪：它的 Base 成员被赋予了默认值，而 D 成员的值则是从其他对象拷贝得来的。

> WARNING! 在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。

#### 派生类赋值运算符

与拷贝和移动构造函数一样，派生类的赋值运算符（参见13.1.2节和13.6.2 节）也必须显式地为其基类部分赋值：

```C++
// Base∶∶operator=（const Base&）不会被自动调用
D &D::operator=(const D &rhs) {
  Base∶∶operator=(rhs);  // 为基类部分赋值
	//按照过去的方式为派生类的成员赋值
  // 酌情处理自赋值及释放已有资源等情况
  return *this;
};
```

上面的运算符首先显式地调用基类赋值运算符，令其为派生类对象的基类部分赋值。基类的运算符（应该可以）正确地处理自赋值的情况，如果赋值命令是正确的，则基类运算符将释放掉其左侧运算对象的基类部分的旧值，然后利用 rhs 为其赋一个新值。随后，我们继续进行其他为派生类成员赋值的工作。

值得注意的是，无论基类的构造函数或赋值运算符是自定义的版本还是合成的版本，派生类的对应操作都能使用它们。例如，对于 Base∶∶operator= 的调用语句将执行 Base 的拷贝赋值运算符，至于该运算符是由 Base 显式定义的还是由编译器合成的无关紧要。

#### 派生类析构函数

如前所述，在析构函数体执行完成后，对象的成员会被隐式销毁（参见 13.1.3节）。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：

```C++
class D : public Base {
public:
	// Base∶∶~Base 被自动调用执行
	~D() { /* 该处由用户定义清除派生类成员的操作 */}
};
```

对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。

#### 在构造函数和析构函数中调用虚函数

如我们所知，派生类对象的基类部分将首先被构建。当执行基类的构造函数时，该对象的派生类部分是未被初始化的状态。类似的，销毁派生类对象的次序正好相反，因此当执行基类的析构函数时，派生类部分已经被销毁掉了。由此可知，当我们执行上述基类成员的时候，该对象处于未完成的状态。

为了能够正确地处理这种未完成状态，编译器认为对象的类型在构造或析构的过程中仿佛发生了改变一样。也就是说，当我们构建一个对象时，需要把对象的类和构造函数的类看作是同一个；对虚函数的调用绑定正好符合这种把对象的类和构造函数的类看成同一个的要求；对于析构函数也是同样的道理。上述的绑定不但对直接调用虚函数有效，对间接调用也是有效的，这里的间接调用是指通过构造函数（或析构函数）调用另一个函数。

为了理解上述行为，不妨考虑当基类构造函数调用虚函数的派生类版本时会发生什么情况。这个虚函数可能会访问派生类的成员，毕章，如果它不需要访问派生类成员的话，则派生类直接使用基类的虚函数版本就可以了。然而，当执行基类构造函数时，它要用到的派生类成员尚未初始化，如果我们允许这样的访问，则程序很可能会崩溃。

> Note! 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。

### 15.7.4 继承的构造函数

在C++11新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为"继承"的。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。

派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的 using 声明语句。举个例子，我们可以重新定义 Bulk_quote 类（参见15.4节），令其继承Disc_quote 类的构造函数：

```C++
class Bulk_quote : public Disc_quote {
public:
	using Disc_quote∶∶Disc_quote;  // 继承Disc_quote的构造函数
  double net_price(std::size_t) const;
};
```

通常情况下，using 声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using 声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。

这些编译器生成的构造函数形如：

```C++
derived(parms) : base(args) {}
```

其中，derived 是派生类的名字，base 是基类的名字，parms 是构造函数的形参列表，args 将派生类构造函数的形参传递给基类的构造函数。在我们的 Bulk_quote 类中，继承的构造函数等价于：

```C++
Bulk_quote(const std::string& book, double price, std::size_t qty, double disc):
Disc_quote(book,price,qty,disc) {}
```

如果派生类含有自己的数据成员，则这些成员将被默认初始化（参见7.1.4 节）。

#### 继承的构造函数的特点

和普通成员的 using 声明不一样，一个构造函数的 using 声明不会改变该构造函数的访问级别。例如，不管 using 声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。

而且，一个 using 声明语句不能指定 explicit 或 constexpr。如果基类的构造函数是 explicit（参见7.5.4节）或者constexpr（参见7.5.6节），则继承的构造函数也拥有相同的属性。

当一个基类构造函数含有默认实参（参见6.5.1 节）时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（没有默认实参），另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。

如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这些构造函数。第一个例外是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。

第二个例外是默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。

## 15.8 容器与继承

当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。

举个例子，假定我们想定义一个 vector，令其保存用户准备购买的几种书籍。显然我们不应该用 vector 保存 Bulk_quote 对象。因为我们不能将 Quote 对象转换成 Bulk_quote（参见15.2.3 节），所以我们将无法把 Quote 对象放置在该vector 中。

其实，我们也不应该使用 vector 保存 Quote 对象。此时，虽然我们可以把 Bulk_quote 对象放置在容器中，但是这些对象再也不是 Bulk_quote 对象了：

```C++
vector<Quote> basket;
basket.push_back(Quote("0-201-82470-1",50));
// 正确∶但是只能把对象的 Quote 部分拷贝给basket
basket.push_back(Bulk_quote("0-201-54848-8",50,10,.25));
// 调用 Quote定义的版本，打印750，即15 * $50 
cout << basket.back().net_price(15) << endl;

```

basket 的元素是 Quote 对象，因此当我们向该 vector 中添加一个 Bulk_quote对象时，它的派生类部分将被忽略掉（参见15.2.3节）。

> Note! 当派生类对象被赋值给基类对象时，其中的派生类部分将被"切掉"，因此容器和存在继承关系的类型无法兼容。

#### 在容器中放置（智能）指针而非对象

当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针（参见12.1 节））。和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型：

```C++
vector<shared_ptr<Quote>> basket;
basket.push_back(make_shared<Quote>("0-201-82470-1",50));
basket.push_back(
	make_shared<Bulk_quote>("0-201-54848-8",50,10,.25));
	// 调用 Quote定义的版本;打印562.5，即在 15*&50中扣除掉折扣金额
cout << basket.back()->net_price(15) << endl;
```

因为 basket 存放着 shared_ptr，所以我们必须解引用 basket.back() 的返回值以获得运行 net_price 的对象。我们通过在 net_price 的调用中使用 -> 以达到这个目的。如我们所知，实际调用的 net_price 版本依赖于指针所指对象的动态类型。

值得注意的是，我们将 basket 定义成 shared_prt<Quote>，但是在第二个push_back 中传入的是一个 Bulk_quote 对象的 shared_ptr。正如我们可以将一个派生类的普通指针转换成基类指针一样（参见 15.2.2节，第 530 页），我们也能把一个派生类的智能指针转换成基类的智能指针。在此例中，make_shared<Bulk_quote> 返回一个 shared_ptr<Bulk_quote> 对象，当我们调用 push_back 时该对象被转换成shared_ptr<Quote>。因此尽管在形式上有所差别，但实际上 basket 的所有元素的类型都是相同的。

### 15.8.1 编写 Basket 类

对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以我们经常定义一些辅助的类来处理这种复杂情况。首先，我们定义一个表示购物篮的类：

```C++
class Basket { 
public:
	// Basket 使用合成的默认构造函数和拷贝控制成员
	void add_item(const std::shared_ptr<Quote> &sale)
		{ items.insert(sale);}
	// 打印每本书的总价和购物篮中所有书的总价
	double total_receipt(std::ostream&) const;
private:
	// 该函数用于比较 shared_ptr，multiset 成员会用到它
	static bool compare(const std::shared_ptr<Quote> &lhs,
											const std::shared_ptr<Quote> &rhs)
		{return lhs->isbn() < rhs->isbn(); }
  // multiset 保存多个报价，按照 compare 成员排序
  std::multiset<std::shared_ptr<Quote>, decltype(compare)*>
					items{compare};
};
```

我们的类使用一个 multiset（参见11.2.1节）来存放交易信息，这样我们就能保存同一本书的多条交易记录，而且对于一本给定的书籍，它的所有交易信息都保存在一起（参见11.2.2节）。

multiset 的元素是 shared_ptr。因为 shared_ptr 没有定义小于运算符，所以为了对元素排序我们必须提供自已的比较运算符（参见11.2.2节）。在此例中，我们定义了一个名为 compare 的私有静态成员，该成员负责比较 shared_ptr 所指的对象的 isbn。我们初始化 multiset，通过类内初始值调用比较函数（参见7.3.1节）：

```C++
// multiset 保存多个报价，按照 compare 成员排序
std::multiset<std::shared_ptr<Quote>,decltype(compare)*>
	items{compare};
```

这个声明看起来不太容易理解，但是从左向右读的话，我们就能明白它其实是定义了一个指向 Quote 对象的 shared_ptr 的 multiset。这个 multiset 将使用一个与 compare 成员类型相同的函数来对其中的元素进行排序。multiset 成员的名字是 items，我们初始化 items 并令其使用我们的 compare 函数。

#### 定义 Basket 的成员

Basket 类只定义两个操作。第一个成员是我们在类的内部定义的 add_item 成员，该成员接受一个指向动态分配的 Quote 的 shared_ptr，然后将这个 shared_ptr 放置在 multiset 中。第二个成员的名字是 total_receipt，它负责将购物篮的内容逐项打印成清单，然后返回购物篮中所有物品的总价格：

```C++
double Basket::total_receipt(ostream &os) const
{
	double sum = 0.0;   //保存实时计算出的总价格	
	// iter 指向 ISBN 相同的一批元素中的第一个
	// upper_bound 返回一个迭代器，该迭代器指向这批元素的尾后位置
  for (auto iter = items.cbegin();
			 			iter != items.cend();
						iter = items.upper_bound(*iter)){
	//我们知道在当前的 Basket中至少有一个该关键字的元素
  // 打印该书籍对应的项目
		sum += print_total(os,**iter,items.count(*iter));
  }
	os << "Total Sale∶ " << sum << endl;// 打印最终的总价格
  return Sum;
}
```

我们的 for循环首先定义并初始化 iter，令其指向 multiset 的第一个元素。条件部分检查 iter 是否等于 items.cend()：如果相等，表明我们已经处理完了所有购买记录，接下来应该跳出 for 循环；否则，如果不相等，则继续处理下一本书籍。

比较有趣的是，for 循环中的"递增"表达式。与通常的循环语句依次读取每个元素不同，我们直接令 iter 指向下一个关键字，调用 upper_bound 函数可以令我们跳过与当前关键字相同的所有元素（参见11.3.5节）。对于 upper_bound 函数来说，它返回的是一个迭代器，该迭代器指向所有与 iter 关键字相等的元素中最后一个元素的下一位置。因此，我们得到的迭代器或者指向集合的末尾，或者指向下一本书籍。

在 for 循环内部，我们通过调用 print_total（参见15.1节）来打印购物篮中每本书籍的细节：

```C++
sum += print_total(os, **iter, items.count(*iter));
```

print_total 的实参包括一个用于写入数据的 ostream、一个待处理的 Quote 对象和一个计数值。当我们解引用 iter 后将得到一个指向准备打印的对象的 shared_ptr。为了得到这个对象，必须解引用该 shared_ptr。因此，**iter是一个 Quote 对象（或者 Quote 的派生类的对象）。我们使用 multiset 的 count 成员（参见11.3.5节）来统计在 multiset 中有多少元素的键值相同（即 ISBN 相同）。

如我们所知，print_total 调用了虚函数 net_price，因此最终的计算结果依赖于**iter 的动态类型。print_total 函数打印并返回给定书籍的总价格，我们把这个结果添加到 sum 当中，最后当循环结束后打印 sum。

#### 隐藏指针

Basket 的用户仍然必须处理动态内存，原因是 add_item 需要接受一个 shared_ptr 参数。因此，用户不得不按照如下形式编写代码：

```C++
Basket bsk;
bsk.add_item(make_shared<Quote>("123",45));
bsk.add_item(make_shared<Bulk_quote>("345",45,3,.15));
```

我们的下一步是重新定义 add_item，使得它接受一个 Quote 对象而非 shared_ptr。新版本的 add_item将负责处理内存分配，这样它的用户就不必再受困于此了。我们将定义两个版本，一个拷贝它给定的对象，另一个则采取移动操作（参见13.6.3节）：

```C++
void add_item(const Quote& sale);  // 拷贝给定的对象
void add_item(Quote&& sale);  //移动给定的对象
```

唯一的问题是 add_item 不知道要分配的类型。当 add_item 进行内存分配时，它将拷贝（或移动）它的 sale 参数。在某处可能会有一条如下形式的 new 表达式：

```C++
new Quote(sale)
```

不幸的是，这条表达式所做的工作可能是不正确的：new 为我们请求的类型分配内存，因此这条表达式将分配一个 Quote 类型的对象并且拷贝 sale 的 Quote 部分。然而，sale 实际指向的可能是 Bulk_quote 对象，此时，该对象将被迫切掉一部分。

#### 模拟虚拷贝

为了解决上述问题，我们给 Quote 类添加一个虚函数，该函数将申请一份当前对象的拷贝。

```C++
class Quote {
public:
	// 该虚函数返回当前对象的一份动态分配的拷贝
	// 这些成员使用的引用限定符参见 13.6.3节
	virtual Quote* clone() const & {return new Quote(*this);}
  virtual Quote* clone() &&
	{return new Quote(std::move(*this));}
	//其他成员与之前的版本一致
};
```

```C++
class Bulk_quote : public Quote {
	Bulk_quote* clone() const &{return new Bulk_quote(*this);}
  Bulk_quote* clone() &&
	{return new Bulk_quote(std::move(*this));}
// 其他成员与之前的版本一致
};
```

因为我们拥有 add_item 的拷贝和移动版本，所以我们分别定义 clone 的左值和右值版本（参见13.6.3节）。每个clone 函数分配当前类型的一个新对象，其中，const 左值引用成员将它自己拷贝给新分配的对象;右值引用成员则将自己移动到新数据中。

我们可以使用 clone 很容易地写出新版本的 add_item：

```C++
class Basket{
public:
	// 拷贝给定的对象
	void add_item (const Quote& sale)
	{ items.insert(std::shared_ptr<Quote>(sale.clone()));}
	// 移动给定的对象
	void add_item(Quote&& sale)
	{ items.insert(
    std::shared_ptr<Quote(std::move(sale).clone())); }
  // 其他成员与之前的版本一致
};
```

和 add_item 本身一样，clone 函数也根据作用于左值还是右值而分为不同的重载版本。在此例中，第一个 add_item 函数调用 clone 的 const 左值版本，第二个函数调用 clone 的右值引用版本。在右值版本中，尽管 sale 的类型是右值引用类型，但实际上 sale 本身（和任何其他变量一样）是个左值（参见13.6.1节）。因此，我们调用 move 把一个右值引用绑定到 sale 上。

我们的 clone 函数也是一个虚函数。sale 的动态类型（通常）决定了到底运行Quote 的函数还是 Bulk_quote 的函数。无论我们是拷贝还是移动数据，clone 都返回一个新分配对象的指针，该对象与 clone 所属的类型一致。我们把一个 shared_ptr 绑定到这个对象上，然后调用 insert 将这个新分配的对象添加到 items 中。注意，因为 shared_ptr 支持派生类向基类的类型转换（参见 15.2.2节），所以我们能把 shared_ptr<Quote> 绑定到 Bulk_quote* 上。

# 第 16 章 模板与泛型编程

面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。

本书第ⅡI部分中介绍的容器、迭代器和算法都是泛型编程的例子。当我们编写一个泛型程序时，是独立于任何特定类型来编写代码的。当使用一个泛型程序时，我们提供类型或值，程序实例可在其上运行。

例如，标准库为每个容器提供了单一的、泛型的定义，如 vector。我们可以使用这个泛型定义来定义很多类型的 vector，它们的差异就在于包含的元素类型不同。

模板是C++中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。当使用一个vector这样的泛型类型，或者 find 这样的泛型函数时，我们提供足够的信息，将蓝图转换为特定的类或函数。这种转换发生在编译时。

## 16.1 定义模板

假定我们希望编写一个函数来比较两个值，并指出第一个值是小于、等于还是大于第二个值。在实际中，我们可能想要定义多个函数，每个函数比较一种给定类型的值。我们的初次尝试可能定义多个重载函数。

如果对每种希望比较的类型都不得不重复定义完全一样的函数体，是非常烦琐且容易出错的。更麻烦的是，在编写程序的时候，我们就要确定可能要 compare 的所有类型。如果希望能在用户提供的类型上使用此函数，这种策略就失效了。

### 16.1.1 函数模板

我们可以定义一个通用的函数模板（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare 的模板版本可能像下面这样：

```C++
template <typename T>
int compare(const T &v1, const T &v2)
{
  if(v1 < v2) return-1;
  if(v2 < v1) return 1;
  return 0;
}
```

模板定义以关键字 template 开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表，用小于号（<）和大于号（>）包围起来。

> Note! 在模板定义中，模板参数列表不能为空。

模板参数列表的作用很像函数参数列表。函数参数列表定义了若干特定类型的局部变量，但并未指出如何初始化它们。在运行时，调用者提供实参来初始化形参。

类似的，模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定模板实参，将其绑定到模板参数上。

我们的 compare 函数声明了一个名为 T 的类型参数。在 compare 中，我们用名字 T 表示一个类型。而 T 表示的实际类型则在编译时根据 compare 的使用情况来确定。

#### 实例化函数模板

当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，当我们调用 compare 时，编译器使用实参的类型来确定绑定到模板参数 T 的类型。例如，在下面的调用中：

```C++
cout << compare(1, 0) << endl; // T为int
```

实参类型是 int。编译器会推断出模板实参为 int，并将它绑定到模板参数 T。

编译器用推断出的模板参数来为我们实例化一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新"实例"。例如，给定下面的调用：

```C++
// 实例化出 int compare(const int&，const int&)
cout << compare (1, 0) << endl; // T为int
// 实例化出 int compare(const vector<int>&，const vector<int>&)
vector<int> vecl{1,2,3}, vec2{4,5,6};
cout << compare(vecl, vec2) << endl; // T为 vector<int>
```

编译器会实例化出两个不同版本的 compare。对于第一个调用，编译器会编写并编译一个 compare 版本，其中 T 被替换为 int：

```C++
int compare(const int &vl, const int &v2)
{
  if (v1 < v2) return -1;
  if (v2 < vl) return 1;
  return 0;
}
```

对于第二个调用，编译器会生成另一个 compare 版本，其中 T 被替换为 vector<int>。这些编译器生成的版本通常被称为模板的实例。

#### 模板类型参数

我们的 compare 函数有一个模板类型参数。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，**类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换**：

```C++
// 正确∶返回类型和参数类型相同
template <typename T> T foo (T* p)
{
	T tmp = *p; // tmp 的类型将是指针p指向的类型
  //... 
  return tmp;
}
```

类型参数前必须使用关键字 class 或 typename：

```C++
// 错误∶U之前必须加上 class 或 typename
template <typename T, U> T calc(const T&,const U&);
```

在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以同时使用这两个关键字：

```C++
// 正确∶在模板参数列表中，typename 和class 没有什么不同
template <typename T, class U> calc (const T&,const U&);
```

看起来用关键字 typename 来指定模板类型参数比用 class 更为直观。毕竟，我们可以用内置（非类）类型作为模板类型实参。而且，typename 更清楚地指出随后的名字是一个类型名。但是，typename 是在模板已经广泛使用之后才引入C++ 语言的，某些程序员仍然只用 class。

#### 非类型模板参数

除了定义类型参数，还可以在模板中定义非类型参数。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数。

当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式（参见 2.4.4 节），从而允许编译器在编译时实例化模板。

例如，我们可以编写一个 compare 版本处理字符串字面常量。这种字面常量是 const char 的数组。由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用（参见6.2.4节）。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数组的长度：

```C++
template<unsigned N, unsigned M>
int compare(const char(&pl)[N], const char(&p2)[M])
{
  return strcmp(p1, p2);
}
```

当我们调用这个版本的 compare 时：

```C++
compare("hi","mom");
```

编译器会使用字面常量的大小来代替 N 和 M，从而实例化模板。记住，编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符（参见 2.1.3 节），因此编译器会实例化出如下版本：

```C++
int compare (const char (&pl)[3], const char(&p2)[4]);
```

一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期（参见第 12 章）。我们不能用一个普通（非static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用 nullptr 或一个值为 0 的常量表达式来实例化。

在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如，指定数组大小。

> Note! 非类型模板参数的模板实参必须是常量表达式。

#### inline 和 constexpr 的函数模板

函数模板可以声明为 inline 或 constexpr 的，如同非模板函数一样。inline 或constexpr 说明符放在模板参数列表之后，返回类型之前：

```C++
// 正确∶inline说明符跟在模板参数列表之后
template <typename T> inline T min(const T&, const T&); 
// 错误∶ inline说明符的位置不正确
inline template <typename T> T min(const T&, const T&);
```

#### 编写类型无关的代码

我们最初的 compare 函数虽然简单，但它说明了编写泛型代码的两个重要原则：

-  模板中的函数参数是 const 的引用。
- 函数体中的条件判断仅使用 < 比较运算。

通过将函数参数设定为 const 的引用，我们保证了函数可以用于不能拷贝的类型。大多数类型，包括内置类型和我们已经用过的标准库类型（除 unigue_ptr 和 IO 类型之外），都是允许拷贝的。但是，不允许拷贝的类类型也是存在的。通过将参数设定为 const 的引用，保证了这些类型可以用我们的 compare 函数来处理。而且，如果 compare 用于处理大对象，这种设计策略还能使函数运行得更快。

你可能认为既使用 < 运算符又使用 > 运算符来进行比较操作会更为自然：

```C++
// 期望的比较操作
if (v1 < v2) return -1;
if (v1 > v2) return 1;
return 0;
```

但是，如果编写代码时只使用 < 运算符，我们就降低了 compare 函数对要处理的类型的要求。这些类型必须支持 <，但不必同时支持 >。

实际上，如果我们真的关心类型无关和可移植性，可能需要用 less（参见14.8.2 节）来定义我们的函数：

```C++
// 即使用于指针也正确的 compare 版本; 参见14.8.2节
template <typename T> int compare(const T &vl, const T &v2)
{
  if(less<T>()(vl,v2)) return -1;
  if(less<T>()(v2,vl)) return 1;
  return 0;
}
```

原始版本存在的问题是，如果用户调用它比较两个指针，且两个指针未指向相同的数组，则代码的行为是未定义的（据查阅资料，less<T> 的默认实现用的就是<，所以这其实并未起到让这种比较有一个良好定义的作用——译者注）。

> Note! 模板程序应该尽量减少对实参类型的要求。

#### 模板编译

当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及错误何时被检测到。

通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。

模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。

> Note! 函数模板和类模板成员函数的定义通常放在头文件中。

> **关键概念：模板和头文件**
>
> 模板包含两种名字：
>
> - 那些不依赖于模板参数的名字
> - 那些依赖于模板参数的名字
>
> 当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者来保证的。而且，模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须是可见的。
>
> 用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。
>
> 通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。

### 大多数编译错误在实例化期间报告

模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。

第一个阶段是编译模板本身时。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。

第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。

第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。

当我们编写模板时，代码不能是针对特定类型的，但模板代码通常对其所使用的类型有一些假设。例如，我们最初的 compare 函数中的代码就假定实参类型定义了 < 运算符。

```C++
if (vl < v2) return -1; // 要求类型T的对象支持<操作
if (v2 < vl) return 1; // 要求类型T的对象支持<操作
return 0; // 返回 int；不依赖于 T
```

当编译器处理此模板时，它不能验证 if 语句中的条件是否合法。如果传递给 compare 的实参定义了 < 运算符，则代码就是正确的，否则就是错误的。例如，

```C++
Sales_data datal, data2;
cout << compare(datal, data2) << endl;// 错误∶ Sales_data未定义<
```

此调用实例化了 compare 的一个版本，将 T 替换为 Sales data。if 条件试图对Sales_data 对象使用 < 运算符，但 Sales_data 并未定义此运算符。此实例化生成了一个无法编译通过的函数版本。但是，这样的错误直至编译器在类型 Sales_data 上实例化 compare 时才会被发现。

> WARNING! 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。

### 16.1.2 类模板

类模板是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。如我们已经多次看到的，为了使用类模板，我们必须在

模板名后的尖括号中提供额外信息（参见3.3节）——用来代替模板参数的模板实参列表。

#### 定义类模板

作为一个例子，我们将实现 StrBlob（参见 12.1.1节）的模板版本。我们将此模板命名为 Blob，意指它不再针对 string。类似 StrBlob，我们的模板会提供对元素的共享（且核查过的）访问能力。与类不同，我们的模板可以用于更多类型的元素。与标准库容器相同，当使用 Blob 时，用户需要指出元素类型。

类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。在类模板（及其成员）的定义中，我们将模板参数当作替身，代替使用模板时用户需要提供的类型或值：

```C++
template <typename T> class Blob {
public:
	typedef T value_type;
	typedef typename std::vector<T>::size_type size_type;
  // 构造函数Blob();
	Blob(std::initializer_list<T> il);
  // Blob中的元素数目
	size_type size() const { return data->size();}
  bool empty() const { return data->empty();}
  // 添加和删除元素
	void push_back (const T &t){data->push_back(t);}
  //移动版本，参见13.6.3节
	void push_back(T &&t){ data->push_back(std::move(t));}
  void pop_back();
  //元素访问
  T& back();
	T& operator[](size_type i); // 在14.5节中定义
private:
	std::shared_ptr<std::vector<T>> data;
  // 若 data[i] 无效，则抛出msg
	void check(size_type i, const std::string &msg) const;
};
```

我们的 Blob 模板有一个名为 T 的模板类型参数，用来表示 Blob 保存的元素的类型。例如，我们将元素访问操作的返回类型定义为 T&。当用户实例化 Blob 时， T 就会被替换为特定的模板实参类型。

除了模板参数列表和使用 T 代替 string 之外，此类模板的定义与12.1.1节中定义的类版本及12.1.6节和第13章、第14章中更新的版本是一样的。

#### 实例化类模板

我们已经多次见到，当使用一个类模板时，我们必须提供额外信息。我们现在知道这些额外信息是显式模板实参列表，它们被绑定到模板参数。编译器使用这些模板实参来实例化出特定的类。

例如，为了用我们的 Blob 模板定义一个类型，必须提供元素类型：

```C++
Blob<int> ia;   // 空Blob<int>
Blob<int> ia2 = {0，1，2，3，4};  // 有5个元素的Blob<int>
```

ia 和 ia2 使用相同的特定类型版本的 Blob（即 Blob<int>）。从这两个定义，编译器会实例化出一个与下面定义等价的类：

```C++
template<> class Blob<int>{
	typedef typename std::vector<int>::size_type size_type;
  Blob();
	Blob(std::initializer_list<int> il);
  //...
	int& operator[](size_type i);
private:
	std::shared_ptr<std::vector<int>> data;
	void check(size_type i,const std::string &msg) const;
};
```

当编译器从我们的 Blob 模板实例化出一个类时，它会重写 Blob 模板，将模板参数 T 的每个实例替换为给定的模板实参，在本例中是 int。

对我们指定的每一种元素类型，编译器都生成一个不同的类：

```C++
// 下面的定义实例化出两个不同的 Blob类型
Blob<string> names; // 保存string 的Blob 
Blob<double> prices; // 不同的元素类型
```

这两个定义会实例化出两个不同的类。names 的定义创建了一个 Blob 类，每个  T 都被替换为string。prices 的定义生成了另一个 Blob 类，T 被替换为 double。

> Note! 一个类模板的每个实例都形成一个独立的类。类型 Blob<string> 与任何其他 Blob 类型都没有关联，也不会对任何其他 Blob 类型的成员有特殊访问权限。

#### 在模板作用域中引用模板类型

为了阅读模板类代码，应该记住类模板的名字不是一个类型名（参见 3.3 节）。类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。

可能令人迷惑的是，一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用模板的实参。例如，我们的 data 成员使用了两个模板，vector 和 shared_ptr。我们知道，无论何时使用模板都必须提供模板实参。在本例中，我们提供的模板实参就是 Blob 的模板参数。因此，data 的定义如下：

```C++
std::shared_ptr<std::vector<T>> data;
```

它使用了 Blob 的类型参数来声明 data 是一个 shared_ptr 的实例，此 shared_ptr 指向一个保存类型为 T 的对象的 vector 实例。当我们实例化一个特定类型的 Blob，例如 Blob<string> 时，data会成为：

```C++
shared_ptr<vector<string>>
```

如果我们实例化 Blob<int>，则 data 会成为 shared_ptr<vector<int>>，依此类推。

#### 类模板的成员函数

与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。

类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，定 义在类模板之外的成员函数就必须以关键字 template 开始，后接类模板参数列表。

与往常一样，当我们在类外定义一个成员时，必须说明成员属干哪个类。而且，从一个模板生成的类的名字中必须包含其模板实参。当我们定义一个成员函数时，模板实参与模板形参相同。即，对于 StrBlob 的一个给定的成员函数

```C++
ret-type StrBlob::member-name(parm-list)
```

对应的 Blob的成员应该是这样的：

```C++
template <typename T>
ret-type Blob<T>::member-name(parm-list)
```

#### check 和元素访问成员

我们首先定义 check 成员，它检查一个给定的索引：

```C++
template <typename T>
void Blob<T>::check(size_type i, const std::string &msg) const
{
  if(i >= data->size())
		throw std::out_of_range(msg);
}
```

除了类名中的不同之处以及使用了模板参数列表外，此函数与原 StrBlob 类的check 成员完全一样。

下标运算符和 back 函数用模板参数指出返回类型，其他未变：

```C++
template <typename T>
T& Blob<T>::back()
{
  check(0,"back on empty Blob");
  return data->back();
}
template <typename T>
T& Blob<T>::operator[](size_type i)
{
	// 如果i 太大，check会抛出异常，阻止访问一个不存在的元素
  check(i,"subscript out of range");
  return (*data)[i];
}
```

在原 StrBlob 类中，这些运算符返回 string&。而模板版本则返回一个引用，指向用来实例化 Blob 的类型。

pop_back 函数与原 StrBlob 的成员几乎相同：

```C++
template <typename T> 
void Blob<T>::pop_back()
{
  check(0,"pop_back on empty Blob");
  data->pop_back();
}
```

#### Blob 构造函数

与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始：

```C++
template <typename T>
Blob<T>::Blob() : data(std::make_shared<std::vector<T>>()){}
```

这段代码在作用域 Blob<T> 中定义了名为 Blob 的成员函数。类似 StrBlob 的默认构造函数（参见12.1.1 节），此构造函数分配一个空 vector，并将指向 vector 的指针保存在 data 中。如前所述，我们将类模板自己的类型参数作为vector 的模板实参来分配 vector。

类似的，接受一个 initializer_list 参数的构造函数将其类型参数 T 作为 initializer_list 参数的元素类型：

```C++
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il):
data(std::make_shared<std::vector<T>>(il)){ }
```

类似默认构造函数，此构造函数分配一个新的 vector。在本例中，我们用参数 il 来初始化此 vector。

为了使用这个构造函数，我们必须传递给它一个 initializer_list，其中的元素必须与 Blob 的元素类型兼容：

```C++
Blob<string> articles = {"a","an","the"};
```

这条语句中，构造函数的参数类型为 initializer_list<string>。列表中的每个字符串字面常量隐式地转换为一个 string。

#### 类模板成员函数的实例化

默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。例如，下面代码

```C++
// 实例化Blob<int>和接受 initializer_list<int>的构造函数
Blob<int> squares = {0,1,2,3,4,5,6,7,8,9};
// 实例化Blob<int>∶∶size() const
for (size_t i = 0; i != squares.size(); ++i)
	squares[i] = i*i; // 实例化Blob<int>∶∶operator[] (size_t)
```

实例化了 Blob<int> 类和它的三个成员函数：operator[]、size 和接受initializer_list<int> 的构造函数。

如果一个成员函数没有被使用，则它不会被实例化。成员函数只有在被用到时才进行实例化，这一特性使得即使某种类型不能完全符合模板操作的要求（参见 9.2节），我们仍然能用该类型实例化类。

> Note! 默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。

#### 在类代码内简化模板类名的使用

当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参：

```C++
// 若试图访问一个不存在的元素，BlobPtr抛出一个异常
template <typename T> class BlobPtr {
public:
	BlobPtr(): curr(0){}
	BlobPtr(Blob<T> &a, size_t sz = 0):
				wptr(a.data), curr(sz) { }
	T& operator*() const
	{ auto p = check(curr, "dereference past end");
		return (*p)[curr]; //(*p) 为本对象指向的 vector
  }
  // 递增和递减
	BlobPtr& operator++();// 前置运算符
  BlobPtr& operator--();
private:
	// 若检查成功，check 返回一个指向 vector 的 shared_ptr 
  std::shared_ptr<std::vector<T>>
	check(std::size_t, const std::string&) const;
  // 保存一个 weak ptr，表示底层 vector 可能被销毁
  std::weak_ptr<std::vector<T>> wptr;
  std∶∶size_t curr;// 数组中的当前位置
};
```

细心的读者可能已经注意到，BlobPtr 的前置递增和递减成员返回 BlobPtr&，而不是 BlobPtr<T>&。当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样。即，就好像我们这样编写代码一样：

```C++
BlobPtr<T>& operator++();
BlobPtr<T>& operator--();
```

#### 在类模板外使用类模板名

当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域（参见7.4节）：

```C++
// 后置∶ 递增/递减对象但返回原值
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int)
{
  // 此处无须检查;调用前置递增时会进行检查
	BlobPtr ret = *this; //保存当前值
  ++*this;  //推进一个元素;前置++检查递增是否合法
	return ret; // 返回保存的状态、
}
```

由于返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的 BlobPtr，它所用类型与类实例化所用类型一致。在函数体内，我们已经进入类的作用域，因此在定义 ret 时无须重复模板实参。如果不提供模板实参，则编译器将假定我们使用的类型与成员实例化所用类型一致。因此，ret 的定义与如下代码等价：

```C++
BlobPtr<T> ret = *this;
```

> Note! 在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。

#### 类模板和友元

当一个类包含一个友元声明（参见7.2.1节）时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

#### 一对一友好关系

类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。例如，我们的 Blob 类应该将 BlobPtr 类和一个模板版本的 Blob 相等运算符定义为友元。

为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板声明包括模板参数列表：

```C++
// 前置声明，在 Blob 中声明友元所需要的
template <typename> class BlobPtr;
template <typename> class Blob;//运算符==中的参数所需要的
template <typename T>
bool operator==(const Blob<T>&,const Blob<T>&);
template<typename T> class Blob{
	//每个Blob 实例将访问权限授予用相同类型实例化的 BlobPtr和相等运算符
  friend class BlobPtr<T>;
  friend bool operator==<T>(const Blob<T>&,const Blob<T>&);
//其他成员定义，与12.1.1 相同
};
```

我们首先将 Blob、BlobPtr 和 operator== 声明为模板。这些声明是 operator== 函数的参数声明以及 Blob 中的友元声明所需要的。

友元的声明用 Blob 的模板形参作为它们自己的模板实参。因此，友好关系被限定在用相同类型实例化的 Blob 与 BlobPtr 相等运算符之间：

```C++
Blob<char> ca;// BlobPtr<char>和 operator==<char>都是本对象的友元
Blob<int> ia; // BlobPtr<int>和 operator==<int>都是本对象的友元
```

BlobPtr<char> 的成员可以访问 ca（或任何其他 Blob<char> 对象）的非 public 部分，但 ca 对 ia（或任何其他 Blob<int> 对象）或 Blob 的任何其他实例都没有特殊访问权限。

#### 通用和特定的模板友好关系

一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元：

```C++
// 前置声明，在将模板的一个特定实例声明为友元时要用到
template <typename T> class Pal;
class C{ // C是一个普通的非模板类
	friend class Pal<C>; //用类C实例化的 Pal是C的一个友元
  // Pal2的所有实例都是C的友元;这种情况无须前置声明
  template <typename T> friend class Pal2;
};
template <typename T> class C2{  // C2本身是一个类模板
	// C2的每个实例将相同实例化的 Pal声明为友元
	friend class Pal<T>; // Pal的模板声明必须在作用域之内
  // Pal2的所有实例都是C2 的每个实例的友元，不需要前置声明
  template <typename X> friend class Pal2;
  // Pal3是一个非模板类，它是C2 所有实例的友元
  friend class Pal3; // 不需要 Pal3的前置声明
};
```

为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。

#### 令模板自己的类型参数成为友元

在新标准中，我们可以将模板类型参数声明为友元：

```C++
template <typename Type> class Bar {
friend Type; //将访问权限授予用来实例化 Bar的类型
	//... 
};
```

此处我们将用来实例化 Bar 的类型声明为友元。因此，对于某个类型名 Foo，Foo 将成为 Bar<Foo> 的友元，Sales_data 将成为 Bar<Sales_data> 的友元，依此类推。值得注意的是，虽然友元通常来说应该是一个类或是一个函数，但我们完全可以用一个内置类型来实例化 Bar。这种与内置类型的友好关系是允许的，以便我们能用内置类型来实例化 Bar 这样的类。

#### 模板类型别名

类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个 typedef（参见2.5.1节）来引用实例化的类：

```C++
typedef Blob<string> StrBlob;
```

这条 typedef 语句允许我们运行在 12.1.1 节中编写的代码，而使用的却是用 string 实例化的模板版本的 Blob。**由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板**。即，无法定义一个 typedef 引用 Blob<T>。

但是，新标准允许我们为类模板定义一个类型别名：

```C++
template<typename T> using twin = pair<T, T>;
twin<string> authors; // authors是一个 pair<string，string>
```

在这段代码中，我们将 twin 定义为成员类型相同的 pair 的别名。这样，twin 的用户只需指定一次类型。

一个模板类型别名是一族类的别名：

```C++
twin<int> win_loss;// win loss 是一个 pair<int，int>
twin<double> area;// area是一个 pair<double，double>
```

就像使用类模板一样，当我们使用 twin 时，需要指出希望使用哪种特定类型的twin。

当我们定义一个模板类型别名时，可以固定一个或多个模板参数：

```C++
template <typename T> using partNo = pair<T, unsigned>;
partNo<string> books;// books是一个pair<string，unsigned>
partNo<Vehicle> cars;// cars是一个 pair<Vehicle，unsigned>
partNo<Student> kids;// kids 是一个 pair<Student，unsigned>
```

这段代码中我们将 partNo 定义为一族类型的别名，这族类型是 second 成员为unsigned 的 pair。partNo 的用户需要指出 pair 的 first 成员的类型，但不能指定 second 成员的类型。

#### 类模板的 static 成员

与任何其他类相同，类模板可以声明 static 成员（参见7.6节）：

```C++
template <typename T> class Foo {
public:
  static std::size_t count() { return ctr;}
  // 其他接口成员
private:
	static std::size_t ctr;
  // 其他实现成员
};
```

在这段代码中，Foo 是一个类模板，它有一个名为 count 的 public static 成员函数和一个名为 ctr 的 private static 数据成员。每个 Foo 的实例都有其自己的static 成员实例。即，对任意给定类型 x，都有一个 Foo<X>::ctr 和一个 Foo<X>::count 成员。所有 Foo<X> 类型的对象共享相同的 ctr 对象和 count 函数。例如，

```C++
// 实例化 static 成员 Foo<string>∶∶ctr和 Foo<string>∶∶count 
Foo<string> fs;
//所有三个对象共享相同的 Foo<int>∶∶ctr和Foo<int>∶∶count 成员
Foo<int> fi, fi2, fi3;
```

与任何其他 static 数据成员相同，模板类的每个 static 数据成员必须有且仅有一个定义。但是，类模板的每个实例都有一个独有的 static 对象。因此，与定义模板的成员函数类似，我们将 static 数据成员也定义为模板：

```C++
template <typename T>
size_t Foo<T>∶∶ctr = 0;// 定义并初始化 ctr
```

与类模板的其他任何成员类似，定义的开始部分是模板参数列表，随后是我们定义的成员的类型和名字。与往常一样，成员名包括成员的类名，对于从模板生成的类来说，类名包括模板实参。因此，当使用一个特定的模板实参类型实例化Foo 时，将会为该类类型实例化一个独立的 ctr，并将其初始化为0。

与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的 static 成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问 static 成员，我们必须引用一个特定的实例：

```C++
Foo<int> fi;  // 实例化 Foo<int>类和 static 数据成员 ctr
auto ct = Foo<int>∶∶count(); // 实例化 Foo<int>∶∶count 
ct = fi.count();  // 使用 Foo<int>∶∶count
ct = Foo::count();  // 错误∶ 使用哪个模板实例的 count?
```

类似任何其他成员函数，一个 static 成员函数只有在使用时才会实例化。

### 16.1.3 模板参数

类似函数参数的名字，一个模板参数的名字也没有什么内在含义。我们通常将类型参数命名为 T，但实际上我们可以使用任何名字：

```C++
template <typename Foo> Foo calc(const Foo& a,const Foo& b)
{
  Foo tmp = a; // tmp 的类型与参数和返回类型一样
  //...
	return tmp;// 返回类型和参数类型一样
}
```

#### 模板参数与作用域

模板参数遵循普通的作用域规则。一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名：

```C++
typedef double A;
template <typename A, typename B> void f(A a, B b)
{
  A tmp = a; // tmp 的类型为模板参数A的类型，而非double 
  double B; // 错误∶重声明模板参数 B ”
}
```

正常的名字隐藏规则决定了 A 的 typedef 被类型参数 A 隐藏。因此，tmp 不是一个double，其类型是使用 f 时绑定到类型参数 A 的类型。由于我们不能重用模板参数名，声明名字为 B 的变量是错误的。

由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次：

```C++
// 错误∶非法重用模板参数名V
template <typename V, typename V> //..
```

#### 模板声明

模板声明必须包含模板参数：

```C++
// 声明但不定义 compare 和 Blob
template <typename T> int compare(const T&,const T&);
template <typename T> class Blob;
```

与函数参数相同，声明中的模板参数的名字不必与定义中相同：

```C++
// 3个 calc 都指向相同的函数模板
template <typename T> T calc（const T&，const T&）; //声明
template <typename U> U calc（const U&，const U&）; //声明
//模板的定义
template <typename Type>
Type calc(const Type& a, const Type& b) { /* ...*/ )
```

当然，一个给定模板的每个声明和定义必须有相同数量和种类（即，类型或非类型）的参数。

> Note! 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前，原因我们将在16.3节中解释。

#### 使用类的类型成员

回忆一下，我们用作用域运算符（::）来访问 static 成员和类型成员（参见7.4节和7.6节）。在普通（非模板）代码中，编译器掌握类的定义。因此，它知道通过作用域运算符访问的名字是类型还是 static 成员。例如，如果我们写下

string::size_type，编译器有 string 的定义，从而知道 size_ type 是一个类型。

但对于模板代码就存在困难。例如，假定 T 是一个模板类型参数，当编译器遇到类似 T::mem 这样的代码时，它不会知道 mem 是一个类型成员还是一个 static数据成员，直至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。例如，假定 T 是一个类型参数的名字，当编译器遇到如下形式的语句时：

```C++
T::size_type *p;
```

它需要知道我们是正在定义一个名为 p 的变量还是将一个名为 size_type 的 static 数据成员与名为 p 的变量相乘。

默认情况下，C++ 语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字 typename 来实现这一点：

```C++
template <typename T>
typename T::value_type top (const T& c){
	if(!c.empty())
		return c.back();
  else
		return typename T::value_type();
}
```

我们的 top 函数期待一个容器类型的实参，它使用 typename 指明其返回类型并在 c 中没有元素时生成一个值初始化的元素（参见7.5.3节）返回给调用者。

> Note! 当我们希望通知编译器一个名字表示类型时，必须使用关键字 typename，而不能使用 class。

#### 默认模板实参

就像我们能为函数参数提供默认实参一样（参见6.5.1 节），我们也可以提供默认模板实参。在新标准中，我们可以为函数和类模板提供默认实参。而更早的C++ 标准只允许为类模板提供默认实参。

例如，我们重写 compare，默认使用标准库的 less 函数对象模板（参见14.8.2节）：

```c++
// compare 有一个默认模板实参 less<T> 和一个默认函数实参 F() 
template <typename T, typename F = less<T>> 
int compare(const T &vl, const T &v2, F f = F())
{
  if (f(vl, v2)) return -1;
  if (f(v2, v1)) return 1;
  return 0;
}
```

在这段代码中，我们为模板添加了第二个类型参数，名为 F，表示可调用对象（参见10.3.2 节）的类型；并定义了一个新的函数参数 f，绑定到一个可调用对象上。

我们为此模板参数提供了默认实参，并为其对应的函数参数也提供了默认实参。默认模板实参指出 compare 将使用标准库的 less 函数对象类，它是使用与compare 一样的类型参数实例化的。默认函数实参指出 f 将是类型 F 的一个默认初始化的对象。

当用户调用这个版本的 compare 时，可以提供自己的比较操作，但这并不是必需的：

```C++
bool i = compare(0, 42); // 使用less; i为-1 
// 结果依赖于iteml和item2中的 isbn 
Sales_data iteml(cin), item2(cin);
bool j = compare(iteml, item2, compareIsbn);
```

第一个调用使用默认函数实参，即，类型 less<T> 的一个默认初始化对象。在此调用中，T 为 int，因此可调用对象的类型为 less<int>。compare 的这个实例化版本将使用 less<int> 进行比较操作。

在第二个调用中，我们传递给 compare 三个实参：compareIsbn（参见11.2.2节）和两个 Sales_data 类型的对象。当传递给 compare 三个实参时，第三个实参的类型必须是一个可调用对象，该可调用对象的返回类型必须能转换为 bool值，且接受的实参类型必须与 compare 的前两个实参的类型兼容。与往常一样，模板参数的类型从它们对应的函数实参推断而来。在此调用中，T 的类型被推断为 Sales_data，F 被推断为 compareIsbn 的类型。

与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。

#### 模板默认实参与类模板

无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：

```C++
template <class T = int> class Numbers { // T默认为 int 
public:
	Numbers(T v = 0): val(v) {}
  // 对数值的各种操作
private:
	T val;
};
Numbers<long double> lots_of_precision;
Numbers<> average_precision;  //空<>表示我们希望使用默认类型
```

此例中我们实例化了两个 Numbers 版本：average_precision 是用 int 代替 T 实例化得到的；lots_of_precision 是用 long double 代替 T 实例化而得到的。

### 16.1.4 成员模板

一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为成员模板。**成员模板不能是虚函数**。

#### 普通（非模板）类的成员模板

作为普通类包含成员模板的例子，我们定义一个类，类似 unique_ptr 所使用的默认删除器类型（参见12.1.5节）。类似默认删除器，我们的类将包含一个重载的函数调用运算符（参见14.8 节），它接受一个指针并对此指针执行 delete。与默认删除器不同，我们的类还将在删除器被执行时打印一条信息。由于希望删除器适用于任何类型，所以我们将调用运算符定义为一个模板：

```c++
// 函数对象类，对给定指针执行 delete 
class DebugDelete {
public:
	DebugDelete(std::ostream &s = std::cerr): os(s) { }
  // 与任何函数模板相同，T 的类型由编译器推断
template <typename T> void operator()(T *p) const
	{ os << "deleting unique ptr" << std::endl; delete p;}
private:
	std::ostream &os;
};
```

与任何其他模板相同，成员模板也是以模板参数列表开始的。每个 DebugDelete 对象都有一个 ostream 成员，用于写入数据；还包含一个自身是模板的成员函数。我们可以用这个类代替delete：

```C++
double* p = new double;
DebugDelete d;// 可像 delete 表达式一样使用的对象
d(p); // 调用 DebugDelete∶∶operator()(double*),释放p 
int* ip = new int;
// 在一个临时 DebugDelete 对象上调用 operator()(int*)
DebugDelete()(ip);
```

由于调用一个 DebugDelete 对象会 delete 其给定的指针，我们也可以将DebugDelete 用作 unique_ptr 的删除器。为了重载 unique_ptr 的删除器，我们在尖括号内给出删除器类型，并提供一个这种类型的对象给 unique_ptr 的构造函数（参见12.1.5节）：

```C++
// 销毁p指向的对象
// 实例化 DebugDelete∶∶operator()<int>(int *)
unique_ptr<int,DebugDelete> p(new int, DebugDelete());
//销毁 sp指向的对象
// 实例化 DebugDelete∶∶operator()<string>(string*)
unique_ptr<string,DebugDelete> sp(new string,DebugDelete());
```

在本例中，我们声明 p 的删除器的类型为 DebugDelete，并在 p 的构造函数中提供了该类型的一个未命名对象。

unique_ptr 的析构函数会调用 DebugDelete 的调用运算符。因此，无论何时unique_ptr 的析构函数实例化时，DebugDelete 的调用运算符都会实例化：因此，上述定义会这样实例化。

```C++
// DebugDelete 的成员模板实例化样例
void DebugDelete::operator()(int *p) const { delete p; }
void DebugDelete::operator()(string *p) const { delete p;}
```

#### 类模板的成员模板

对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各自有自己的、独立的模板参数。

例如，我们将为 Blob 类定义一个构造函数，它接受两个迭代器，表示要拷贝的元素范围。由于我们希望支持不同类型序列的迭代器，因此将构造函数定义为模板：

```C++
template <typename T> class Blob {
	template <typename It> Blob (It b, It e);
  //... 
};
```

此构造函数有自己的模板类型参数 It，作为它的两个函数参数的类型。

与类模板的普通函数成员不同，成员模板是函数模板。当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：

```C++
template <typename T>  // 类的类型参数
template <typename It> // 构造函数的类型参数
Blob<T>::Blob(It b,It e):
data(std::make_shared<std::vector<T>>(b, e)) {}
```

在此例中，我们定义了一个类模板的成员，类模板有一个模板类型参数，命名为T。而成员自身是一个函数模板，它有一个名为 It 的类型参数。

#### 实例化与成员模板

为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。与往常一样，我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参。与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板实参（参见16.1.1节）：

```C++
int ia[] ={0,1,2,3,4,5,6,7,8,9};
vector<long> vi = {0,1,2,3,4,5,6,7,8,9};
list<const char*> w ={"now","is","the","time"};
// 实例化 Blob<int>类及其接受两个 int*参数的构造函数
Blob<int> al(begin(ia), end(ia));
// 实例化Blob<int>类的接受两个 vector<long>∶∶iterator的构造函数
Blob<int> a2(vi.begin(), vi.end());
// 实例化Blob<string>及其接受两个list<const char*>∶∶iterator参数的构造函数
Blob<string> a3(w.begin(), w.end());
```

当我们定义 a1 时，显式地指出编译器应该实例化一个 int 版本的 Blob。构造函数自己的类型参数则通过 begin(ia) 和 end(ia) 的类型来推断，结果为 int*。因此，a1 的定义实例化了如下版本：

```C++
Blob<int>::Blob(int*, int*);
```

a2 的定义使用了已经实例化了的 Blob<int> 类，并用 vector<long>::iterator 替换 It 来实例化构造函数。a3 的定义（显式地）实例化了一个 string 版本的 Blob，并（隐式地）实例化了该类的成员模板构造函数，其模板参数被绑定到 list<const char*>。

### 16.1.5 控制实例化

当模板被使用时才会进行实例化（参见16.1.1 节）这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。

在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过显式实例化（explicit instantiation）来避免这种开销。一个显式实例化有如下形式：

```C++
extern template declaration;  //实例化声明
template declaration;  //实例化定义
```

declaration 是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，

```C++
// 实例化声明与定义
extern template class Blob<string>;  //声明
template int compare(const int&，const int&); // 定义
```

当编译器遇到 extern 模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为 extern 就表示承诺在程序其他位置有该实例化的一个非 extern 声明（定义）。对于一个给定的实例化版本，可能有多个 extern 声明，但必须只有一个定义。

由于编译器在使用一个模板时自动对其实例化，因此 extern 声明必须出现在任何使用此实例化版本的代码之前：

```C++
// Application.cc
// 这些模板类型必须在程序其他位置进行实例化
extern template class Blob<string>;
extern template int compare(const int&,const int&);
Blob<string> sal, sa2; // 实例化会出现在其他位置
// Blob<int>及其接受 initializer_list的构造函数在本文件中实例化
Blob<int> al ={0,1,2,3,4,5,6,7,8,9};
Blob<int> a2(al); // 拷贝构造函数在本文件中实例化
int i = compare(al[0], a2[0]); // 实例化出现在其他位置
```

文件 Application.o 将包含 Blob<int> 的实例及其接受 initializer_list 参数的构造函数和拷贝构造函数的实例。而 compare<int> 函数和 Blob<string> 类将不在本文件中进行实例化。这些模板的定义必须出现在程序的其他文件中：

```C++
// templateBuild.cc
// 实例化文件必须为每个在其他文件中声明为 extern 的类型和函数提供一个（非extern）的定义
template int compare(const int&, const int&);
template class Blob<string>; // 实例化类模板的所有成员
```

当编译器遇到一个实例化定义（与声明相对）时，它为其生成代码。因此，文件templateBuild.o 将会包含 compare 的 int 实例化版本的定义和 Blob<string>类的定义。当我们编译此应用程序时，必须将 templateBuild.o 和 Application.o链接到一起。

> WARNING! 对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。

#### 实例化定义会实例化所有成员

一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化个类模板的类型，必须能用于模板的所有成员。

> Note! 在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。

### 16.1.6 效率与灵活性

对模板设计者所面对的设计选择，标准库智能指针类型（参见12.1 节）给出了一个很好的展示。

shared_ptr 和 unique_ptr 之间的明显不同是它们管理所保存的指针的策略——前者给予我们共享指针所有权的能力；后者则独占指针。这一差异对两个类的功能来说是至关重要的。

这两个类的另一个差异是它们允许用户重载默认删除器的方式。我们可以很容易地重载一个 shared_ptr 的删除器，只要在创建或 reset 指针时传递给它一个可调用对象即可。与之相反，删除器的类型是一个 unique_ptr 对象的类型的一部分。用户必须在定义 unique_ptr 时以显式模板实参的形式提供删除器的类型。因此，对于 unique_ptr 的用户来说，提供自己的删除器就更为复杂。

如何处理删除器的差异实际上就是这两个类功能的差异。但是，如我们将要看到的，这一实现策略上的差异可能对性能有重要影响。

#### 在运行时绑定删除器

虽然我们不知道标准库类型是如何实现的，但可以推断出，shared_ptr 必须能直接访问其删除器。即，删除器必须保存为一个指针或一个封装了指针的类（如 function，参见14.8.3节）。

我们可以确定 shared_ptr 不是将删除器直接保存为一个成员，因为删除器的类型直到运行时才会知道。实际上，在一个 shared_ptr 的生存期中，我们可以随时改变其删除器的类型。我们可以使用一种类型的删除器构造一个 shared_ptr，随后使用 reset 赋予此 shared_ptr 另一种类型的删除器。通常，类成员的类型在运行时是不能改变的。因此，不能直接保存删除器。

为了考察删除器是如何正确工作的，让我们假定 shared_ptr 将它管理的指针保存在一个成员 p 中，且删除器是通过一个名为 del 的成员来访问的。则 shared_ptr 的析构函数必须包含类似下面这样的语句：

```C++
// del的值只有在运行时才知道;通过一个指针来调用它
del ? del(p) : delete p; // del(p)需要运行时跳转到 del的地址
```

由于删除器是间接保存的，调用 del(p) 需要一次运行时的跳转操作，转到 del 中保存的地址来执行对应的代码。

#### 在编译时绑定删除器

现在，让我们来考察 unique_ptr 可能的工作方式。在这个类中，删除器的类型是类类型的一部分。即，unique_ptr 有两个模板参数，一个表示它所管理的指针，另一个表示删除器的类型。由于删除器的类型是 unique_ptr 类型的一部分，因此删除器成员的类型在编译时是知道的，从而删除器可以直接保存在 unique_ptr 对象中。

unique_ptr 的析构函数与 shared_ptr 的析构函数类似，也是对其保存的指针调用用户提供的删除器或执行delete：

```C++
// del在编译时绑定;直接调用实例化的删除器
del(p); // 无运行时额外开销
```

del 的类型或者是默认删除器类型，或者是用户提供的类型。到底是哪种情况没有关系，应该执行的代码在编译时肯定会知道。实际上，如果删除器是类似 DebugDelete（参见16.1.4 节）之类的东西，这个调用甚至可能被编译为内联形式。

通过在编译时绑定删除器，unique_ptr 避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，shared_ptr 使用户重载删除器更为方便。

## 16.2 模板实参推断

我们已经看到，对于函数模板，编译器利用调用中的函数实参来确定其模板参数。从函数实参来确定模板实参的过程被称为模板实参推断。在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板实参，用这些模板实参生成的函数版本与给定的函数调用最为匹配。

### 16.2.1 类型转换与模板类型参数

与非模板函数一样，我们在一次调用中传递给函数模板的实参被用来初始化函数的形参。如果一个函数形参的类型使用了模板类型参数，那么它采用特殊的初始化规则。只有很有限的几种类型转换会自动地应用于这些实参。编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。

与往常一样，顶层 const（参见2.4.3节）无论是在形参中还是在实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。

- const 转换：可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参（参见4.11.2节）。
- 数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针（参见 4.11.2节）。

其他类型转换，如算术转换（参见 4.11.1 节）、派生类向基类的转换（参见 15.2.2 节）以及用户定义的转换（参见7.5.4节和14.9节），都不能应用于函数模板。

作为一个例子，考虑对函数 fobi 和 fref 的调用。fobi 函数拷贝它的参数，而 fref 的参数是引用类型：

```C++
template <typename T> T fobj（T，T）;// 实参被拷贝
template <typename T> T fref（const T&，const T&）;// 引用
string sl("a value");
const string s2 ("another value");
fobj(s1,s2);  // 调用 fobj(string，string); const 被忽略
fref(sl,s2);  // 调用 fref(const string&，const string&)
							//将 s1转换为const是允许的
int a[10], b[42];
fobj(a,b); //调用f（int*，int*）
fref(a,b); // 错误∶数组类型不匹配
```

在第一对调用中，我们传递了一个 string 和一个 const string。虽然这些类型不严格匹配，但两个调用都是合法的。在 fobi 调用中，实参被拷贝，因此原对象是否是 const 没有关系。在 fref 调用中，参数类型是 const 的引用。对于一个引用参数来说，转换为 const 是允许的，因此这个调用也是合法的。

在下一对调用中，我们传递了数组实参，两个数组大小不同，因此是不同类型。在 fobj 调用中，数组大小不同无关紧要。两个数组都被转换为指针。fobj 中的模板类型为 int*。但是，fref 调用是不合法的。**如果形参是一个引用，则数组不会转换为指针**（参见6.2.4节）。a 和 b 的类型是不匹配的，因此调用是错误的。

> Note! 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有 const 转换及数组或函数到指针的转换。

#### 使用相同模板参数类型的函数形参

一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果推断出的类型不匹配，则调用就是错误的。例如，我们的 compare 函数（参见16.1.1 节）接受两个 const T& 参数，其实参必须是相同类型：

```C++
long lng;
compare(1ng，1024); // 错误∶不能实例化compare(long，int)
```

此调用是错误的，因为传递给 compare 的实参类型不同。从第一个函数实参推断出的模板实参为 long，从第二个函数实参推断出的模板实参为 int。这些类型不匹配，因此模板实参推断失败。

如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数：

```C++
// 实参类型可以不同，但必须兼容
template <typename A,typename B>
int flexibleCompare(const A& vl, const B& v2)
{
  if (v1 < v2) return -1;
  if (v2 < v1) return 1;
  return 0;
}
```

现在用户可以提供不同类型的实参了：

```C++
long lng;
flexibleCompare(lng，1024); // 正确∶调用 flexibleCompare（long，int）
```

当然，必须定义了能比较这些类型的值的 < 运算符。
