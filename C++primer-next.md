# 第 15 章 面向对象程序设计

面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。

继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉他们的区别。

在很多程序中都存在着一些相互关联但是有细微差别的概念。例如，书店中不同书籍的定价策略可能不同：有的书籍按原价销售，有的则打折销售。有时，我们给那些购买书籍超过一定数量的顾客打折；另一些时候，则只对前多少本销售的书籍打折，之后就调回原价，等等。面向对象的程序设计(OOP)适用于这类应用。

## 15.1 OOP: 概述

**面向对象程序设计**的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

#### 继承

通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类**，其他类则直接或间接地从基类继承而来，这些继承得到的类称为**派生类**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。

为了对之前提到的不同定价策略建模，我们首先定义一个名为 Quote 的类，并将它作为层次关系中的基类。Quote 的对象表示按原价销售的书籍。Quote 派生出另一个名为 Bulk_quote 的类，它表示可以打折销售的书籍。

这些类将包含下面的两个成员函数：

- isbn()，返回书籍的 ISBN 编号。该操作不涉及派生类的特殊性，因此只定义在 Quote 类中。
- net_price(size_t)，返回书籍的实际销售价格，前提是用户购买该书的数量达到一定标准。这个操作显然是类型相关的，Quote 和 Bulk_quote 都应该包含该函数。

在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数**。因此，我们可以将 Quote 类编写成：

```C++
class Quote {
public:
  std::string isbn() const;
  virtual double net_price(std::size_t n) const;
};
```

派生类必须通过使用**类派生列表**明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符：

```C++
class Bulk_quote : public Quote {
public:
  double net_price(std::size_t) const override;
};
```

因为 Bulk_quote 在它的派生列表中使用了 public 关键字，因此我们完全可以把 Bulk_quote 的对象当成 Quote 的对象来使用。

派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtual 关键字，但是并不是非得这么做。C++新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个 override 关键字。

#### 动态绑定

通过使用**动态绑定**，我们能用同一段代码分别处理 Quote 和 Bulk_quote 的对象。例如，当要购买的书籍和购买的数量都已知时，下面的函数负责打印总的费用：

```C++
// 计算并打印销售给定数量的某种书籍所得的费用
double print_total (ostream &os, const Quote &item, size_t n)
{
  // 根据传入 item 形参的对象类型调用 Quote::net_price
  // 或者Bulk_quote::net_price
  double ret = item.net_price(n);
  os << "ISBN: " << item.isbn()
     << " # sold: " << n << " total due: " << ret << endl;
  return ret;
}
```

该函数非常简单：它返回调用 net_price() 的结果，并将该结果连同调用 isbn() 的结果一起打印出来。

关于上面的函数有两个有意思的结论：因为函数 print_total 的 item 形参是基类 Quote 的一个引用，我们既能使用基类 Quote 的对象调用该函数，也能使用派生类 Bulk_quote 的对象调用它；又因为 print_total 是使用引用类型调用 net_price 函数的，所以实际传入 print_total 的对象类型将决定到底执行 net_price 的哪个版本：

```C++
// basic 的类型是Quote;bulk的类型是Bulk_quote
print_total(cout, basic, 20); // 调用 Quote 的net_price
print_total(cout, bulk, 20); // 调用 Bulk_quote 的net_price
```

第一条调用句将 Quote 对象传入 print_total，因此当 print_total 调用 net_price 时，执行的是 Quote 的版本；在第二条调用语句中，实参的类型是 Bulk_quote，因此执行的是 Bulk_quote 的版本（计算打折信息）。因为在上述过程中函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为**运行时绑定**。

> Note! 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

## 15.2 定义基类和派生类

定义基类和派生类的方式在很多方面都与我们已知的定义其他类的方式类似，但是也有一些不同之处。本节将介绍在定义有继承关系的类时可能用到的基本特性。

### 15.2.1 定义基类

我们首先完成 Quote 类的定义：

```C++
class Quote {
public:
  Quote() = default;
  Quote(const std::string &book, double sales_price): bookNo(book), price(sales_price) {}
  std::string isbn() const {return bookNo;}
  // 返回给定数量的书籍的销售总额
  // 派生类负责改写并使用不同的折扣计算方法
  virtual double net_price(std::size_t n) const
  				{return n * price;}
  virtual ~Quote() = default; // 对析构函数进行动态绑定
private:
  std::string bookNo;
protected:
  double price = 0.0; // 代表普通状态下不打折的价格
};
```

对于上面这个类来说，新增的部分是在 net_price 函数和析构函数之前增加的 virtual 关键字以及最后的 protected 访问说明符。我们将在15.7.1节详细介绍虚析构函数的知识，现在只需记住作为继承关系中根节点的类通常都会定义一个虚析构函数。

> Note! 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

#### 成员函数与继承

派生类可以继承其基类的成员，然而当遇到如 net_price 这样与类型相关的操作时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以覆盖从基类继承而来的旧定义。

在 C++语言中，基类必须将它的两种成员函数区分开来;一种是基类希望其派生类进行覆盖的函数;另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通常将其定义为虚函数。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

基类通过在其成员函数的声明语句之前加上关键字 virtual使得该函数执行动态绑定。任何构造函数之外的非静态函数（参见7.6节）都可以是虚函数。关键字virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。我们将在 15.3 节介绍更多关于虚函数的知识。

成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。对于isbn 成员来说这正是我们希望看到的结果。isbn 函数的执行与派生类的细节无关，不管作用于 Quote 对象还是 Bulk_quote 对象，isbn 函数的行为都一样。在我们的继承层次关系中只有一个isbn 函数，因此也就不存在调用 isbn() 时到底执行哪个版本的疑问。

#### 访问控制与继承

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员。

我们的 Quote 类希望它的派生类定义各自的 net_price 函数，因此派生类需要访问 Quote 的 price 成员。此时我们将 price 定义成受保护的。与之相反，派生类访问bookNo 成员的方式与其他用户是一样的，都是通过调用isbn 函数，因此bookNo 被定义成私有的，即使是 Quote 派生出来的类也不能直接访问它。我们将在 15.5 节介绍更多关于受保护成员的知识。

### 15.2.2 定义派生类

派生类必须通过使用类派生列表明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。

派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明，因此，我们的Bulk_quote类必须包含一个 net_price 成员∶

```C++
class Bulk_quote : public Quote {  // Bulk_quote 继承自Quote public:
	Bulk_quote ()= default;
	Bulk quote(const std::string&, double, std::size_t, double);
  // 覆盖基类的函数版本以实现基于大量购买的折扣政策
  double net_price(std::size t) const override;
private:
	std:size_t min_qty = 0;	// 适用折扣政策的最低购买量
	double discount = 0.0;; // 以小数表示的折扣额
};
```

我们的 Bulk_quote 类从它的基类 Quote 那里继承了 isbn 函数和 bookNo、price 等数据成员。此外，它还定义了 net_price 的新版本，同时拥有两个新增加的数据成员 min_qty 和 discount。这两个成员分别用于说明享受折扣所需购买的最低数量以及一旦该数量达到之后具体的折扣信息。

我们将在15.5节详细介绍派生列表中用到的访问说明符。现在，**我们只需知道访问说明符的作用是控制派生类从基类继承而来的成员是否对派生类的用户可见**。

如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们能将公有派生类型的对象绑定到基类的引用或指针上。因为我们在派生列表中使用了 public。所以 Bulk_quote 的接口隐式地包含 isbn 函数，同时在任何需要 Quote 的引用或指针的地方我们都能使用 Bulk_quote 的对象。

大多数类都只继承自一个类，这种形式的继承被称作"单继承"，它构成了本章的主题。关于派生列表中含有多于一个基类的情况将在 18.3节中介绍。

#### 派生类中的虚函数

派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

派生类可以在它覆盖的函数前使用 virtual 关键字，但不是非得这么做。我们将在15.3节介绍其原因，C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在 const 成员函数（参见7.1.2节）的const关键字后面、或者在引用成员函数（参见13.6.3节）的引用限定符后面添加一个关键字 override。

#### 派生类对象及派生类向基类的类型转换

一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。因此，一个 Bulk_quote 对象将包含四个数据元素∶它从 Quote 继承而来的 bookNo 和 price 数据成员，以及 Bulk_quote 自己定义的min_qty 和 discount 成员。

C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为Bulk_quote 的对象包含如图15.1所示的两部分。

![](https://cdn.pkubailu.cn/img/15.1.png)

因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。

```C++
Quote item;  // 基类对象
Bulk_quote bulk;  // 派生类对象
Quote* p = &item; // p指向Quote对象
p = &bulk;  // p指向bulk的 Quote部分
Quote &r = bulk;  // r绑定到 bulk的 Quote部分
```

这种转换通常称为**派生类到基类的**类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换（参见4.11节）。

这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。

> Note! 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。

#### 派生类构造函数

尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。

> Note! 每个类控制它自己的成员初始化过程。

派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段（参见7.5.1节）执行初始化操作的。类似于我们初始化成员的过程，派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的。例如，接受四个参数的 Bulk_quote 构造函数如下所示∶

```C++
Bulk_quote(const std::string& book, double p, std::size_t qty, double disc):
Quote(book, p), min_qty(qty), discount(disc) {} 
```

该函数将它的前两个参数（分别表示 ISBN 和价格）传递给 Quote 的构造函数，由 Quote 的构造函数负责初始化 Bulk_quote 的基类部分（即 bookNo 成员和 price 成员）。当（空的）Quote 构造函数体结束后，我们构建的对象的基类部分也就完成初始化了。接下来初始化由派生类直接定义的 min_qty 成员和 discount 成员。最后运行 Bulk_quote 构造函数的（空的）函数体。

除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分。

> Note! 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员.

#### 派生类使用基类的成员

派生类可以访问基类的公有成员和受保护成员

```C++
// 如果达到了购买书籍的某个最低限量值，就可以享受折扣价格了
double Bulk_quote::net_price(size_t cnt) const
{
  if (cnt >= min qty)
		return cnt * (1 - discount)* price;
  else
		return cnt* price;
}
```

该函数产生一个打折后的价格：如果给定的数量超过了 min_qty，则将 discount （一个小于1大于0的数）作用于 price。

我们将在 15.6节进一步讨论作用域，目前只需要了解派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员（例如min_qty 和 discount）的方式与使用基类成员（例如 price）的方式没什么不同。

>**关键概念：遵循基类的接口**
>
>必须明确一点∶每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。
>
>因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。

#### 继承与静态成员

如果基类定义了一个静态成员（参见7.6节），则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对干每个静态成员来说都只存在唯一的实例。

```C++
class Base{
public:
	static void statmem ();
};
class Derived : public Base {
	void f (const Derived&);
};
```

静态成员遵循通用的访问控制规则，如果基类中的成员是 private 的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它：

```C++
void Derived::f(const Derived &derived_obj)
{
	Base::statmem(); // 正确∶ Base定义了 statmem 
	Derived::statmem (); // 正确∶ Derived继承了 statmem 
	// 正确∶派生类的对象能访问基类的静态成员
	derived_obj.statmem(); // 通过 Derived对象访问
  statmem();  //通过 this 对象访问
}
```

#### 派生类的声明

派生类的声明与其他类差别不大（参见7.3.3节），声明中包含类名但是不包含它的派生列表：

```C++
class Bulk_quote ∶ public Quote; // 错误∶派生列表不能出现在这里
class Bulk_quote; // 正确∶声明派生类的正确方式
```

一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类、一个函数或一个变量等。派生列表以及与定义有关的其他细节必须与类的主体一起出现。

#### 被用作基类的类

如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明：

```C++
class Quote; // 声明但未定义
// 错误∶Quote必须被定义
class Bulk_quote : public Quote { ...};
```

这一规定的原因显而易见∶派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身。

一个类是基类，同时它也可以是一个派生类：

```C++
class Base {/* ...*/};
class D1 : public Base {/* ...*/};
class D2 : public D1 { /*...*/};
```

在这个继承关系中，Base 是 D1 的**直接基类**，同时是 D2 的间接基类。直接基类出现在派生列表中，而间接基类由派生类通过其直接基类继承而来。

每个类都会继承直接基类的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又含有其基类的成员；依此类推直至继承链的顶端。因此，最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。

#### 防止继承的发生

有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final：

```C++
class NoDerived final {/**/); // NoDerived 不能作为基类
class Base {/**/ }; 
// Last是final的;我们不能继承 Last
class Last final : Base {/**/ };  // Last不能作为基类
class Bad : NoDerived {/* */ }; // 错误∶ NoDerived是 final的
class Bad2 : Last { /**/ }; // 错误∶Last 是 final的
```

