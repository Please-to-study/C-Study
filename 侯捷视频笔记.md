# 1. C++面向对象高级开发

## 1.1 基础知识点补充

Header（头文件）中的防卫式声明：

```C++
#ifndef __COMPLEX__
#define __COMPLEX__
.....
  文件内容主体
.....
#endif
```

相同 class 的各个 objects 互为友元

```C++
class complex 
{
public:
  complex(double r = 0, double i = 0): re(r), im(i) {}
  int func(const complex& param)
  {
    return param.re + param.id;
  }
private:
  double re, im;
};
{
  complex c1(2,1);
  complex c2;
  c2.func(c1);
}
```

临时对象： typename ();

函数的参数和返回类型尽量使用引用。

new操作符的原理：

![](https://cdn.pkubailu.cn/img/new的原理.png)

delete操作符的原理：

![](https://cdn.pkubailu.cn/img/delete原理.png)

动态分配array的内存图（在VC编译器下）：

![](https://cdn.pkubailu.cn/img/动态分配array的内存图.png)

delete 操作忘记加 [] 符号的内存泄漏图：

![](https://cdn.pkubailu.cn/img/array new 一定要搭配 array delete.png)

static 使用要点：

![](https://cdn.pkubailu.cn/img/static补充.png)

单例模式：

![](https://cdn.pkubailu.cn/img/单例模式.png)

cout 补充：

![](https://cdn.pkubailu.cn/img/cout补充.png)

namespace 补充：

![](https://cdn.pkubailu.cn/img/namespace补充.png)

## 1.2 类与类之间的关系

### 1.2.1 复合关系

以 queue 数据结构为例讲解复合关系：

![](https://cdn.pkubailu.cn/img/复合关系（has a）.png)

![](https://cdn.pkubailu.cn/img/复合关系下的构造和析构1.png)

### 1.2.2 委托关系

![](https://cdn.pkubailu.cn/img/委托关系.png)

### 1.2.3 继承关系

![](https://cdn.pkubailu.cn/img/继承关系.png)

![](https://cdn.pkubailu.cn/img/继承关系下的构造和析构.png)

![](https://cdn.pkubailu.cn/img/继承与virtual.png)